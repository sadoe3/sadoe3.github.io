---
title: "Chapter 17"

categories:
    - cpp

tags:
    - [C++, Programming Language, tuple, regular expression, random, IO]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-20
---

# Specialized Library Facilities

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## The tuple Type
A `std::tuple` is a template that is similar to a `std::pair`
- like `std::pair`, it can have members whose types vary from one `tuple` type to another
- unlike `std::pair`, it can have any number of members
- a `std::tuple` is most useful when we want to combine some data into a single object but do not want to bother to define a data structure to represent those data 
- it's defined in the `<tuple>` header

### Operations On tuples
The following table shows the operations of `std::tuple`
||Operations on `std::tuple`|
|:---|:---|
|`tuple<T1, T2, ..., Tn> t;`|`t` is a `std::tuple` with as many members there are types `T1` ... `Tn`. the members are value initialized|
|`tuple<T1, T2, ..., Tn> t(v1, v2, ..., vn);`|`t` is a `std::tuple` with types `T1`...`Tn` in which each members is initialized from the corresponding initializer, vi. this constructor is `explicit`|
|`make_tuple(v1, v2, ..., vn)`||
|``||
|``||
|``||
|`get<i>(t)`|as usual, the index starts at 0|
|``||
- the following codes show the example of the use of `std::tuple`
```c++
#include <tuple>
auto item = std::make_tuple(3, "haha", 7.02);
std::get<0>(item) /= 3;         // the first element is now 1
```

## The bitset Type
If you want to handle the collections of bits that are larger than the longest integral type, **std::bitset** class which is defined in the `<bitset>` header would be a good solution

## Regular Expressions
A **regular expression** is a way of describing a sequence of characters

### Regular Expression Library Components
The C++ regular-expression library (RE library) is defined in the `<regex>` header
- the following table shows the components of the library

||Regular Expression Library Components|
|:---|:---|
|`regex`|class that represents a regular expression|
|``||
|``||
|``||

### more about regular expressions


## Random Numbers
Prior to the new standard, both C and C++ relied on a simple C library function named `rand`
- that function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system-dependent maximum value that is at least 32767
    * the `rand` function has several problems :
        + many, if not most, programs need numbers in a different range from the one produced by `rand`
        + some applications require random floating-point numbers
        + some programs need numbers that reflect a nonuniform distribution
- to solve these problems, the library defines the `<random>` header which contains a set of cooperating classes :
    * **random-number engines**
        + an engine is a type that generates a sequence of random `unsigned` integers
    * **random-number distributions**
        + a distribution is a type that uses an engine to return numbers according to a particular probability distribution
- hence, the C++ programs should not use the library `rand` function
    * instead, they should use the engine with the proper distribution

### Random-Number Engines and Distributions
The random-number engines are function-object classes that define a call operator that takes no arguments and returns a random `unsigned` number
- random-number engines
    * we can generate raw random number by calling an object of a random-number engine type
    * there are several engines defined in the library
        + each compiler designates one of these engines as the `std::default_random_engine` type
        + the list of engines would be covered later in this chapter
    * the following table shows the operations of the engine

    ||Random Number Engine Operations|
    |:---|:---|
    |`Engine e;`|default constructor; uses the default seed for the engine type|
    |`Engine e(s);`|uses the integral value `s` as the seed|
    |`e.seed(s)`|reset the state of the engine using the seed `s`|
    |`e.min()`|the smallest number this generator will generate|
    |`e.max()`|the largest number this generator will generate|
    |`Engine::result_type`|the `unsigned` integral type this engine generates|
    |`e.discard(u)`|advance the engine by `u` steps; `u` has type `unsigned long long`|
    + note that the seed is `std::uint_fast32_t` which is usually just a 32-bit `int`. Every value in the range [0 ~ 2^32) should produce different results
    + using `time()` function defined in the `<ctime>` header as a seed usually doesn't work if the program is run repeatedly as part of an automated process
- random-number distributions
    * to get the properly transformed random number, we need to use the distribution object
    * there are several distributions defined in the library
        + the list of distributions would be covered later in this chapter as well
        + with the exception of the `std::bernouilli_distribution`, the distribution types are templates
        + each of these templates takes a single type parameter that names the result type that the distribution will generate
        + some distribution templates can be used to generate only floating-point numbers; others can be used to generate only integers
        + the distribution templates define the default template parameter
            - the default for the integral distribution is `int`
            - the default for the floating-point is `double`
        + the constructor for each distribution has parameters that are specific to the kind of distribution
            - some of these parameters specify the range of the distribution, such as `std::uniform_int_distribution<IntT> u(m, n)`
            - and these ranges are alwasy **inclusive**, unlike iterator ranges
    * the following table shows the operations of the distribution

    ||Distribution Operations|
    |:---|:---|
    |`Dist d`|default consturctor; makes `d` ready to use|
    |``|other constructors depend on the type of `Dist`; and the distruction consturctors are `explicit`|
    |`d(e)`|successive calls with the same `e` produce a sequence of random numbers according to the distribution type of `d`; `e` is a random-number engine object|
    |`d.min()`|return the smallest number `d(e)` will generate|
    |`d.max()`|return the largest number `d(e)` will generate|
    |`d.reset()`|reestablish the state of `d` so that subsequent uses of `d` don't depend on values `d` has already generated|
- when we refer to a **random-number generator**, we mean the combination of a distribution object with an engine

### Things to Consider
- a given random-number generator always produces the same sequence of numbers
    * a function with a **local** random-number generator should make that generator (both the engine and distribution objects) `static`
    * otherwise, the function will generate the identical seuqnce on each call
- because engines return the same sequence of numbers
    * it's essential that we declare engines **outside** of loops
    * otherwise, we'd create a new engine on each iteration and generate the same values on each iteration
    * similarly, distributions may retain state and should also be defined outside loops

### List of Engines
Explanation ddddd
||Random Number Engines|
|:---|:---|
|`default_random_engine`|type alias for one of the other engines intended to be used for most purpose|
|``||
|``||
|``||

### List of Distributions
Explanation ddddd
||Random Number Engines|
|:---|:---|
|`default_random_engine`|type alias for one of the other engines intended to be used for most purpose|
|``||
|``||
|``||


## The IO Library Revisited

### Formatted Input and Output
The library defines a set of **manipulators** that **modify the format** state of a stream
- manipulators are used for two broad categories of output control :
    * controlling the presentation of numeric values
    * controlling the amount and placement of padding
- most of the manipulators that change the format state provide set/unset pairs
- it's usually best to **undo** whatever changes are made as soon as those changes are no longer needed
    * manipulators that change the format state of the stream usually leave the format state changed for all subsequent IO
- `std::endl` is the typcial example of manipulators
    * which means, you use the other manipulators in the same way we use the `std::endl`

### List of Manipulators
The library defines manipulators in two header files
- `<iostream>`
    ||Manipulators Defined in `<iostream>`|
    |:---|:---|
    |`boolalpha`|display `true` and `false` as strings|
    |``||
    |``||
    |``||
    |``||
    * unless you need to control the presentation of a floating-point number, it's usually best to let the library choose the notation
- `<iomanip>`
    ||Manipulators Defined in `<iomanip>`|
    |:---|:---|
    |`setfill(ch)`|fill whitespace with `ch`|
    |``||
    |``||
    |``||
    * `std::setw`, like `std::endl`, does not change the internal state of the output stream
        + it determines the size of only the next output
    
### Unformatted I/O Operations
The library provides a set of low-level operations that support **unformatted IO**
- Single-Byte
    ||Single-Byte Low-Level IO Operations|
    |:---|:---|
    |`is.get(ch)`|put the next byte from the `std::istream` `is` in character `ch`. returns `is`|
    |``||
    |``||
    |``||
- Multi-Byte
    ||Multi-Byte Low-Level IO Operations|
    |:---|:---|
    |`is.get(sink, size, delim)`||
    |``||
    |``||
    |``||
    * it's a common error to intend to remove the delimiter from the stream but to 
    forget to do so
- if you can use the more type-safe, higher-level operations supported by the library, it's usually better to do so

## Random Access to a Stream
The library provides a pair of functions to *seek* to a given location and to *tell* the current location in the associated stream
- random IO is an inherently system-dependent
    * to understand how to use these features, you must consult your system's documentation
- the `std::istream` and `std::ostream` types usually do **not support** random access
    * other types (`std::fstream` or `std::sstream`) **do support**
- to support random access, the IO types maintain a **marker** that determines where the next read (getting) or write (putting) will happen
    * but note that there is only **single** marker, we must do a `seek` to reposition the marker whenever we switch between reading and writing so that it's safe to do so
- the following table shows the random IO functions
    ||Seek and Tell Functions|
    |:---|:---|
    |`tellg()`||
    |`tellp()`||
    |``||
    |``||
    |``||

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}