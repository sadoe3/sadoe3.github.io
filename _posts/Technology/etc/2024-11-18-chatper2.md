---
title: "Git 사용법"

categories:
    - etc

tags:
    - [etc, Git, GitHub, Version Control]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-11-18
---

change ’ to '


## Initial Setting

### What is Git?
- `Git` is a **version control** tool, similar to `SVN`.
- `Git` is particularly useful when working on a project with a team, allowing multiple team members to collaborate effectively.
    - However, `Git` can also be used for individual projects, especially if you want to work on the same project across multiple PCs.

### How to Download & Install Git
- Git can be **downloaded** from the [**official website**](https://git-scm.com/downloads).
- After installation, you can confirm Git is properly installed by running the command `git --version` in the command prompt (`cmd`).
    - If you see a message like `git version 2.33.0.windows.2`, the installation was successful.

### How to setup Git
- Git is used via the **command prompt** (often referred to as the **terminal**).
- To use Git effectively, you’ll need to know basic terminal commands.
- Common Git command syntax is: `git [command] [-option] [--option]`.
    - examples
    - `git status`
    - `git config --list`
    - `git commit -m "message"`
- If you want to open a file in `VS Code` directly from Git, use this method:
    1. Run `git config --global core.editor "code --wait"` in cmd.
    2. When opening a file, `VS Code` will launch.
        * Git will **wait** for you to finish editing and close `VS Code` before it proceeds with further commands.
- You need to set your Git **user name** and **email** to use Git:
    - `git config --global user.name "Your Name"`
    - `git config --global user.email "email@example.com"`
    - You can check if the setup is correct with: `git config user.name`.
- Now you need to configure Git to handle **newline differences** between `Windows`(CRLF) and `Mac/Linux`(LF) systems
    - For Windows: `git config --global core.autocrlf true`
    - For Mac/Linux: `git config --global core.autocrlf input`

### Git Aliases
You can **shorten** Git **commands** using `aliases`:
- Example: `git config --global alias.st status`
    * this lets you run `git st` instead of `git status`.

### How to Learn Git Commands
- Study the [**official Git reference**](https://git-scm.com/docs) for comprehensive documentation.
- For command help, use `--help` (e.g., `git config --help`) to see available options.


## Git Workflow
Git manages files in three main areas:
- **Working Directory**: Where files are modified.
- **Staging Area**: Files added for version control.
- **`.git` Directory**: Git’s internal storage for version data. You can think of this as **Git Respository**

The typical workflow involves:
1. Files in the **Working Directory** are modified.
2. After editing, files are added to the **Staging Area** using `git add`.
3. Files in the **Staging Area** are committed to the **`.git` directory** using `git commit`.
4. To sync with a remote server (like `GitHub`), use `git push` to upload your `.git` data.
5. To get changes from a remote server, use `git pull` to update your local repository.

### `.git` Directory
- **Creating a `.git` Directory**:
    - Navigate to your project directory and run `git init` to initialize a new Git repository.
    - Use `dir /a` to confirm that the `.git` directory was created.
- **Removing the .git Directory**:
    - You can delete the `.git` directory manually via the file explorer, or run `rd /s .git` in cmd.

### Tracked or Modified file
When a file is added to Git for the **first time**, it becomes an **untracked file** and exists in the **working directory**.
- By using the `add` command on an untracked file, it becomes a **tracked file** and moves to the **staging area**.
- When a **tracked file** is **modified**, it becomes a **modified file**, and the version of the **file before modification** remains in the **staging area**, while the newly **modified version** exists in the **working directory**.
    * In other words, the **same file exists** in **both** the working directory and staging area before and after modification.
    * In this case, if the `add` command is used, the **modified file** in the working directory becomes a **tracked file**, and the **pre-modified tracked file** that was in the staging area **disappears**.
        + the **newly tracked file** from the **working directory** is then moved to the **staging area**.

### Git Status
`git status` shows the current state of files, including untracked and modified files so that you can choose which files to `commit`.


## .gitignore file
In Git, if you **don't want** to include certain files in **version control**, you can add the names (including extensions) of those files to a `.gitignore` file.
- This will **prevent** those files from showing up in the `git status` untracked file list or anywhere else.
    * In other words, whether the files **exist** or not, or whether they change or not, Git will simply **ignore** them.
- There are several ways to create a `.gitignore` file.
- One method is as follows:
    1. Open **Windows Explorer** and set it to show file **extensions**.
    2. Navigate to the folder that contains the **`.git` directory**.
    3. Create a new **text file** in that folder and remove the name including **extension**, **renaming** it to `.gitignore`.
    4. This will create a `.gitignore` file in Windows.
    5. Once created, double-click the `.gitignore` file to open it.
        * You can then use a program like `VS Code` or `Notepad` to open and edit the file.
        * Add the names of the files you want to ignore, then save the file.
- In the `.gitignore` file, you can add more than just specific file names:
    - `log.log` (a specific file name, including its extension)
    - `*.log` (all files with the `.log` extension)
    - `build/` (all files inside the `build` folder)
    - `build/*.log` (all files with the `.log` extension inside the `build` folder)
    - `# comment` (you can also add comments using `#`)


## Using Git Locally
1. Initialize a **`.git` directory** in `your project folder` and **configure Git** based on the concepts covered above.
2. As you make changes, use `git add` to stage new or modified files.
    - Example: `git add NameC.txt`
    - Ways to add multiple files with `git add`:
        * Specify each file individually: `git add NameA.txt NameB.txt`
        * Specify all files with the same extension: `git add *.txt`
        * add all changes: `git add .`
    - If you want to move files from the staging area back to the working directory
        * you can use `git rm --cached *`.

3. Commit changes with `git commit`
    - When you run the command `git commit`, the text editor defined in your initial configuration (e.g., `VS Code`) will open with a file named `COMMIT_EDITMSG`.
    - In this message file:
        * The **first line** should contain the **commit title** (a **brief summary** of the commit).
            + This title is referred to as the **commit message**.
            + The title should start with a **verb**, similar to how a function name would be written.
        * From the second line onwards, you should provide **details** about the changes made in the commit.
    - Once you're done, save and close the message file, and the commit will be completed.
    - You can **view** all your **commit messages** later by running the command `git log`, which will display the commit messages you wrote during each commit.
4. Push them to a remote repository with `git push`.
5. Pull them to get updates from a remote respository with `git pull`

### Simplified Commit Workflow
You can **bypass** the `text editor` or `add` when committing:
- Use `git commit -m "message"` to commit with a message directly.
- Use `git commit -am "message"` to commit after automatically staging modified files.
    * with this command, you don't need to call `add` before calling `commit`

### Commit Best Practices
When making a `commit`, you should **not** commit the **entire project** at once.
- Instead, divide the project by features and **commit** each time **a feature** is `added`, `changed` or `removed`.
- Additionally, if the **commit message** does **not fully describe** the changes, **version control** will become much more **difficult later**.
    * Therefore, when committing, ensure that the **commit message accurately represents** the changes made.


## Git and GitHub
If you understand the concepts so far, you should be able to easily use Git on your local PC.
- However, Git is typically used with `GitHub` for version control, so now let's look at how to use Git with `GitHub`.
- `GitHub` is a server-like service that manages **remote repositories**.
- After creating a specific repository on GitHub, various people can copy that repository to their working directories on their PCs.
    * This process is called `cloning`.
- When the repository is first created, it starts with `version 1`.
- After cloning the repository, everyone who cloned it will have their own version of the repository in their working directory, but this will be `version 2` of the repository.
    * In other words, when you clone or pull, you get a version of the repository that is `+1` from the GitHub version.
- After making changes in your working directory to align the project as needed, you can `commit` the changes.
    * This prepares the modified files on your local PC to be **uploaded** to the GitHub repository.
- After committing the changes, use the `push` command to **upload** your changes to the GitHub repository.
    * However, you can only `push` if the version of your local repository is **one version ahead** of the version on GitHub.
    * Which means that you **can't** `push` if your version is `2` and the server's version is `2` or `3`.
        + you can do it only if the server's version is `1`
- Once the `push` is **successful**, the GitHub repository will be updated to match the version you pushed.
    * This means that the **GitHub repository** is now at `version 2`.
    * Moreover, your version is now incremented to `version 3`.
- When others who cloned the repository (`version 1`) and were working with `version 2`, they will need to use the `pull` command to update their local repository to `version 3`.
    * If they **don't do** this, Git will **block** the `push` because they're trying to update `version 2` with another `version 2`.
    * This situation is known as a **merge conflict**, and there are methods for resolving it, which I'll explain below.
- The `pull` command is a combination of the `fetch` and `merge` commands.
    * The command `git fetch origin` fetches the **changes information** from the repository at the URL `origin`
        + It's worth noting that `fetch` does **not modify** the **`.git` directory**.
    * The `git merge` command then **takes the changes** fetched by `git fetch` and applies them to the `.git` directory on your local PC.
    * So, the combined command `git pull origin` fetches changes from `origin` and applies them to your local `.git` directory.
- Once `pull` is successful, your local repository will be one version ahead of the GitHub repository, and you will be able to **push** your changes.

### Forking on GitHub
- `Forking` allows you to copy a repository to your own GitHub account, enabling you to make changes independently.


## Connecting Git and GitHub
1. Create a folder on your local machine for your GitHub project.
    - `cd` to that directory in the **terminal**.
2. Clone the repository from GitHub using `git clone [url]`.
    - if you don't have it, create the repository in your Github account
    - you can get the `[url]` by clicking the **button** named `code`
    - the cloned repository would exist in the new folder
3. Configure Git that I mentioned [here]()
4. Register the **nickname** `origin` to make it easier to use the **remote repository URL** in the terminal by using this code:
    - `git remote add origin <url>`
    - You can use a name other than `origin`, but it is **common practice** to use `origin` for the remote URL.
    - You can check the URL associated with `origin` by running the command `git remote -v`.
    - Once you're done, you can **remove** the `origin` by using the command `git remote remove origin`.
5. Push changes to GitHub with `git push origin` and pull updates with `git pull origin`.


## Resolving Merge Conflicts
When a **merge conflict** occurs, `push` is **not allowed**.
- To identify which parts have been changed, you first need to `pull` the updated repository.
- After performing the `pull`, any files with merge conflicts in the working directory will contain **changes** from **both** your `local PC` and the `updated repository` on GitHub.
- The section between `<<<<<<< HEAD` and `=======` represents
    * the changes made **locally**
- and the section between `=======` and `>>>>>> refs/remotes/origin/main` (this part may vary depending on the situation)
    * represents the changes from the **remote** repository.
- By comparing the two conflicting files, you’ll notice that the code block **starts** at the **first difference** and **ends** at the **last difference**.
    * Within this block, there may be **identical sections** in both versions.
- To **resolve** the conflict, you can either **remove** one version or appropriately **combine** the two (change both files to the same code), based on your goals.
    * After resolving the conflict, `commit` the changes and `push` them to complete the merge.
- Once the conflict is properly resolved, the final code should have the `<<<<<<< HEAD`, `=======`, and `>>>>>> refs/remotes/origin/main` markers **completely removed**.


## GitHub and VS Code
Github와 VS Code를 함께 사용하면, git를 사용하는 방법이 크게 두가지로 나뉘게 된다. <br>
1. 기존 방식인 terminal을 이용하여 git을 사용하는 방법
    - 이 방법은 VS Code에서 GitHub repository에 있는 내용을 변경한 뒤, terminal에서 `cd`를 이용하여 clone되어 있는 해당 repository로 이동한 뒤, `push` 및 `pull`을 수행하는 방식
    - 일반적인 git 사용법과 동일하기 때문에 익숙하다는 장점이 있지만, 아래에서 소개할 2번째 방법에 비해서는 비교적 불편함
2. VS Code의 기능을 이용하여 git를 사용하는 방법
    - 이 방법은 엄청 편하긴 하지만, 기존의 git사용법과 다르기 때문에 새로운 내용을 배워야 한다는 것이 단점임
    - 그렇지만 배우기만 해두면 엄청 편하게 git을 사용할 수 있게 되어서, 왠만하면 이 방법은 알아두는게 좋다

## VS Code의 기능을 이용하여 git를 사용하는 방법
- cloning도 VS Code에서 할 수 있지만, cloning은 terminal에서 하는 것이 좀더 직관적이라, cloning은 굳이 정리하지 않았다.
- 즉, cloning된 이후 VS Code에서 `push`하는 방법과 `pull`하는 방법을 정리해보았다.
- VS Code에서 `push` 하는 방법
1. cloning된 repository를 적절히 변경한다.
2. VS Code의 좌측 화면을 보면, 5개의 버튼이 있는데, 그중 가운데에 Source Control이라는 버튼있다. 해당 버튼을 누른다.
3. Source Control에서는 수정된 파일들이 Changes category에 존재하게 되는데, 해당 category의 좌측부분에는 +버튼이 존재한다.
    - 해당 버튼을 누르면, Stage All Changes가 적용이 되어, 변경된 모든 파일들이 `add`되게 된다.
    - 전부 `add`하고 싶지 않은 경우에는 Changes category안에 있는 파일들 중 원하는 파일들의 좌측부분에 있는 +버튼을 눌러 `add`해 주면 된다.
4. 이후 Source Control panel의 우측 상단을 보면 체크표시가 되어있는 버튼이 있는데, 해당 버튼을 누르게 되면, `commit`이 된다.
    - 이때, 해당 버튼을 누르게되면, VS Code의 중앙 상단에 commit message를 입력하는 칸이 생기게 되고, 거기에 적절한 commit messsage를 입력한 뒤, enter를 누르면 `commit`이 된다.
5. `commit`을 하고 난 뒤, Source Control panel의 우측 상단에 ...으로 구성된 버튼이 있는데, 해당 버튼을 누르고, Push 버튼을 누르면 `git push origin`가 된다.
- VS Code에서 `pull` 하는 방법
1. 다른 곳에서 해당 repository가 변경된다.
2. Source Control 버튼을 누른뒤, Source Control panel의 우측 상단에 ...으로 구성된 버튼이 있는데, 해당 버튼을 누르고, Pull 버튼을 누르면 `git pull origin`이 된다.
- 추가적으로, 만약에 origin을 대상으로 command를 수행하고 싶지 않은 경우에는 ...으로 구성된 버튼을 누르고, Pull, Push 버튼을 누른 뒤, Pull from 버튼이나 Push to 버튼을 눌러서 특정 url을 대상으로 해당 command를 수행할 수 있다.
- 또한, 특정 파일의 변경사항을 `discard`하고 싶은 경우, Changes category에서 해당 파일의 우측부분에 뒤로가기 같은 버튼을 누르면 해당 파일에 대한 변경이 `discard`된다.
- 마지막으로, 해당 repository를 대상으로 terminal를 이용하여 git을 사용하고 싶은 경우에도, 만약에 VS Code에 해당 repository가 열려있는 경우라면, VS Code menu에서 `Terminal -> New Terminal`을 누르게 되면, VS Code에서 clone된 해당 folder로 `cd`가 되어있는 terminal이 열리게 됩니다.
    - 이후, VS Code에 있는 해당 terminal에서 기존에 terminal에서 사용했던 방법으로 git을 사용하면 된다.
- 그래서 최종적으로 VS Code의 기능을 이용해서 git을 사용하는 것이 훨씬 편하기 때문에, 이 방법을 제대로 숙지한 후, 앞으로도 VS Code의 기능을 이용하여 git을 편하게 사용하면 된다. 

## VS Code에서 Merge Conflict 해결하는 방법
- 특정 file에서 merge conflict가 발생하게 되면, VS Code에서 Source Control 버튼을 누르면 Merge Changes category안에 merge conflict가 발생된 file들이 존재하게 된다.
- 이후 해당 file들을 더블클릭히여 열게되면, HEAD, =====, \>\>\>\>으로 나누어진 두 파트의 code block들을 볼 수 있다.
- 위쪽에 있는 current change는 내 pc에서 변경된 내용이고, 아래쪽에 잇는 incoming change는 github server에서 변경된 내용이다.
- HEAD가 있는 줄의 바로 위쪽을 보면, Accept Current Change, Accept Incoming Change 등의 기능을 할 수 있는 4가지 hyperlink text가 있는 것을 알 수 있다.
- 여기서 내 변경사항을 진행시킬거면 Accept Current Change를 눌러주면 되는데, 이렇게 되면 내 변경사항만 남고, github server에서 변경된 내용은 사라지게 된다.
- 이런식으로 하나씩 merge conflict가 발생된 부분들을 해결해주면 된다.
- 이렇게 해서 파일을 저장한 뒤, 다시 모두 `add` 및 `commit` 시키고, `push`를 해주면 해결할 수 있다.
- 이렇게 하나씩 해결할수도있지만, merge가 발생된 file을 우클릭하면 incoming이나 current의 변경사항 중 하나의 변경사항을 선택하여, merge된 곳 전부에 해당 사항을 적용하게 할수도있다.
- 뭔가 심각하게 꼬인경우에는, 그냥 다 지우고, 다시 `cloning`을 할 수도 있지만, `git status`로 현재 상태를 파악한뒤, terminal에서 제공하는 hint를 기반으로 적절히 `git pull`과 `git push`를 사용해서 merge conflict를 해결할수도 있다. 

## Github의 commit 내용들 보는 방법
- Github desktop application을 설치해서 확인 할 수도있지만, 이 program을 사용하지 않는 상황이라면, 그냥 Github site들어가서, login 한뒤, 해당 repository로 들어가면, code button 같은 것들이 있는 줄 바로 밑에 가장 최근에 `commit`된 내용을 볼 수 있다.
- 해당 줄의 우측을 보면, 시계 icon과 지금까지 `commit`된 숫자를 볼수있는데, 해당 icon이나 숫자를 click하게 되면, 해당 project에서 지금까지 `commit`된 내역을 볼 수 있다.

## Github로 관리되는 Unity project에 Nuget 설치할 때 주의할 점
- Nuget for Unity는 package manager에서 찾을 수 없어서, Internet에서 다운 받고, custom package로 import해야되는데, 이미 누군가 import를 한뒤, `push`한 project를 `pull`하게 되면, 내 pc에서 Nuget for Unity package를 import 하려고해도, Nothing to import라고 뜨면서 import가 안되게 된다.
- 이때에는 그냥 해당 project를 껏다가 다시 키면, 자연스럽게, 내 pc에 있는 project에도 Nuget for Unity가 설치된다.
    - 또한 이렇게 되면, 이미 다른 사람이 설치한 API도 같이 자동적으로 설치가 된다.

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}