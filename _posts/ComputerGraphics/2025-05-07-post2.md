---
title: "Computer Graphics: Materials"

categories:
    - graphics

tags:
    - [computer graphics, graphics, materials, ray tracing, physics, 3D math, vector, matrix, linear algebra]

toc: true
toc_label: "Table of Contents"
toc_sticky: true
mathjax: true

date: 2025-05-07
---

# Materials
This report explains the fundamental concepts of implementing various materials—diffuse, metallic, and dielectric-in a ray tracing renderer.

## **Ray Tracing**
- Before diving into the materials, it is crucial to understand the core principles of ray tracing at first.

### **Forward vs. Backward Path Tracing**
- In the real world, light rays originate from light sources and travel through a scene, bouncing off surfaces until they reach an observer's eye.
    - This process is known as **light tracing** or **forward path tracing**.
- However, directly simulating this is computationally inefficient.
    - Only a minuscule fraction of the light rays emitted from a source will ever reach the camera, resulting in wasted computation.
- While forward path tracing can be effective for specific scenarios like rendering caustics, most modern ray tracers use a different approach.
    - **Backward path tracing** (or simply "path tracing") works in the opposite direction.
    - It casts rays from the camera (or eye) into the scene.
- This approach is significantly more efficient.
    - Because it ensures that every ray calculated contributes to a visible pixel on the screen.
- In this model, a ray is traced from a pixel on the camera's sensor into the scene.
    - If the ray intersects an object, a new ray is scattered from that intersection point.
        - This process continues recursively until the ray either hits a light source, or a maximum bounce limit is reached.
    - If the ray ultimately hits a light source,
        - it carries a contribution of that light's color back to the camera, which is then attenuated by the properties of each surface it interacted with.
    - If the ray never hits a light,
        - it is assigned a default background color (often black).

### **Diffuse Albedo**
- The **diffuse albedo** is a material property that defines the percentage of incoming light that a surface reflects uniformly in all directions.
- For example, a surface with an albedo of $[0.3, 0.7, 1.0]$ will absorb $70\%$ of the red, $30\%$ of the green, and $0\%$ of the blue components of the incoming light.
    - The remaining light, modulated by the albedo, is what gives the object its color.

### **Light Intensity**
- The intensity of light received by a surface depends on the angle between the surface normal and the incoming light ray.
    - The maximum intensity is achieved when the light ray is parallel to the surface normal, and it decreases as the angle increases.
- This relationship is described by **Lambert's Cosine Law**.
    $$
    I_{reflected} = I_{original} * cos\theta
    $$
    - The angle $\theta$ is the angle between the surface normal and the incoming light ray.
    - The intensity is typically constrained to be non-negative by utilizing a function such as $max(0,cos\theta)$.

### **Recursive Calculation**
- To calculate the final color of a pixel, ray tracers use a recursive function.
    - A ray is traced from the camera, and at each bounce, the color is determined by a product of the surface's properties and the color from the subsequent ray.
- The core recursive formula can be generalized as:
    $$
    \text{color}_{\text{reflected}} = \text{intensity}_{\text{light}} \times \text{albedo}_{\text{current}} \times 
    \text{color}_{\text{incoming}}
    $$
    - This formula describes a series of modulations.
    - Initially, the **color of the incoming ray** is multiplied by the **diffuse albedo** of the intersected surface.
        - This multiplication simulates the absorption and reflection of each RGB component.
    - The result is then attenuated by the **light intensity**, a scalar value derived from the angle of incidence.
    - The final product of these operations determines the color of the reflected ray.
- The recursion terminates in one of three cases:
    1. **A ray hits a light source**
        - The recursion ends, and a color of light source (e.g., white) is returned.
    2. **A ray hits nothing**
        - The recursion ends, and a background or skybox color is returned.
    3. **The maximum recursion depth is reached**
        - The ray is assumed to have lost all its energy, and the function returns black.
        - This is a crucial optimization to prevent infinite loops and limit computation.
            - A common maximum depth is between 5 and 10 bounces.


## **Light Absorption and Filtering**
- The color of a ray is not a constant value.
    - It is a cumulative property that is filtered at each surface it interacts with.

### **Scenario 1: Ray Annihilation**
- A ray can effectively "die" if it is filtered by a surface that completely absorbs its color components.
- **Initial state**
    - A white ray (RGB = $[1, 1, 1]$)
- **Bounce 1**
    - The ray hits a pure red object (albedo $[1, 0, 0]$).
    - The ray's color becomes red, losing its green and blue components.
- **Bounce 2**
    - The now-red ray hits a pure green object (albedo $[0, 1, 0]$).
    - The object absorbs all red light, and since there are no green or blue components left in the ray, the ray's color becomes black (RGB = $[0, 0, 0]$).
    - The ray effectively dies and no longer contributes to the final image.

### **Scenario 2: Ray Survival**
- If a ray's color and an object's albedo have overlapping color components, the ray can survive multiple bounces, albeit with reduced intensity.
- This is what creates complex and realistic colors.
    - **Initial state**
        - A white ray (RGB = $[1, 1, 1]$).
    - **Bounce 1**
        - Hits a reddish object (albedo $[0.8, 0.2, 0.2]$).
        - The ray becomes a reddish light.
    - **Bounce 2**
        - Hits a greenish object (albedo $[0.3, 0.7, 0.3]$).
        - The ray becomes a dimmer, mixed-color light.
    - **Bounce 3**
        - Hits a bluish object (albedo $[0.4, 0.4, 0.8]$).
        - The ray's final color is a very dim, mixed-color light.
- The final pixel value is the cumulative result of all these color-filtering interactions, which is why a single ray's journey through a scene is what determines the final pixel's color.


## **Reflection in Ray Tracing**
- Ray tracing simulates how light interacts with surfaces by calculating the paths of light rays.
    - The behavior of these rays upon hitting an object depends on the object's material properties.
- This section details the implementation of three fundamental reflection models
    - diffuse (Lambertian)
    - specular (Metal)
    - and a combination of the two (Fuzzy Reflection).

### **Diffuse (Lambertian) Reflection**
- Diffuse reflection is characteristic of matte, non-shiny surfaces.
    - Light hitting a diffuse surface is scattered in many directions across a hemisphere, with the intensity of the scattered light being greatest along the surface normal.
- To accurately simulate this behavior, ray tracers often use **cosine-weighted hemisphere sampling**.
    - This technique generates a new, random reflected ray with a higher probability of its direction being closer to the surface normal.
    - This weighting is critical because light rays reflected at a shallow angle to the surface (grazing angles) contribute less to the overall scene illumination.
- A common implementation method involves:
    1. **Generating a random point** within a unit sphere, rejecting points that are too close to the sphere's center.
    2. **Normalizing this vector** to ensure its length is 1, so it lies on the surface of the unit sphere.
    3. **Ensuring the vector is outward-facing** by checking its dot product with the surface normal. If the dot product is negative, the vector is inverted to ensure it points away from the surface. This guarantees the reflected ray remains within the hemisphere above the surface.
- This process provides a computationally efficient way to generate physically plausible diffuse reflections.

### **Specular (Metal) Reflection**
- Specular reflection occurs on polished, mirror-like surfaces where light is not scattered but is instead reflected in a single, predictable direction.
    - The law of reflection states that the angle of incidence equals the angle of reflection.
- The direction of a perfectly reflected ray can be calculated using the following formula, which is derived from vector mathematics:
    $$
    v_{reflected}=v_{incident}−2(v_{incident}\cdot n)n
    $$
    - where:
        - $v_{incident}$ is the normalized incoming light vector.
        - $n$ is the normalized surface normal vector at the point of intersection.
    - The dot product ($v_{incident}\cdot n$) ensures the correct projection of the incident vector onto the normal, which is crucial for determining the reflected direction.
- For a dot product to correctly determine the reflection direction, it is essential that both the incident vector and the normal vector point away from the surface, or both point toward it.
    - It's standard practice to use the incoming ray direction (which points toward the surface) and an inverted normal vector for a consistent calculation.

### **Fuzzy Reflection**
- Fuzzy reflection is a model for simulating less-than-perfectly-polished metallic surfaces, such as brushed or scuffed metals.
    - This model introduces a degree of randomness to the specular reflection, scattering the reflected ray around the ideal specular direction.
- This effect is achieved by adding a small, random perturbation to the perfectly reflected ray vector.
    - The magnitude of this perturbation is controlled by a **fuzziness parameter**, which effectively represents the radius of a sphere centered on the ideal reflection vector's endpoint.
- The formula for the scattered ray is as follows:
    $$
    v_\text{scattered}=v_\text{unit\_reflected}+f_\text{fuzziness}\cdot v_{\text{random}}
    $$
    - where:
        - $v_\text{unit\_reflected}$ is the normalized, perfectly reflected vector.
        - $f_\text{fuzziness}$ is the scalar fuzziness parameter.
        - $v_\text{random}$ is a random unit vector.
- An important implementation detail is ensuring that the scattered ray's direction points outward from the surface.
    - A simple check using the dot product between the scattered vector and the surface normal can be performed to absorb any rays that scatter back into the object.












[Top](#){: .btn .btn--primary }{: .align-right}
