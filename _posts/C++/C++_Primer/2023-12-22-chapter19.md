---
title: "Chapter 19"

categories:
    - cpp

tags:
    - [C++, Programming Language, memory allocation, RTTI, enum, pointer to class member, nested class, union, local class, bit-field, volatile]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-22
---

# Specialized Tools and Techniques

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Controlling Memory Allocation

### temp
temp
- temp


## Run-Time Type Identification

### temp
temp
- temp


## Enumerations
**Enumerations** let us group together sets of **integral** constants
- like classes, each enumeration defines a new type
    * and they are **literal** types

### Scoped and Unscoped Enumerations
C++ has 2 kinds of enumerations
- **scoped** enumerations
    ```c++
    // example of scoped enumerations
    enum class Color { RED, GREEN, BLUE };
    Color a = RED;              // error;
    Color a = Color::RED;       // ok;
    ```
    * the `class` keyword can be changed to `struct`
    * **enumerator** is the value defined inside the enumeration body
- **unscoped** enumerations
    ```c++
    // example of unscoped enumerations
    enum Color { RED = 6, GREEN, BLUE };    // GREEN = 7, BLUE = 8
    Color a = BLUE;              // ok;
    Color a = Color::BLUE;       // ok;
    ```
    * the **unscoped** enumerations may have the **empty** name
- by default, enumerator values start at 0 and each enumerator has a value 1 greater than the preceding one 
- enumerators are `const`
    * and, if they are initialized, their initializers must be **constant expressions**
    * consequently, each enumerator is itself a **constant expression**
- note that you **cannot redefine** the enumerators in the same scope
    ```c++
    enum Color { RED, GREEN, BLUE = 3 };
    enum RGB { RED, GREEN, BLUE = 3 };              // error; redefine enumerators
    enum class ScopedRGB { RED, GREEN, BLUE = 3 };  // ok; enumerators are hidden

    constexpr Color eyes = BLUE;                      // ok;
    constexpr Color eyes = 3;                         // error; wrong type; int is used
    constexpr ScopedRGB eyes = BLUE;                  // error; wrong type; Color::BLUE is used
    constexpr ScopedRGB eyes = ScopedRGB::BLUE;       // ok;
    ```
    * also note that although two different enumerations have enumerator which contains the same name, the two enumerators are different because the two enumerations are different types
        + same rule is applied to the built-in types (espeically for `int`) as well
        + although the enumerator has the same value as the `int` literal, they are different
- although each `enum` defines a unique type, it is represented by one of the built-in integral types
    * and, we may specify that type by following the `enum` name with a colon and the name of the type we want to use
    ```c++
    enum IntValues : unsigned long long { charType = 255, shortType = 65535 };
    ```
    * if we do not specify the underlying type, then by default the **scope** `enum`s have `int` as the underlying type
    * there is **no default** for **unscoped** `enum`s
        + we just know that the underlying type is large enough to hold the enumerator values
    * it's an error for an enumerator to have a value that is too large to fit in that type when the underlying type is specified (including implicitly specified for a scoped `enum`)
    * with this feature, we can be confident that our program compiled under one implementation will generate the same code when we compile it on another
- we can **forward declare** an `enum`
    ```c++
    enum IntValues : unsigned long long;
    enum struct ScopedRGB;      // uses int by default
    ```
    * an `enum` forward declaration must specify (implicitly or explicitly) the underlying size of `enum`
    * the size of the `enum` must be the same across all declarations and the `enum` definition
    * moreover, we **cannot** declare a name as an unscoped `enum` in one context and **redeclare** it as a scoped `enum` later

## Pointer to Class Member

### temp
temp
- temp


## Nested Classes

### temp
temp
- temp


## union: A Space-Saving Class

### temp
temp
- temp


## Local Classes

### temp
temp
- temp


## Inherently Nonportable Features

### temp
temp
- temp


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}