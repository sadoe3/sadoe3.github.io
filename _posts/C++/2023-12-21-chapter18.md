---
title: "Chapter 18"

categories:
    - cpp

tags:
    - [C++, Programming Language, Exception Handling, Namespace, Multiple Inheritance, Virtual Inheritance]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-21
---

# Tools for Large Programs

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Exception Handling
**Exception handling** allows us to handle problems that arise at run time
- because we've covered the basics of the exception handling in the [previous chatper](https://sadoe3.github.io/cpp/chapter5/), this chapter covers the more detailed information regarding it

### Throwing an Exception
The process to search for the proper `catch` clause is known as **stack unwinding**
- local objects are automatically destroyed during stack unwinding
- the compiler uses the thrown expression to copy initialize a special object known as the **exception object**
    * if the expression has an array or function type, the expression is converted to its corresponding **pointer** type

### Catching an Excpetion
The **exception declaration** in a `catch` clause looks like a function parameter list with exactly **one** parameter
- as in a parameter list, we can **omit** the name of the `catch` parameter if the `catch` has no need to access the thrown expression
- the type can be an lvalue reference but may not be an rvalue reference
- as with a function parameter, the derived-to-base conversion is supported
    * therefore, multiple `catch` clauses with types related by inheritance must be **ordered** from most derived to least derived
- a `catch` clause can pass its current exception object out to another `catch` clause by **rethrowing** the exception
    ```c++
        try {
            try {
                throw std::exception("haha");
            }
            catch (std::exception) {
                throw;          // rethrow the current exception
            }
            catch (...) {       // catch all exception
                std::cout << "aa" << std::endl;     // this clause is skipped
            }
        }
        catch (...) {
            std::cout << "bb" << std::endl;
        }
        // pritns bb
        // because rethrowing leaves current try-catch block
    ```
    * note that when you **rethrow** the exception, expression is not provided
        + because it needs to pass current exception 
    * if you want to catch all exceptions at once, you can do so by providing `...(ellipsis)` for the exception declaration in a `catch` clause
        + because it catches every exception, it must be the last `catch` clause

### Function try Blocks and Constructors
In order to handle the exception from a constructor initializer list, we must write the consturctor as a **function `try` block**
```c++
// example of writing a function try block
ClassName::ClassName(std::string inputName) try : name(inputName) { 
    /* body */ 
} catch(const std::exception &e) {
    // handle the exception
} 
```

### The noexcept Exception Specification
A function can specify that it does not throw exception by providing a `noexcept` specification
- if the function has `noexcept` specifier, then we say that function has a **nonthrowing specification**
- `noexcept` specifier must appear on **all** of the declarations and the corresponding definition of a function or on **none** of them
    * the keyword appears after the parameter list and before the trailing return
    * we may also specify `noexcept` on the declaration and definition of a function pointer
        + it may not appear in a `typdef` or type alias
    * in a member function the `noexcept` specifier follows any `const` or reference qualifiers
        + and it precedes `final`, `override`, or `= 0` on a virtual method
- it's possible that a `noexcept` function **does throw**; it's possible to be compiled
    * however, if it does, `terminate` is called
    * thereby enforcing the promise not to throw at run time
- note that `throw()` has the same meaning as `noexcept` although it's been deprecated in the current stardard
- the `noexcept` specifier takes an optional argument that must be convertible to `bool`
    * if the argument is `true`, then it's saying the function won't throw
    * otherwise, then it's saying the function might throw
    * the arguments to the `noexcept` **specifier** are often composed using the `noexcept` **operator**
        + the operator is an unary operator that returns a `bool` rvalue constant expression that indicates whether a given expression might throw
        + like `sizeof`, `noexcept` does not evaluate its operand
        + `void f() noexcept(g());` :
            - if `g()` doesn't throw an exception then it would be `void f() noexcept(true)`
            - otherwise, `void f() noexcept(false)`

### Exception Class Hierarchies
The `std::exception` is the root of the hierarchy
- there are 4 direct derived classes from it
    * `std::bad_cast`
    * `std::bad_alloc`
    * `std::runtime_error`
        + there are 3 direct derived classes from it
        + `std::overflow_error`
        + `std::underflow_error`
        + `std::range_error`
    * `std::logic_error`
        + there are 4 direct derived classes from it
        + `std::domain_error`
        + `std::invalid_argument`
        + `std::out_of_range`
        + `std::length_error`
- you can implement your own exception class by inheriting from the `std::exception` class or from one of the library classes derived from `std::exception`


## Namespaces



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}