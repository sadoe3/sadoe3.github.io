---
title: "Chapter 5"

categories:
    - cpp

tags:
    - [C++, Programming Language, Statement]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-11-30
---

# Statements

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Prerequisites regarding statements
- this post assumes that you've already studied about statements through learning C
- hence, this post covers only about how the C++ features work with the existing concepts of statements 

### C++ features
- range for
- try-catch blocks

## Range for
```c++
// syntax
for( delcaration : expression ) {
    ... // some codes
} 
```
- `expression` : a sequence(collection) which contains elements of same type at the **continued** memories
    * such as, braced initializer, array, objec which has begin and end method which return the iterators are the collections
- `declaration` : an object which handles the element of the give collection
    * there must be a conversion between the type of a variable and the oen of the sequence
        + hence, just using **auto** type might be useful choice
    * if you want to change the value of the element through the given object, you must set the object as a **reference**
        + `auto & object`
    * otherwise, the object **copies** the element so that you cannot change the element by using the given object
    
## Try-Catch blocks
Try-Catch blocks are related to the exception handling in C++

### Excpetion Handling
Excpetion handling would be covered in the later chapter, but for now some basic concepts are convered through this post
- There are 3 concepts related to exception handling
    1. Exception class
        + The object of the certain exception class has the information regarding current problem
        + There are several standard exception classes in C++
    2. `throw` expression
        + you can notify the program that there's a problem by `throwing` the object the the exception class
            * this is often referred as **raise an exception**
    3. `try-catch` blocks
        + the codes which may **raise an exception** is inside the `try` block
        + one or more `catch` clauses handles the exception
            * hence, catch block is often referred as **exception handler**

### How to throw an exception
The following codes is the example of throwing `runtime_error` exception
```c++
#include <stdexcept>            // must be included to use runtime_error class
...                             // soem codes
throw std::runtime_error("error information");
```
- there are 4 headers which define the standard exception classes
    * `<exception>`
        + this header defines the most general kind of exception class named `exception`
    * `<stdexcept>`
        + this header defines several general-purpose exception classes
    * `<new>`
        + this header defines the `bad_alloc` class which would be covered in the later chapter
    *  `<type_info>`
        + this header defiens the `bad_cast` class  which would be covered in the later chapter
- the following is the standard exception classes defiend in `<stdexcept>` heaer file

|Class Name|Explanation|
|:---:|:---|
|`exception`|the most general kind of problem|
|`runtime_error`|problem that can be detected only at run time|
|`range_error`|run-time error: result generated outside the valid range|
|`overflow_error`|run-time error: computation that overflowed|
|`underflow_error`|run-time error: computation that underflowed|
|`logic_error`|error in the logic of the program|
|`domain_error`|logic error: argument for which no result exists|
|`invalid_argument`|logic error: inappropriate argument|
|`length_error`|logic error: attempt to create an object larger than the maximum size for that type|
|`out_of_range`|logic error: used a value outside the valid range|

- there are 2 types of exception
    * one which must be **default**-initialized
        + `exception`, `bad_alloc`, `bad_cast` are this type of classes
    * one which must be initialized with **initializer**
        + other classes are this type of classes
        + the initializer can be a `string` class or a C-style string which provides the additional information regarding current problem
            - this is why the example initialized the `runtime_error` with the C-style string
- standard exception classes have only a few operations and one member function
    * we can create, copy, and assign them
    * the only member function is `.what()` method which returns a `const char *` that points to a C-style string which was given at initialization phase

### try-catch blocks
```c++
// syntax of try-catch blocks
try{
    ... // some codes which may raise an exception
} catch( exception-declaration ) {
    ... // soem codes which handles the exception
} catch( exception-declaration ) {
    ... // soem codes which handles the exception
}

// example of basid use
#include <stdexcept>

try{
    throw std::runtime_error("this is run-time error");
} catch(std::runtime_error err) {
    std::cout << err.what() << std::endl;
}

// unnamed
try {
    throw std::runtime_error("error message");
} catch (std::invalid_argument) {
    std::cout << "1" << std::endl;
} catch (std::runtime_error) {
    std::cout << "2" << std::endl;
}
// 2 would be printed
```
- `exception-declaration` is an object which is initialized by the exception object raised through `throw` expression 
    * this object may have its name or not
- there is no `finally` clause in C++ unlike Java because of the **RAII**
    * **RAII** is the concept where an object's destructor is responsible for freeing resource
    * this would be covered in the later chapter for sure
- once one of the `catch` clauses is executed, the **control flow** continues to execute the statement following the last `catch` clause of the `try` block
- the search for the handler **reverses** the call chain like **recursion**
    * if there no handler for current excpetion, then the library function called `terminate` is called

### Exception Safety
When an exception is raised, control flow stops executing current statement and jumps to the `catch` clause in order to search for the proper handler
- this may make the object invalid state or it may not be freed
- hence, if you want develop a **robust** program, you need to aware of these cases

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}