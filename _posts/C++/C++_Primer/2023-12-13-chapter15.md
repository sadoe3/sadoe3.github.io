---
title: "Chapter 15"

categories:
    - cpp

tags:
    - [C++, Programming Language, OOP, Inheritance, virtual, dynamic binding]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-13
---

# Object-Oriented Programming

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## OOP: An Overview

### The Key Ideas in OOP
There are 3 core concepts in Object-oriented programming(OOP)
- Data Abstraction
    * using it, we can define classes that separate interface from implementation
    * this concept is related to encapsulation
- Inheritance
    * using it, we can define classes that model the relationships among similar types
- Dynamic Binding
    * using it, we can use objects of these types (which are related to inheritance) while ignoreing the details of how they differ

### Inheritance
Classes related by **inheritance** form a hierarchy
- typically, there is a **base class** at the root of the hierarchy
    * the **base class** defines members that are common to the all types in the hierarchy
- and, the **derived classes** inherit from the **base class** directly or indirectly
    * each derived class defines members that are specific to the derived class itself
    * the following codes show the example of basic definition of the **derived class**
    ```c++
    class Base {
    public:
    ... // some codes
    };
    class Derived : public Base {
    public:
    ... // some codes
    };
    ```
    * the base class of the derived class is specified in a **class deriviation list**, which is a colon followed by a comma-separated list of base classes each of which may have an **optional access specifier**
        + if the access specifier is not provided, the default one is selected
            * `class` = `private`
            * `struct` = `public`

### Virtual Method
If you define a method in the base class as `virtual`, then you can **override** it in the derived class so that same function call yields different result based on which type of argument passed
```c++
class Base {
public:
    virtual void f() const { std::cout << "this is base" << std::endl; }
};
class Derived : public Base {
public:
    void f() const override { std::cout << "this is derived" << std::endl; } 
};
void print(const Base &input) {
    input.f();
}
int main() {  
    Base b;
    Derived d;

    print(b);           // prints Base::f()
    print(d);           // prints Derived::f()

    return 0;   
}
```
- when you define a `virtual` function, place `virtual` keyword before the `return type` of the function
- when you **override** the virtual function place `override` keyword after the `parameter list` or qualifiers, if any

### Dynamic Binding
If a compound type(pointer or reference) to the base class points(refers) to the derived class, the call to the virtual method of the base class may differ if the derived class **overrides** it
- this is called **dynamic binding** because the decision as to which version (based or derived) to run depneds on the type of argument, and that decision can't be made until run time
    * therefore, **dynamic binding** is sometimes known as **run-time binding**
- also, we speak of types related by inheritance as **polymorphic** types because we can use the **"many forms"** of these types while ignoring the differences among them
- however, note that **polymorphism** happens only for the **compound types** to base class, not normal type
    * if the normal object of base class is constructed or assigned by the derived class, only base part is captured and the derived part is **sliced down**

## Defining Base and Derived Classes

### Virtual Keyword
Any non`static` method, other than constructor, may be `virtual`
- the `virtual` keyword appears only on the declaration inside the class and
    * may not be used on a function definition that appears outside the class body
- also, `virtual` keyword doesn't need to be repeated
    * which means, the derived classes don't have to place `virtual` keyword for the base class's `virtual` method

### protected Access Specifier
the `protected` access specifier gives access level between `public` and `private`
- it's like `public` : because its `friend` or **derived class** can use its `protected` members
    * note that friendship is not inherited
    * friends of the base class have no spical access to its derived class
    * and friends of the derived class have no spical access to its base class
- it's like `private` : because the normal user cannot access to its `protected` members 

### Constructors of the Derived Class
You can think that a derived class has two parts : base part and derived part
- when you construct the derived class, its constructor should construct its base part as well
    * hence, the order of execution for initializing the members of the derived class is like this:
        1. the object of the derived class calls its proper constructor to be created
        2. the derived class's constructor class its **direct** base class's constructor
            - if the **direct** base class also has its base class, then it calls the constructor of that class
            - this iteration keeps going until it reaches the root of the hierarchy
        3. the base class's constructor initializes its part, and executes its function body
        4. then, its direct derived class's constructor does its job
            - this iteration keeps going unil it reaches the leaf of the hierarchy
    * note that if you don't call the direct base constructor in the **constructor initializer list**, then the corresponding synthesized version is automaically called in the proper order 
- also note that the calls to `virtual` functions in the constructor or destructor will be bound as if the object has the same type as the constructor itself
    - otherwise, there's a chance that the uninitialized derived class's members are unused
    - the following codes show the example of this case
    ```c++
    class Base {
    public:
        Base() = default;
        Base(const Base &input) : baseMember(input.baseMember) { f(); }     // always calls Base::f()
        virtual void f() const { std::cout << "this is base" << std::endl; }
    private:
        double baseMember;
    };
    class Derived : public Base {
    public:
        Derived() = default;
        Derived(const Derived &input) : Base(input), memberA(input.memberA) {}
        void f() const override { std::cout << "this is derived" << std::endl; } 
    private:
        int memberA;
    };
    ...     // some codes
    Derived a;
    Derived b(a);       // Base::f() is called although it calls the constructor of the derived class
    ```

### Virtual Destructor
Base classes ordinarily should define a `virtual` destructor even if they do no work
- because the destructor of the derived class is called only if the destructor of base class is `virtual` if you call `delete` operator to the compound type to the base class which points or refers to the object of the derived class
- the order of destruction is same as usual (reverse of construction)
    1. the object of the derived class call's its destructor to be destroyed
    2. it executes its function body and its implicit destruction phase happens to destroy the members of its part
    3. then, it calls its **direct** base class's destructor
    4. this iteration keeps going until it reaches the root of the hierarchy

### Respecting the Base-Class Interface
Although it may be possible for the derived class to access to the implementation part of the base class, it should use the interface part of the base class only

### static members
If a base class defines a `static` member, there is only **single** instance of each `static` member
- `static` members obey normal access control
    * if the member is `private` in the base class, then the derived class have no direct access to it

### Declaration of the Derived Class
The declaration contains the class name but does **not** include its derivation list
```c++
class Derived;      // ok; right way to declare a derived class
class Derived : public Base;    // error; derivation list can't appear here
``` 
- the derivation list must appear together in the class body
- also, the base class must be defined before being inherited

### Preventing Inheritance
If you don't want the derived class to inherit or override, you can prevent it by using `final` keyword
```c++
class Base final { };
class Derived : public Base {};     // error; Base can't be a Base class

class Base { virtual void f(); };
class DerivedA : public Base { void f() final; };
class DerivedB : public DerivedA { void f(); };     // error; f can't be overridden
```
- you can use `final` keyword by placing it after the class name or
    * placing it after the parameter list or qualifiers, if any

### Static Type and Dynamic Type
In the concept of **polymorphism**, there are 2 kinds of types
- static type
    * which is always known at compile time
- dynamic type
    * which may not be known until run time
- also, note that we cannot convert from base to derived even when a base pointer or reference is bound to a derived class
    * this is because the compiler has no way to know (at compile time) that a specific conversion will be safe at run time
    * therefore, in order to fix this issue, we have 2 solutions
        + if the base class has one or more virtual functions, we can use a `dynamic_cast` to request a conversion that is checked at run time
        + or, in those cases when we know that the conversion from base to derived is safe, we can use a `static_cast` to override the compiler
```c++
Derived d;
Base * ptrB = &d;
Derived * ptrD = ptrB;      // error; can't convert to base to derived by default
```


## Virtual Functions

### Same Function Prototype
If you want to override the virtual method, they must have the **same** `parameter list` and **same** `return type` with one exception
- the exception applies to virtuals that return a reference (or pointer) to types that are themselves related by inheritance
- that is, if `Derived` is derived from `Base`, then a base class virtual can return a `Base *` and the version in the derived can return a `Derived *`
- the following codes show the example of this case
```c++
class Base {
public:
    virtual Base* f() { std::cout << "Base" << std::endl; return this; }
};
class Derived : public Base {
public:
    Derived* f() override { std::cout << "Derived" << std::endl; return this; }
};
```

### Default Arguments of Virtual Methods
Like other methods, it's possible for `virtual` methods to have default arguments
- but it's based on the **static type**
```c++
class Base {
public:
    virtual void f(int a = 3) { std::cout << a << std::endl; }
};
class Derived : public Base {
public:
    void f(int a = 4) override { std::cout << a << std::endl; }
};
void print(Base &input) {
    input.f();  // prints 3
}
```

### Circumventing the Virtual Mechanism
In some cases, we want to prevent dynamic binding of a call to a `virtual` function
```c++
baseP->Base::f();   // calls Base::f(), although baseP points to the derived class which overrides f()
```
- we can use the `::(scope operator)` to force the call to use a particular version of that virtual
- ordinarily, only methods or friends should need to use this feature


## Abstract Base Classes

### Pure Virtual Functions
If you want to prevent the base class which has a `virtual` method from being created, you can achieve this by making that `virtual` method as **pure** `virtual`
```c++
class Base {
public:
    virtual void f() = 0;      // pure virtual method
};
class Derived : public Base {
    void f() { ... /* some implementation */ }
}
... // some codes
Base a;     // error;
Derived b;  // ok;
```
- you make make **pure** `virtual` method by writing `= 0` in place of a function body
    * it may appear only on the declaration of a `virtual` function in the class body
- if the derived class overrides the **pure** `virtual` method, then you can create the object of the derived class

### Refactoring
**Refactoring** involves redesigning a class hierarchy to move operations and/or data from oe class to another


## Access Control and Inheritance

### Access Specifier in Derivation List
The access specifier in derivation list has **no effect** on whether members (and friends) of a derived class may access the members of its own direct base class
- regardless of which specifier is provided, the derived class has the **direct access** to the `public` and `protected` members of its base class
- its purpose is to control the access that **users** of the derived class, including other classes which are derived from the derived class, have to the members inherited from the base class
    * if it's `private`, then the user of derived class has no direct access to the `public` member of the base part because they are treated as if they were `private` members

### Accessibility of Derived-to-Base Conversion
Assuming `D` inherits from `B`:
- user code may use the derived-to-base conversion only if `D` inherits publicly from `B`. user code may not use the conversion if `D` inherits from `B` using either `protected` or `private`
- member functions and friends of `D` can use the conversion to `B` regardless of how `D` inherits from `B`. the derived-to-base conversion to a direct base class is always accessible to members and friends of a derived class
- member functions and friends of classes derived from `D` may use the derived-to-base conversion if `D` inherits from `B` using either `public` or `protected`. such code may not use the conversion if `D` inherits privately from `B`

### Exempting Individual Members
Sometimes we need to change the access level of a name that a derived class inherits
```c++
class Base {
protected:
    void f() { ... /*some codes*/ }
}
class Derived : private Base {
public:
    using Base::f;
}
Derived a;
a.f();      // ok;
```
- we can do so by providing `using` declaration


## Class Scope under Inheritance

### Name Lookup
Assume that `C` is derived from `B` which is derived from `A` :
- when the control flow sees `C.member`, it checks
    * the scope of `C` first
    * then, scope of `B`
    * finally, scope of `A` is searched for
- note that the name lookup happens at compile time

### Name Collision
Like any other scope, names defined in an inner scope (e.g., a derived class) **hide** uses of that name in the outer scope (e.g., a base class)
```c++
struct Base {
    Base() : mem(0) {}
protected:
    int mem;
};
struct Derived : Base {
    Derived(int i) : mem(i) { } // initializes Derived::mem to i
                                // Base::mem is default initialized
    int get_mem() { return mem; }   // returns Derived::mem
    int get_base() { return Base::mem; }    // returns Base::mem explicitly
protected:
    int mem;
}
```
- we can use a hidden base-class member by using the `::(scope operator)`
- aside from overriding inherited virtual functions, a derived class usually should not reuse names defined in its base class

### Virtual Functions and Scope
If a certain method of the base class is **not** `virtual`, we **cannot** override and overload it from the derived class
```c++
class Base {
public:
    void f() { std::cout << "Base" << std::endl; }
};
class Derived : public Base {
public:
    void f(int a) { std::cout << a << std::endl; }  // tries to overload, but hides the base version actually
};
... // some codes
Derived a;
a.f();  // error;
a.f(1); // ok; 
```
- if you try to overload it, the derived version just **hides** the base version 


## Consturctors and Copy Control

### Virtual Destructors
Recall that most base classes should define its destructor as `virtual`
- this fact raises an important exception to the rule of thumb that if a class needs a destructor, it also needs copy and assignment
    * if a base class has an empty destructor in order to make it `virtual`, then the fact that the class has a destructor does **not** indicate that assignment operator or copy constructor is also needed
- also as we covered in the [previous chapter](https://sadoe3.github.io/cpp/chapter13/), if the class defines its destructor, even if it uses the default version, the compiler won't synthesize a move operation for that class

### Synthesized Copy Control and Inheritance
The synthesized copy-control members in a base or a derived class are synthesized and execute like any other default ones
- they **memberwise** initialize, assign, or destroy the members of the class itself
- it is worth noting that it doesn't matter whether the base-class member is it-self synthesized or has an user-provided definition
    * all that matters is that the corresponding member is accessible and that it is not a `deleted` function
 
### Deleted Functions
The default versions may be defined as `deleted` for the same reasons as in any other class
- in addition, the way in which a base class is defined can cause a derived-class member to be defined as `deleted` :
    * if the default constructor, copy constructor, copy-assignment operator, or destructor in the base class is `deleted` or inaccessible
        + then the corresponding member in the derived class is defined as `deleted`, because the compiler can't use the base-class member to construct, assign, or destroy the base-class part of the object
    * if the base class has an inaccessible or `deleted` destructor
        + then the synthesized default and copy constructors in the derived classes are defiend as `deleted`, because there is no way to destroy the base part of the derived object
    * as usual, the compiler will not synthesize a `deleted` move operation. if we use `=default` to request move operation, it will be a `deleted` function in the derived 
        + if the corresponding operation in the base is `deleted` or inaccessible, because the base class part cannot be moved
        + the move constructor will also be `deleted` if the base class destructor is `deleted` or inaccessible

### Move Operations and Inheritance
Base classes ordinarily should define the move operations if it is sensible to do so
```c++
class Base {
    Base() = default;
    Base(const Base &) = default;
    Base(Base &&) = default;
    Base& operator=(const Base &) = default;
    Base& operator=(Base &&) = default;
    virtual ~Base() = default;
}
```
- for the same reasons we've covered already, once it defines its move operations, it must also explicitly define the copy versiosn as well

### Defining Copy Controls
When you define **copy-control** members, make sure that the base part is handled
- the copy/move constructors should call its direct class's corresponding constructor before initializing their part
    + `Derived(const Derived & rhs) : Base(rhs), memberA(rhs.memberA);`
    + `Derived(Derived && rhs) : Base(std::move(rhs)), memberA(rhs.memberA);`
- the copy/move assignment operators should handle the base part as well
    ```c++
    Derived& Derived::operator=(const Derived &rhs) {
        Base::operator=(rhs);
        // same concept is applied 
        // handles self-assignment, frees the existing resources as appropriate
        // then, assigns the members in the derived class, as usual
        return *this;
    }
    Derived& Derived::operator=(Derived &&rhs) {
        Base::operator=(std::move(rhs));
        // same concept is applied 
        // handles self-assignment, frees the existing resources as appropriate
        // then, assigns the members in the derived class, as usual
        return *this;
    }
    ```
- unlike other members, the destructor is responsible only for destroying its part
    * because the implicit `destruction phase` calls its direct base's destructor automatically
    * hence, what matters is whether the destructor of the derived class is called 
        + this is the reason why most base classes should define its destructor as `virtual`

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}