---
title: "Chapter 19"

categories:
    - cpp

tags:
    - [C++, Programming Language, memory allocation, RTTI, enum, pointer to class member, nested class, union, local class, bit-field, volatile]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-22
---

# Specialized Tools and Techniques

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Controlling Memory Allocation

### Overloading new and delete Expressions
Although it's possible to define our custom `new` and `delete` **functions**, we **cannot change** the behavior of `new` and `delete` **expressions**
- `new` expression has the following behavior
    1. allocates the memory
        * this is the part which can be **customized**
    2. constructs it
    3. returns it
- `delete` expression has the following behavior
    1. destroys the memory
        * this is the part which can be **customized**
    2. deallocates it

### Overloading new and delete Functions
The library defines 8 overloaded versions of `operator new` and `operator delete` functions
```c++
// these versions might throw an expcetion
void * operator new(size_t);
void * operator new[](size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;

// these versions promise not to throw
void * operator new(size_t, std::nothrow_t&) noexcept;
void * operator new[](size_t, std::nothrow_t&) noexcept;
void operator delete(void*, std::nothrow_t&) noexcept;
void operator delete[](void*, std::nothrow_t&) noexcept;
```
- they are divided into 2 part:
    * throwing versions and nonthrowing versions
- the type `std::nothrow_t` is a `struct` defined in the `<new>` header
    * the `<new>` header also defines a `const` object named `std::nothrow`
        + which users can pass to signal they want the nonthrowing version of `new`
- like destructors, an `operator delete` must not throw an exception
- we can overload the `operator new` and `operator delete`
    * by defining in the **global scope**
    * or, defining them as **member functions** 
- using `malloc()` and `free()` from `<cstdlib>` is a good option if you want to define your custom `operator new` and `operator delete`
- the following codes show the simple definition of custom `new` and `delete` functions
    ```c++
    void* operator new(size_t size) {
        if(void* mem = malloc(size))
            return mem;
        else
            throw bad_alloc();
    }
    void operator delete(void* mem) noexcept { free (mem); }
    ```
- when `operator delete` and `operator delete[]` is defined as a class member, the function may have a **second parameter** of type `size_t`
    * if present, the additional parameter is initialized with the size in bytes of the object addressed by the first parameter
    * if the base class has a `virtual` destructor, then the size passed to `operator delete` will **vary** depending on the **dynamic type** of the object to which the deleted pointer points
        + moreover, the version of the `operator delete` function that is run will be the one from the **dynamic type** of the object

### Placement new Expressions
In earlier versions of the language - before the `std::allocator` class was part of the library - **placement `new`** form of `new` is used to **construct** an object 
```c++
new (place_address) type;
new (place_address) type [size];

new (place_address) type (initializer);
new (place_address) type { braced initializer list };
```
- like `std::allocator`, it's used when you want to separate the allocation and construction
- the `place_address` must be a pointer which points to preallocated memory address
    * it's worth noting that that memory doesn't have to be dynamic
- the placement `new` expression has 4 forms
    * the first two expressions don't have the arguments to be used to construct
        + in this case, placement `new` uses `operator new(size_t, void*)` to **allocate** its memory
            - however, note that although it is trying to allocate its memory, this function does not allocate any memory
            - it simply returns its pointer argument
        + this is the version of `operator new` that we are not allowed to redefine
    * the last two epxressions initialize object(s) at the given address with the given initializer(s)
- because you separate the allocation and construction, it's usually a good idea to separate the destruction and deallocation by **explicitly** call the destructor through the given pointer argument
    * `ptr->~Type();`

## Run-Time Type Identification
**Run-Time Type Identification** (RTTI) is provided through two operations
- the `dynamic_cast` operator
    * which safely converts a pointer or reference to a base type into a pointer or reference to a derived type
- the `typeid` operator
    * which returns the type of a given expression

### RTTI is Useful for Inheritance
If you want to call the method of the derived class which is not `virtual`
- then, using RTTI would be a good soltuion
    * however, note that it's almost always better to call the `virtual` method if it's possible to do so 

### dynamic_cast
Performing `dynamic_cast` is possible only if the derived class is **publicly** inherited from the base class
```c++
if (Derived * dp = dynamic_cast<Derived *>(bp)) {
    // use the Derived pointer
} 
else {
    // use the Base pointer
}
```
- when the casting failed, it returns
    * `0` if it's pointer conversion
    * throw `std::bad_cast` exception if it's reference conversion
- also it's possible to execute `dynamic_cast` on a **null** pointer
    * the result is a **null** pointer of the requested type
- it's worth noting that performing a `dynamic_cast` in a condition ensures that the cast and test of its result are done in a **single** expression
    * also, it increase the level of safety because only `if` clause can use the casted pointer

### typeid
The `typeid(e)`, where `e` is the expresison, operator returns a reference to `const` object of a library type named `std::type_info` which is defined in the `<typeinfo>` header or a type publicly derived from `std::type_info`
- the result obeys the following rules
    * top-level `const`s are ignored as usual
    * the references are also ignored
        + if the expression is the reference, then the `typeid` operator returns the type to which the reference refers
    * the standard conversion to pointer for arrays and functions are not done
        + if `e` is an array, then the result is not a pointer but an array type
- if `e` is not of class type or a class type without any `virtual` functions
    * the `typeid` indicates the **static** type of the operand at **compile time**
- if `e` is lvalue of the class type which defines at least one `virtual` function
    * it indicates the **dynamic** type of the operand at **run time**
    * it's worth noting that if `e` is the compound type to the base type which denotes to the derived object, then
        + the `typeid(e)` returns the derived type, although it's compound type to the base type
    * also, in this case, you must pass `(*bp)` not `(bp)` to `typeid`
        + because `typeid(*bp)` returns the **dynamic type**
        + but `typeid(bp)` returns the **staic type** which is the pointer to the base class although it actually points to the derived object
- if `typeid` returns the **dynamic type**, the resulting pointer must be **valid**
    * otherwise, like `nullptr`, it throws `std::bad_typeid` exception

### Typical Example of RTTI
The `typeid` is often used to **compare** types
```c++
// example of type-sensitive equality operator
class Base {
    friend bool operator==(const Base&, const Base&);
public:
    // interface members for Base
protected:
    virtual bool equal(const Base&) const;
    // data and other implemenation of members of Base
};
class Derived: public Base {
public:
    // other interface members for Derived
protected:
    virtual bool equal(const Base&) const;
    // data and other implemenation of members of Derived
};

bool operator==(const Base &lhs, const Base &rhs) {
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

bool Base::equal(const Base &rhs) const {
    // compares members of Base
}

bool Derived::equal(const Base &rhs) const {
    // delegate the work to the Base to compare Base part
    if(!Base::equal(rhs))
        return false;

    // we know the types are equal through the typeid operator
    // so the cast won't throw
    const Derived &castedRhs = dynamic_cast<const Derived &>(rhs);
    // compares members of Derived
}
``` 
- the codes above shows typical example of using RTTI

### type_info Class
The exact definition of the `std::type_info` class varies by compiler
- however, the standard guarantees that the class will be defined in the `<typeinfo>` header and that class will provide at least the operations in the table below
    ||Operations on `std::type_info`|
    |:---:|:---:|
    |`t1 == t2`|returns `true` if the `type_info` objects `t1` and `t2` refer to the same type, `false` otherwise|
    |``||
    |``||
    |``||


## Enumerations
**Enumerations** let us group together sets of **integral** constants
- like classes, each enumeration defines a new type
    * and they are **literal** types

### Scoped and Unscoped Enumerations
C++ has 2 kinds of enumerations
- **scoped** enumerations
    ```c++
    // example of scoped enumerations
    enum class Color { RED, GREEN, BLUE };
    Color a = RED;              // error;
    Color a = Color::RED;       // ok;
    ```
    * the `class` keyword can be changed to `struct`
    * **enumerator** is the value defined inside the enumeration body
- **unscoped** enumerations
    ```c++
    // example of unscoped enumerations
    enum Color { RED = 6, GREEN, BLUE };    // GREEN = 7, BLUE = 8
    Color a = BLUE;              // ok;
    Color a = Color::BLUE;       // ok;
    ```
    * the **unscoped** enumerations may have the **empty** name
- by default, enumerator values start at 0 and each enumerator has a value 1 greater than the preceding one 
- enumerators are `const`
    * and, if they are initialized, their initializers must be **constant expressions**
    * consequently, each enumerator is itself a **constant expression**
- note that you **cannot redefine** the enumerators in the same scope
    ```c++
    enum Color { RED, GREEN, BLUE = 3 };
    enum RGB { RED, GREEN, BLUE = 3 };              // error; redefine enumerators
    enum class ScopedRGB { RED, GREEN, BLUE = 3 };  // ok; enumerators are hidden

    constexpr Color eyes = BLUE;                      // ok;
    constexpr Color eyes = 3;                         // error; wrong type; int is used
    constexpr ScopedRGB eyes = BLUE;                  // error; wrong type; Color::BLUE is used
    constexpr ScopedRGB eyes = ScopedRGB::BLUE;       // ok;
    ```
    * also note that although two different enumerations have enumerator which contains the same name, the two enumerators are different because the two enumerations are different types
        + same rule is applied to the built-in types (espeically for `int`) as well
        + although the enumerator has the same value as the `int` literal, they are different
- although each `enum` defines a unique type, it is represented by one of the built-in integral types
    * and, we may specify that type by following the `enum` name with a colon and the name of the type we want to use
    ```c++
    enum IntValues : unsigned long long { charType = 255, shortType = 65535 };
    ```
    * if we do not specify the underlying type, then by default the **scope** `enum`s have `int` as the underlying type
    * there is **no default** for **unscoped** `enum`s
        + we just know that the underlying type is large enough to hold the enumerator values
    * it's an error for an enumerator to have a value that is too large to fit in that type when the underlying type is specified (including implicitly specified for a scoped `enum`)
    * with this feature, we can be confident that our program compiled under one implementation will generate the same code when we compile it on another
- we can **forward declare** an `enum`
    ```c++
    enum IntValues : unsigned long long;
    enum struct ScopedRGB;      // uses int by default
    ```
    * an `enum` forward declaration must specify (implicitly or explicitly) the underlying size of `enum`
    * the size of the `enum` must be the same across all declarations and the `enum` definition
    * moreover, we **cannot** declare a name as an unscoped `enum` in one context and **redeclare** it as a scoped `enum` later


## Pointer to Class Member
A **pointer to member** is a pointer that can point to a non`static` member of a class
- pointers to `static` members are ordinary pointers
- there are 2 kinds of **pointers to class member**
    * pointers to data members
    * pointers to member functions 
- we'll use a version of the `Screen` class to explain this concept
    ```c++
    class Screen {
    public:
        typedef std::string::size_type pos;
        char get_cursor() const { return contents[cursor];}
        void setContents(cosnt std::string &input) { contents = input; }
        char get() const;
        char get(pos ht, pos wd) const;
    private:
        std::string contents;
        pos cursor;
        pos height, width;
    };
    ```

### Pointers to Data Members
```c++
const std::string Screen::*pdata = &Screen::contents;       // default use
auto pdata = &Screen::contents;                             // easy way
// but it's not possible to perform above code unless this function is the friend of Screen class

// hence the solution is to use the public static method which returns the pointer to data member
class Screen {
public:
    static const std::string Screen::*data() { return &Screen::contents; }
    // other members
};
Screen data;
data.setContents("abcde");
auto pdata = Screen::data();                                // identifies a specific member 
std::cout << (data.*pdata).length() << std::endl;           // uses the pointer with the acutal object; prints 5
```
- it is essential to understand that when we initialize or assign a pointer to member, that pointer does **not yet point to any data**
    * it only identifies which member to point to
    * therefore, we must supply the acutal object to use the pointer to member
        + by using `.*` or `->*`
    * note that the **parentheses** are crucial due to the **precedence** 
- when we initialize or assign a pointer to member, the access level matters
    * if the member is `private`, then the current function scope doesn't have the access to it unless it's the `friend` of the class or a method of it
    * in this case, having a `public static` method which returns the pointer to data member would be a good solution

### Pointers to Member Functions
```c++
char (Screen::*pmf) (Screen::pos, Screen::pos) const;
pmf = &Screen::get;         // default use
auto pmf = &Screen::get;    // easy way
using Action = char (Screen::*) (Screen::pos, Screen::pos) const;
Action pmf = &Screen::get;  // another way

Screen data, *ptr = &data;
char c1 = (ptr->*pmf) (0, 0);   // parentheses are crucial due to the precedence
```
- as the example shows, we can point to the one of the overloaded methods by specifying the exact parameter list
- the use of pointers to member functions is similar to the use of pointers to data members

### Pointer-to-Member Function Tables
The following codes show the example of storing pointers to member functions in a **function table**
```c++
class Screen {
public:
    // cursor movement members
    Screen& home() { std::cout << "home" << std::endl; return *this; }
    Screen& forward() { std::cout << "forward" << std::endl;return *this; }
    Screen& back() { std::cout << "back" << std::endl; return *this; }
    Screen& up() { std::cout << "up" << std::endl; return *this; }
    Screen& down() { std::cout << "down" << std::endl; return *this; }
    // Action is a pointer that can be assigned any of the cursor movement members
    using Action = Screen & (Screen::*) ();
    enum Directions { HOME, FORWARD, BACK, UP, DOWN };
    Screen& move(Directions);
private:
    static Action Menu[];
};

// initialize static member
Screen::Action Screen::Menu[] = {
    &Screen::home,
    &Screen::forward,
    &Screen::back,
    &Screen::up,
    &Screen::down,
};

Screen& Screen::move(Directions cm) {
    return (this->*Menu[cm])();
}

... // some codes
Screen a;
a.move(Screen::HOME);       // prints home
a.move(Screen::DOWN);       // prints down
```

### Using Member Functions as Callable Objects
By default, pointers to member functions don't support `function call` operator
- which means, it can't be used for the library functions
- there are 3 ways to solve this problems
    * `std::function` template
        ```c++
        std::function<bool (const std::string&)> fcn = &std::string::empty;
        std::find_if(svec.begin(), svec.end(), fcn);
        ```
    * `std::bind`
        ```c++
        // bind each string in the range to the implicit first argument to empty
        auto it = std::find_if(svec.begin(), svec.end(), std::bind(&std::string::empty, std::placeholders::_1));
        ```
    * `std::mem_fn` which is defined in the `<functional>` header as well
        ```c++
        std::find_if(svec.begin(), svec.end(), std::mem_fn(&std::string::empty));
        ```
        + like `std::function`, `std::mem_fn` generates a callable object from a pointer to member
        + unlike `std::function`, `std::mem_fn` will deduce the type of the callable from the type of the pointer to member



## Nested Classes
A class can b defined within another class
- such a class is a **nested class**, also referred to as a **nested type**

### Enclosing Class and Nested Class
The enclosing class and the nested class are **independent** and **unrelated** to each other
- the object of the enclosing type doesn't have the member of the nested type, and vice versa

### Visibility of the Nested Class
The name of the nested class is visible **only within** its enclosing class scope but **not outside** the class scope
- hence, the main purpose of the nested class is mostly related to the implementation of the enclosing class
- the enclosing type can specify the **access level** to the nested type
    * a nested class defined in the `public` part
        + may be used anywhere
    * a nested class defined in the `protected` part
        + is accessible only by the enclosing class, its friends, and its derived classes
    * a nested class defined in the `private` part
        + is accessible only to the members and friends of the enclosing class

### Declaring Inside and Defining Outside
Like other members, it's possible for the enclosing class to declare the nested class inside and define it outside
```c++
class Enclosing {
public:
    class Nested;       // declares the nested class
    // other members
};
class Enclosing::Nested {       // defines the nested class outside the enclosing class definition
    static int static_member;       // static member
    // other members
}
int Enclosing::Nested::static_member = 1;   // defines the static member
```
- note that until the actual definition of a nested class that is defined outside the class body is seen,
    * that calss is an **incomplete** type


## Local Classes
A class can be defined a function body
- such a class is called a **local class**
- the concept is similar to the **nested class**
    * but it's more **restricted**

### Restrictions of Local Classes
- all the members of the local class must be **completely** defined inside the class body
- the local classes **cannot** have `static` members
- they **cannot** access to the local objects in the same function scope
    * however, it's possible for them to access to the global objects or `static` local objects 

### Other Features
- it's possible to define **local enumerations**
- also, it's possible to define the **nested local classes**


## union: A Space-Saving Class
A `union` is a special kind of class which may have multiple data members of most types
- including class types that have constructors and destructors
- but it cannot have reference type as its member

### About union
Like any other class, a `union` defines a new type
- the default access specifier for `union` is `public`
- the amount fo storage allocated for a `union` is at least as much as is needed to contain its largest data member
- only one member of the `union` may have a value
    * when a value is assigned, all other members become **undefined**
- a `union` can have member functions
    * including constructor and destructor
- however, it's **doesn't** support the **inheritance**
    * hence, it can't have `virtual` method

### Defining union
```c++
// typical example
union Name {
    char cval;
    int ival;
    double dval;
};
...     // some codes
Name a;
a.ival = 3;

// anonymous union
union {
    char cval;
    int ival;
    double dval;
};
ival = 3;
```
- the name of the `union` is **optional**
    * if the name is not included, then it becomes a **anonymous** `union`
        + the members of the **anonymous** `union` are directly accessible in the scope where the `union` is defined
        + however, it **cannot** have `private`, or `protected` members
        + also, it **cannnot** define member functions

### union with Members of Class Type
When a `union` takes the member which is a class type, it usually defined as a member of another class so that that class can keep track of the member of the `union` which is being currently used
- that class usually has the data member of `enum` type as a **discriminant**
    * when you assign new value to one of the `union`'s member
    * that `enum` member is used to check whether it's a class type or not
        + if it's a class type, then you call
            * `placement new` operator to construct it
            * or its `desturctor` to destory it


## Inherently Nonportable Features

### Bit-Fields
A class can define a (non`static`) dat amember as a **bit-field**
- the **bit-field** member holds a specified number of **bits**
- note that the memory layout of a **bit-field** is machine dependent

### Defining Bit-Fields
```c++
class ClassName {
public:
    unsigned a: 3;
    unsigned b: 1;
};
```
- the type of the bit-field members must be integral or enumeration type
    * ordinary, `unsigned` types are the best options
- you can specify the number of bits by placing `:` after the member followed by the number of bits
- the bit-field members aree accessed in the same way as the other members of a class
    * moreover, they supports the built-in bit-wise operations for sure

### volatile Qualifier
An object should be declared `volatile` when its value might be changed in ways outside the control or detection of the program
```c++
volatile int display_register;
```
- the `volatile` keyword is a directive to the compiler that it should not perform optimizations on such objects
- in the same way that a class may define `const` member function, it can also define member functions as `volatile`
    * only `volatile` member functions  may be called on `volatile` objects
- programs that use `volatile` usually must be changed when they are moved to new machines or compilers
- in most ways, `volatile` keyword is used in musch the same way as the `const` qualifier
    * however, there's one important difference
    * the synthesized copy/move and assignment operators cannot be used to initialize or assign from a `volatile` object
        + if a class wants to allow `volatile` objects to be copied, moved, or assigned
        + it must define its own verions of the copy or move operations

### Linkage Directive: extern "C"
C++ programs sometimes need to call functions written in another programming language
- C++ uses **linkage directives** to inidicate the language used for any non-C++ function
- mixing C++ with code written in any other language, including C, requires access to a compiler for that language that is compatible with your C++ compiler

### Declaring a Non-C++ Function
A linkage directive can have one of two forms
- single or compound
```c++
// single
extern "C" size_t strlen(const char *);

// compound
extern "C" {
    int strcmp(const char*, const char*);
    char* strcat(char*, const char*);
}

// includes header file written in C
extern "C" {
#include <string.h>
}

// pointer to function
extern "C" void (*pfc) (int);  // pfc points to a C function
void (*pfcpp) (int);           // pfcpp points to a C++ function
pfcpp = pfc;                   // error; they have different types

// C++ function which takes pointer to C function
extern "C" typedef void FC(int);
void f2(FC *);          // f2 is a C++ function with a parameter that is a pointer to a C function

// exporting C++ function to C
extern "C" double calc(double param) { /* codes */ }
```
- the string literal indicates the language in which the function is written
    * a compiler may provide linkage specifications for other languages
    * for instance, `extern "Ada"`, `extern "FORTRAN"`
- the names of functions declared within the braces are visible as if the functions were declared outside braces
- linkage directive may not appear inside a class or function definition
- the same linkage directive must appear on every declaration of a function
- some C++ compilers may accept the assignment between pointer to C function and pointer to C++ function with same function which have the same `return type` and `parameter list` as a language extension, even though, strictly sepaking, it is illegal
- the linkage directive applies to the function and any function pointers used as the return type or as a parameter type
    * if you wish to pass a pointer to a C function to a C++ function, you must use a type alias
- it is worth noting that the parameter and return types in functions that are shared across the languages are often **constrained**
    * for instance, the C program won't know about the constructors, destructors, or other class-specific operations
- the interaction between linkage directives and function overloading depends on the target language
    * if the language supports overloaded functions, then it is likely that a compiler that implements linkage directives for that language would also support overloading of these functions from C++
    * the C language doesn't support function overloading, so a C linkage directive can be specified for only one function in a set of overloaded functions

### Preprocessor Support for Linking to C
To allow the same source file to be complied under either C or C++, the preprocessor defiens __cplusplus(two underscores) when we compile C++
```c++
#ifdef __cplusplus
extern "C"
#endif
// some C codes
int strcmp(const char*, const char*);
```
- using this variable, we can conditionally include code when we are compiling C++

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}