---
title: "Chapter 2"

categories:
    - cpp

tags:
    - [C++, Programming Language, Type]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-11-27
---

# Variables and Basic Types

> 이 포스팅은 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Primitive Built-in Types

### Arithmetic Types
C++의 built-in type은 크게 2가지 종류로 구성이 된다.
- Arithmetic Types
<br>
Arithmetic Types은 또한 2가지로 구성이 되는데, 다음과 같다
    * Integral types
    <br>
    bool, char, wchar_t, char16_t, char32_t, short, int, long, long long
    <br>
    int의 크기는 system 마다 다르기 때문에, fixed size라고 생각하고 coding하면 안된다.
    * Floating-point types
    <br>
    float, double, long double
- void type
<br>
다양한 상황에서 void type을 사용하게 되는데, 예를 들면 void pointer를 생각해 볼 수 있다.

### Signed and Unsigned Types
bool, extended character types을 제외한 integral type은 signed인지 unsigned인지를 설정할 수 있다.
- 굳이 signed를 붙이지 않아도 기본적으로 signed이다.
- 그냥 unsigned 라고 쓰면, unsigned int를 의미한다.
- unsigned는 negative part가 postive part에 추가적으로 붙어서, 동일한 크기이지만 postivie part를 좀더 많이 사용할 수 있게 해준다.
- 다만 char는 예외적으로 compiler에 따라서 char가 signed char일 수도 있고, unsigned char일 수도 있다.

### Deciding which type to use
- Negative Value를 받지 않는다는 확신이 서면 unsigned type을 사용하기<br>
- integral type에 관하여, 기본적으로는 int 사용하기. 너무 짧으면 short, 너무 길면 long long 사용하기. 일반적으로 long은 int와 같은 크기이기 때문에 사용할 일이 별로 없음.
- char는 expression에 사용할 때, unsigned인지 signed인지 명시하여 사용하기
- 일반적으로 char는 문자 하나를 저장할때 사용하긴 함
- floating-point type에 관하여, double 사용하기. float는 너무 부정확하고, long double은 너무 정확하기 때문(run-time cost).

### Type Conversions
A type이 예상되는 상황에서 B type이 주어졌으면, B type에서 A type으로 automaic(implicit) type conversion이 이루어진다. (물론 B type에서 type conversion operator가 구현이 되어 있어야 함. 기본적으로 built-in type들은 서로 간의 type conversion이 구현이 되어있음)
- bool type은 0만을 false로 받고, 나머지 값들은 true로 받는다.
- integral type에 floating-point value를 넣어주면, integral part만 받고, 나머지는 truncated 된다. (반올림이 안됨)
- floating-point type에 integral value를 넣어주면, fractional part는 0으로 입력이 된다.
- out-of-range value를 집어넣었을 때, unsigned type 같은 경우에는 넘친 만큼 반대쪽에서 그 만큼 추가된 값이 된다. (ex: unsigned char -> 300 -> 44)
- signed type 같은 경우, 결과는 undefined 이다. (unsigned와 같을 수도 있음)
- signed와 unsigned가 동일한 expression에 있는 경우, signed가 unsigned로 casting 되어 expression이 진행된다. (그 값은 위에서 설명한 방식대로 변경됨)
- 그래서 일반적으로 signed와 unsigned는 동일한 expression에 사용하지 않는것이 좋다.

### Literals
value with name = object <br>
value without name = literal <br>
object which are able to change its value = variable <br>
object which are not able to change its value = constant <br>
일단 이런식으로 정의를 내렸지만, 사실 object의 정의는 사람마다 다르기 때문에, 그냥 data를 저장할수있는 type으로 정의된 공간 정도로 생각하면 된다.
- integral literal
    * decimal = 20
    * octal = 024
    * hexadecimal = 0x14
    * minmum size = int
- floating-point literal
    * decimal point = 3.14159
    * scientific notation = 3.14159E0
    * default type = double -> can be overriden
- string literal
    * character = 'a' <br>
    type = char
    * c-sytle string = "a"
    * c-sytle string literal은 char들로 이루어진 array이고, 맨 마지막에 null character(\0)가 추가되어, "a"는 2의 크기를 갖는다.
    * 또한 string literal 2개가 인접하여 있으면 1개의 string literal로 생각하면 된다. <br>
    "aaa" "bbb" = "aaabbb"
- escape sequence
    * nonprintable characters를 출력할때 사용한다.
    * \\n, \\t, \\a, \\v, \\b, \\", \\\\, \\?, \\', \\r, \\f
- boolean literal
    * true, false가 boolean literals이다.
- pointer literal
    * nullptr는 null pointer를 사용할때 쓰는 pointer literal이다.
- specifying the type of a Literal
    * default한 literal의 type 대신에 내가 원하는 type을 설정하여 literal를 사용할수있다.
    * suffix나 prefix를 추가하면 되는데, 예를 들면 L'a'는 wchar_t를 사용하고, 3.14L은 long double을 사용한다. (long double을 사용할때에는 대문자를 사용하여 1과 혼동되지 않게 하자)

## Variables

### Two types
기본적으로 c++는 2가지의 type을 갖는다.
- built-in type
- class type

### Variables Definitions
아직 class type에 관해서는 다루지 않았기 때문에, built-in type으로 object를 define 하는 방법에 대해 다루어 보겠다.
- 기본적인 Syntax는 다음과 같다
    * (type specifier) (list of one or more variables, comma separated, may have initial value) ;
    * ex: int width, height = 3;

### Initialization
Object가 만들어 질때, initial value를 설정하면 이를 **Initialization**이라고 한다.
- 다만 만들어진 이후에 =(assignment operator)을 사용하면 이는 assignment operation이 된다.
- 4가지 방법으로 초기화(initialize)를 진행할 수 있다.
    * int age = 3;
    * int age = {3};
    * int age{3};
    * int age(3);
- 여기서 { } (curly braces)를 사용한 초기화 방법을 list initialization이라고 하는데, 이때 만약에 초기화 중 data loss가 발생되는 상황에서는 compiler가 초기화를 멈춘다(error를 발생시킴)
    * ex: int age{3.14}; // error

### Default Initialization
만약 Object를 만들때, initial value를 설정하지 않으면, 해당 object는 **default initialized** 되어, 정해진 default value가 initial value로 설정되어 초기화된다.
- default initialization은 해당 object가 어떤 type이고, 어디에서 만들어 졌는지에 따라 default value를 다르게 설정해준다.
- built-in type의 object는 다음 2가지의 경우를 보면 된다.
    * outside function body 
    <br>
    이 경우 0으로 초기화 된다
    * inside function body
    <br>
    이 경우 uninitialized 된다 (즉 어떤 값으로 초기화 되는지는 undefined 이다.)
    <br>
    기본적으로 uninitialized object는 error-prone이기 때문에, 왠만하면 모든 object들은 초기화를 해주는것이 좋다.

### Variable Declaration
multiple files handling하는 경우, 다른 source code에 defined된 object를 사용해야 할때는 extern keyword를 이용해서 해당 object를 사용할 수 있다.
```c++
extern int i; // declares but does not define i
int j;        // declares and defines j

extern double pi = 3.1416 // defintion
```
다만 extern keyword를 사용해도 explicit initializer(=)를 이용하면 이는 곧 defintion이 된다. <br> 
주의할 점은 defintion은 딱 1개의 파일에서만 존재해야하고, declaration은 여러 파일에서 존재해도 상관없다.<br>마지막으로 function body 안에서는 extern keyword를 사용할 수 없다.

### Identifier
Identifier is a name of an object, a function, or a class.
- 기본적으로 C++에서 사용하는 특정 단어들(ex: keywords)을 제외한 단어는 identifier로 사용될 수 있다.
- 다만 보통 naming convention을 따라서 작성하는 것이 좋다.
    * variable = camelCase
    * class = PascalCase
    * function = PascalCase
    * constant = SCREAMING_SNAKE_CASE
- 어떤 naming convention을 사용하든, point는 consistency를 지켜줘야 의미가 있다.

### Scope of a Name
most scopes in C++ are delimited by curly braces
- 특정 code block 안에서 만들어진 object는 해당 code block (scope)을 벗어나면 사라지게 된다.
- 모든 program내에서 accessible 한 object를 만드려면 outside function body에다가 object를 define하면 된다. (global scope를 갖게 됨)  


## Compound Types



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}