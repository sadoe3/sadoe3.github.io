---
title: "Project 1: Threads"

categories:
    - pintos

tags:
    - [Operating Systems, PintOS, Kernel Development, Linux, Scheduling Algorithms, Concurrency, Priority Inversion, System Programming, Thread Management, Priority]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-03-15
---

# Threads
- The first project involved two significant advancements to the PintOS:
  * Optimization of the alarm clock mechanism.
  * Implementation of a priority-based scheduling algorithm incorporating preemption and priority donation.
- Below, I outlined the objectives, challenges, solutions, and implementations for each component.

## Part 1: Alarm Clock

### Objective
- The primary objective of this enhancement is to optimize the `timer_sleep()` function within PintOS by transitioning from an inefficient **busy-waiting** paradigm to a more efficient sleep/wakeup mechanism.
- This optimization involves two key components:
  * **Utilizing the `THREAD_BLOCKED` state**:
      - Instead of actively consuming CPU cycles, threads will enter a **blocked state** when sleeping, allowing the CPU to be allocated to other tasks.
  * **Introducing a `sleep_list`**:
      - A dedicated list will be used to efficiently manage threads that are awaiting resumption, enabling quick identification and activation when their wake-up time arrives.

### Current Problem
- The original `timer_sleep()` system call pauses a process for a specified number of `ticks` using **busy waiting**

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  timer_sleep (int64_t ticks) 
  {
    int64_t start = timer_ticks ();
    ASSERT (intr_get_level () == INTR_ON);
    while (timer_elapsed (start) < ticks) 
      thread_yield ();
  }
  ```
  </details>
* This approach exhibits several inefficiencies:
  - It repeatedly checks the current time in a tight loop.
  - If the wake-up time has not yet arrived, it invokes `thread_yield()`, which transitions the thread to the `THREAD_READY` state.
  - Crucially, if no other threads are present in the `ready_list`, the same thread is immediately rescheduled as `THREAD_RUNNING`. 
    * This creates a continuous cycle of yielding and re-running, leading to a significant waste of CPU resources.

### Original Grade
<img src="data:image/png;base64,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" alt="Description of image">

### Solution
- To address the aforementioned problems, `timer_sleep()` has been reimplemented to:
  - Leverage the `THREAD_BLOCKED` state to suspend threads, preventing unnecessary CPU consumption.
  - Introduce a `sleep_list` data structure to effectively track and manage all sleeping threads.
- The revised workflow for a `timer_sleep()` call is as follows:
  1. The calling thread is added to the `sleep_list` via a new `thread_sleep()` function.
  2. The system periodically checks the current time (e.g., within the timer interrupt handler.)
  3. When a thread's designated wake-up time is reached, it is moved from the `sleep_list` to the `ready_list` via a `thread_wakeup()` function, making it eligible for scheduling.

### Implementation Details
- The following components have been modified or introduced:
- **`timer.c`**
  - **`timer_sleep()`**
    - The `thread_yield()` call has been replaced with `thread_sleep()` when the process needs to sleep.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      timer_sleep(int64_t ticks)
      {
        int64_t start = timer_ticks();
        ASSERT (intr_get_level () == INTR_ON);

        while(timer_elapsed(start) < ticks)
          thread_sleep(ticks);
      }
      ```
      </details>
  - **`timer_interrupt()`**
    - A call to `thread_wakeup()` with the current `timer_ticks()` value has been added.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      timer_interrupt (struct intr_frame *args UNUSED)
      {
        ticks++;
        thread_tick ();

        thread_wakeup(ticks);    // wake up!
      }
      ```
      </details>
- **`thread.h`**
  - **`struct thread`**
    - A new member, `int64_t tick_wakeup`, has been added to store the specific tick at which the thread should be woken up.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct thread
      {
        // other codes
        struct list_elem elem;              /* List element. */

        int64_t tick_wakeup;                /* Tick till wake up */
        // other codes
      }
      ```
      </details>

- **`thread.c`**
  - **`sleep_list`**
    - A new static list, `static struct list sleep_list`, has been introduced to manage threads currently in the `THREAD_BLOCKED` state due to `timer_sleep()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* List of all processes.  Processes are added to this list
        when they are first scheduled and removed when they exit. */
      static struct list all_list;

      /* List of processes in THREAD_BLOCKED state. Processes are added to this list
        when they are called with thread_sleep() and removed when wakeup() is called */
      static struct list sleep_list;
      ```
      </details>
  - **`thread_init()`**
    - The `sleep_list` is now initialized during the `thread_init()` function.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_init (void) 
      {
        ASSERT (intr_get_level () == INTR_OFF);

        lock_init (&tid_lock);
        list_init (&ready_list);
        list_init (&all_list);
        list_init (&sleep_list);

        /* Set up a thread structure for the running thread. */
        initial_thread = running_thread ();
        init_thread (initial_thread, "main", PRI_DEFAULT);
        initial_thread->status = THREAD_RUNNING;
        initial_thread->tid = allocate_tid ();
      }
      ```
      </details>
  - **`thread_wakeup()`**
    - This function iterates through the `sleep_list` and moves threads whose `tick_wakeup` time has been reached to the `ready_list`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Wakes up sleeping threads by checking the sleep_list and comparing its elements to the global ticks, 
         then activates the appropriate threads.
      */
      void thread_wakeup(int64_t current_ticks) {
        enum intr_level old_level = intr_disable();

        struct list_elem *current_element = list_begin(&sleep_list), *next_element = NULL;
        while (current_element != list_end(&sleep_list)) {
            struct thread *thread_to_check = list_entry(current_element, struct thread, elem);

            next_element = list_next(current_element);
            if (thread_to_check->tick_wakeup <= current_ticks) {
              list_remove(current_element);
              thread_unblock(thread_to_check);    // put this thread to ready_list
            }
            current_element = next_element;
        }

        intr_set_level(old_level);
      }
      ```
      </details>
  - **`thread_sleep()`**
    - This function sets the calling thread's state to `THREAD_BLOCKED`, records its wake-up time (`tick_wakeup`), and adds it to the `sleep_list`. 
    - It then calls `thread_block()` to yield CPU control.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Sleeps for ticks. If the current thread is not the idle thread, this changes the status of the calling thread to THREAD_BLOCKED, 
        stores the local tick for waking up, updates the global tick if necessary, and calls schedule(). */
      void thread_sleep(int64_t ticks_to_sleep) {
        struct thread *cur = thread_current();
        
        ASSERT (!intr_context());
        enum intr_level old_level = intr_disable();
        int current_ticks = timer_ticks();
        if (cur != idle_thread) {
          cur->tick_wakeup = current_ticks + ticks_to_sleep;
          list_push_back(&sleep_list, &cur->elem);
        }
      
        thread_block();
        intr_set_level (old_level);
      }
      ```
      </details>

### Conclusion
- This modification successfully eliminates the inefficient busy-waiting mechanism from `timer_sleep()`, leading to a significant improvement in CPU efficiency within PintOS by allowing the CPU to perform other tasks while threads are sleeping.



## Part 2: Priority

### Objective
- The primary objective of this section is to fundamentally transform PintOS's **scheduling mechanism**. 
- This involves replacing the existing **FIFO** scheduling with a robust **priority-based system**, and incorporating **preemption** to ensure that high-priority threads are executed promptly and effectively.

### Current Problem
- **FIFO Scheduling**
  * The original PintOS design employs a strict FIFO scheduling policy. 
  * Threads are added to the `ready_list` in the order of their arrival, completely disregarding their assigned priorities.

      <details markdown="1">
      <summary><b>Click</b> to see the original code</summary>

      ```c
      void
      thread_unblock (struct thread *t) 
      {
        enum intr_level old_level;

        ASSERT (is_thread (t));

        old_level = intr_disable ();
        ASSERT (t->status == THREAD_BLOCKED);
        list_push_back (&ready_list, &t->elem);
        t->status = THREAD_READY;
        intr_set_level (old_level);
      }
      ```
      </details>

- **No Preemption**
  * A significant limitation of the current system is the absence of preemption. 
  * Even when a high-priority thread becomes ready (e.g., wakes up from a sleep or unblocks), it is not immediately granted CPU time if a lower-priority thread is currently executing. 
    + This leads to inefficient resource utilization and can cause critical delays for time-sensitive tasks.

### Solution
- The proposed solution below addresses these issues:
  1. **Creation/Unblocking**:
      - **Priority Comparison**: When a new thread is created or an existing thread is unblocked, its priority is compared with that of the currently running thread. If the new/unblocked thread possesses a higher priority, `thread_yield()` is invoked to trigger a context switch.
      - **Priority-Ordered Insertion**: Threads are no longer simply pushed to the back of the `ready_list`. Instead, they are inserted into the `ready_list` in a sorted order based on their priority, ensuring that the highest-priority ready thread is always at the front.
  2. **Level of Abstraction**:
      - **Low-level of Abstraction**: The `thread_unblock()` function is low-level function. Hence it's modified to solely handle the insertion of a thread into the `ready_list` according to its priority.
      - **Higher-level of Abstraction**: The functions that have higher-level of abstraction, such as `thread_create()` (when a new thread is created) or `thread_wakeup()` (when a sleeping thread becomes ready), are responsible for evaluating whether preemption is necessary and subsequently calling `thread_yield()` if a higher-priority thread has become ready.
  3. **Timer Preemption**: 
      - To enforce priority-based scheduling during timer interrupts, `intr_yield_on_return()` is utilized instead of directly calling `thread_yield()`. This mechanism signals the interrupt handler to perform a context switch upon returning from the interrupt, allowing a higher-priority thread to be scheduled if available.
  4. **Priority Donation**: 
      - To mitigate the problem of priority inversion (where a high-priority thread gets blocked waiting for a resource held by a low-priority thread), additional fields (`donors` and `lock_to_wait`) are added to the `struct thread`. This enables a mechanism where a low-priority thread temporarily inherits the priority of a high-priority thread that is blocked on a lock it holds.

### Implementation Details
- The following components have been modified or introduced:
- **`thread.h`**
  - **`struct thread`**
    - New members `lock_to_wait`, `original_priority`, `donors`, and `donelem` have been added to facilitate priority donation and tracking.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct thread
      {
        // other codes
        int64_t tick_wakeup;                /* Tick till wake up */
        struct lock *lock_to_wait;          /* Address of the lock to wait */
        int original_priority;              /* Original Priority value */
        struct list donors;                 /* Doners for priority inversion */
        struct list_elem donelem;           /* List element for donors list */
        // other codes
      };
      ```
      </details>

- **`thread.c`**
  - **`init_thread()`**
    - The new fields `wait_to_lock`, `original_priority`, and `donors` are initialized for each new thread.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      init_thread (struct thread *t, const char *name, int priority)
      {
        enum intr_level old_level;

        ASSERT (t != NULL);
        ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
        ASSERT (name != NULL);

        memset (t, 0, sizeof *t);
        t->status = THREAD_BLOCKED;
        strlcpy (t->name, name, sizeof t->name);
        t->stack = (uint8_t *) t + PGSIZE;
        t->priority = priority;
        t->magic = THREAD_MAGIC;


        t->lock_to_wait = NULL;
        t->original_priority = priority;
        list_init(&t->donors);


        old_level = intr_disable ();
        list_push_back (&all_list, &t->allelem);
        intr_set_level (old_level);
      }
      ```
      </details>
  - **`thread_sleep()`**
    - Threads are now inserted into the `sleep_list` in an ordered fashion, prioritizing those with earlier wake-up times and higher priorities.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void thread_sleep(int64_t ticks_to_sleep) {
        struct thread *cur = thread_current();
        
        ASSERT (!intr_context());
        enum intr_level old_level = intr_disable();
        int current_ticks = timer_ticks();
        if (cur != idle_thread) {
          cur->tick_wakeup = current_ticks + ticks_to_sleep;

          struct list_elem *current_element = list_begin(&sleep_list);
          while (current_element != list_end(&sleep_list)) {
              struct thread *thread_current_element = list_entry(current_element, struct thread, elem);
              if (thread_current_element->priority < cur->priority || ((thread_current_element->priority == cur->priority) 
                                                                  && (thread_current_element->tick_wakeup > cur->tick_wakeup)))
                  break;
              current_element = list_next(current_element);
          }
          list_insert(current_element, &cur->elem);  
        }

        thread_block();
        intr_set_level (old_level);
      }
      ```
      </details>
  - **`thread_wakeup()`**
    - This function now unblocks threads based on both their wake-up ticks and priority, and actively checks for preemption opportunities.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void thread_wakeup(int64_t current_ticks) {
        enum intr_level old_level = intr_disable();

        struct list_elem *current_element = list_begin(&sleep_list), *next_element = NULL;
        while (current_element != list_end(&sleep_list)) {
            struct thread *thread_to_check = list_entry(current_element, struct thread, elem);

            next_element = list_next(current_element);
            if (thread_to_check->tick_wakeup <= current_ticks) {
              list_remove(current_element);
              thread_unblock(thread_to_check);    // put this thread to ready_list
            }
            current_element = next_element;
        }

        intr_set_level(old_level);
      }
      ```
      </details>
  - **`thread_yield()`**
    - The logic for inserting the current thread back into the `ready_list` has been modified to ensure it is placed according to its priority, maintaining the sorted order of the list.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_yield (void) 
      {
        struct thread *cur = thread_current ();
        enum intr_level old_level;
        
        ASSERT (!intr_context ());
        old_level = intr_disable ();

        
        if (cur != idle_thread) {
          bool is_inserted = false;
          for(struct list_elem *current_element = list_begin(&ready_list), *end_element = list_end(&ready_list); current_element != end_element; current_element = list_next(current_element)) {
            struct thread *thread_current_element = list_entry(current_element, struct thread, elem);
            if (thread_current_element->priority < cur->priority) {
              list_insert(current_element, &cur->elem);
              is_inserted = true;  
              break;
            }
          }
        
          if(is_inserted == false)
            list_push_back(&ready_list, &cur->elem);
        }

        cur->status = THREAD_READY;
        schedule ();
        intr_set_level (old_level);
      }
      ```
      </details>
  - **`thread_set_priority()`**
    - This function not only sets a thread's priority but also incorporates logic for managing priority donation and triggering preemption if the new priority is higher than that of the currently running thread at the front of the `ready_list`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_set_priority (int new_priority) 
      {
        struct thread* current_thread = thread_current();

        if(list_empty(&current_thread->donors))
          current_thread->priority = new_priority;
        else {
          if(current_thread->priority < new_priority)
            current_thread->priority = new_priority;
        }
        current_thread->original_priority = new_priority;
        
        if(list_empty(&ready_list) == false && current_thread->priority < list_entry(list_front(&ready_list), struct thread, elem)->priority)
          thread_yield();
      }
      ```
      </details>
  - **`thread_unblock()`**
    - This function now inserts the unblocked thread into the `ready_list` in the correct priority order, rather than simply appending it.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_unblock (struct thread *t) 
      {
        enum intr_level old_level;

        ASSERT (is_thread (t));

        old_level = intr_disable ();
        ASSERT (t->status == THREAD_BLOCKED);


        bool is_inserted = false;
        for(struct list_elem *current_element = list_begin(&ready_list), *end_element = list_end(&ready_list); current_element != end_element; current_element = list_next(current_element)) {
          struct thread *thread_current_element = list_entry(current_element, struct thread, elem);
          if (thread_current_element->priority < t->priority) {
            list_insert(current_element, &t->elem);
            is_inserted = true;  
            break;
          }
        }
        if(is_inserted == false)
          list_push_back(&ready_list, &t->elem);


        t->status = THREAD_READY;
        intr_set_level (old_level);
      }
      ```
      </details>
  - **`thread_create()`**
    - After a new thread is created and unblocked, this function now includes a check to determine if the newly created thread has a higher priority than the currently running thread. 
    - If so, it triggers `thread_yield()` to allow immediate preemption.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      tid_t
      thread_create (const char *name, int priority,
                    thread_func *function, void *aux) 
      {
        struct thread *t;
        struct kernel_thread_frame *kf;
        struct switch_entry_frame *ef;
        struct switch_threads_frame *sf;
        tid_t tid;

        ASSERT (function != NULL);

        /* Allocate thread. */
        t = palloc_get_page (PAL_ZERO);
        if (t == NULL)
          return TID_ERROR;

        /* Initialize thread. */
        init_thread (t, name, priority);
        tid = t->tid = allocate_tid ();

        /* Stack frame for kernel_thread(). */
        kf = alloc_frame (t, sizeof *kf);
        kf->eip = NULL;
        kf->function = function;
        kf->aux = aux;

        /* Stack frame for switch_entry(). */
        ef = alloc_frame (t, sizeof *ef);
        ef->eip = (void (*) (void)) kernel_thread;

        /* Stack frame for switch_threads(). */
        sf = alloc_frame (t, sizeof *sf);
        sf->eip = switch_entry;
        sf->ebp = 0;

        /* Add to run queue. */
        thread_unblock(t);

        // now preform preemption if needed
        if(t->priority > thread_current()->priority)
          thread_yield();

        return tid;
      }
      ```
      </details>

- **`synch.c`**
  - **`semaphore_elem`**
    - A `priority` field has been added to `struct semaphore_elem` to enable priority-based waiting on semaphores.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* One semaphore in a list. */
      struct semaphore_elem 
      {
        struct list_elem elem;              /* List element. */
        struct semaphore semaphore;         /* This semaphore. */
        int priority                        /* Priority for scheduling*/
      };
      ```
      </details>
  - **`sema_down()`**
    - It's worth noting that `sema_down()` is not modified
      * because priority matters when `sema_up()` is called
  - **`sema_up()`**
    - This function now sorts the `waiters` list based on `priority` before unblocking the highest-priority thread. 
    - It also performs preemption if the unblocked thread has a higher priority than the currently running thread.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      bool compare_priority_for_waiters(const struct list_elem *lhs, const struct list_elem *rhs, void *aux UNUSED) {
        struct thread *thread_left = list_entry(lhs, struct thread, elem), *thread_right = list_entry(rhs, struct thread, elem);
        return thread_left->priority > thread_right->priority;
      }

      void
      sema_up (struct semaphore *sema) 
        {
          enum intr_level old_level;
        
          ASSERT (sema != NULL);
        
          old_level = intr_disable ();
          struct thread *thread_to_unblock = NULL;
          if (!list_empty (&sema->waiters)) {
            // sort list
            list_sort(&sema->waiters, compare_priority_for_waiters, NULL);
            thread_to_unblock = list_entry (list_pop_front (&sema->waiters), struct thread, elem);
            thread_unblock(thread_to_unblock);
          }
          sema->value++;
        
          if(!intr_context() && thread_to_unblock != NULL && thread_to_unblock->priority > thread_current()->priority)
            thread_yield();
        
          intr_set_level (old_level);
        }
      ```
      </details>
  - **`lock_acquire()`**
    - This function now incorporates the priority donation mechanism. 
    - When a thread attempts to acquire a locked resource,
      * if the holder's priority is lower, the holder temporarily inherits the priority of the acquiring thread to prevent priority inversion.
    - It also tracks the lock that the current thread is waiting for.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      lock_acquire (struct lock *lock)
      {
        ASSERT (lock != NULL);
        ASSERT (!intr_context ());
        ASSERT (!lock_held_by_current_thread (lock));

        struct thread *current_thread = thread_current();

        if(lock->holder != NULL) {
          for(struct lock *current_lock = lock; current_lock != NULL && current_lock->holder->priority < current_thread->priority; current_lock = current_lock->holder->lock_to_wait) 
            current_lock->holder->priority = current_thread->priority;

          if(lock->holder->original_priority < current_thread->priority)
            list_push_back(&lock->holder->donors, &current_thread->donelem);
        }
        current_thread->lock_to_wait = lock;

        sema_down (&lock->semaphore);
        lock->holder = current_thread;
        current_thread->lock_to_wait = NULL;
      }
      ```
      </details>
  - **`lock_release()`**
    - Upon releasing a lock, this function manages the removal of priority donors and restores the original priority of the lock holder if no higher-priority donations are active. 
    - It also correctly handles scenarios involving multiple priority donations.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      lock_release (struct lock *lock) 
      {
        ASSERT (lock != NULL);
        ASSERT (lock_held_by_current_thread (lock));
        
        bool is_donor_gone = false;
        struct thread *thread_current_element = NULL;
        for(struct list_elem *current_element = list_begin(&lock->holder->donors), *end_element = list_end(&lock->holder->donors); current_element != end_element;) {
          thread_current_element = list_entry(current_element, struct thread, donelem);
          // handles multiple donation
          if (thread_current_element->lock_to_wait == lock) {
            current_element = list_remove(current_element);
            is_donor_gone = true;
          }
          else
            current_element = list_next(current_element);
        }

        struct thread *current_thread = thread_current();
        if(is_donor_gone == true)
          current_thread->priority = current_thread->original_priority;

        for(struct list_elem *current_element = list_begin(&lock->holder->donors), *end_element = list_end(&lock->holder->donors); current_element != end_element; current_element = list_next(current_element)) {
          thread_current_element = list_entry(current_element, struct thread, donelem);
          if (thread_current_element->priority > current_thread->priority)
            current_thread->priority = thread_current_element->priority;
        }

        lock->holder = NULL;
        sema_up (&lock->semaphore);
      }
      ```
      </details>
  - **`cond_wait()`**
    - The `waiters` list for conditions is now maintained in priority order, ensuring that the highest-priority waiting thread is signaled first.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      cond_wait (struct condition *cond, struct lock *lock) 
      {
        struct semaphore_elem waiter;

        ASSERT (cond != NULL);
        ASSERT (lock != NULL);
        ASSERT (!intr_context ());
        ASSERT (lock_held_by_current_thread (lock));
        
        sema_init (&waiter.semaphore, 0);

        waiter.priority = lock->holder->priority;
        bool is_inserted = false;
        for(struct list_elem *current_element = list_begin(&cond->waiters), *end_element = list_end(&cond->waiters); current_element != end_element; current_element = list_next(current_element)) {
          struct semaphore_elem *semaphore_current_element = list_entry(current_element, struct semaphore_elem, elem);
          if (semaphore_current_element->priority < waiter.priority) {
            list_insert(current_element, &waiter.elem);
            is_inserted = true;  
            break;
          }
        }
        if(is_inserted == false)
          list_push_back(&cond->waiters, &waiter.elem);
        
        lock_release (lock);
        sema_down (&waiter.semaphore);
        lock_acquire (lock);
      }
      ```
      </details>

### Conclusion
- This comprehensive enhancement successfully introduces priority scheduling, preemption, and a robust priority donation mechanism into PintOS. 
- These changes significantly improve the operating system's responsiveness and efficiency by ensuring that high-priority tasks are executed in a timely manner and by effectively addressing the challenges posed by priority inversion.

### Improved Grade
<img src="data:image/png;base64,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" alt="Description of image">





## Final Thoughts
- Together, these improvements fundamentally transform PintOS into a more robust and efficient operating system. 
- By optimizing resource utilization through intelligent thread management and prioritizing critical tasks, PintOS now offers enhanced responsiveness and overall performance.

[Top](#){: .btn .btn--primary }{: .align-right}