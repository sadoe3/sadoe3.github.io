---
title: "Effective Modern C++ : Chapter 5"

categories:
    - cpp

tags:
    - [C++, Programming Language, Effective Modern C++, Rvalue, Move, Forward]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-1-5
---

# Rvalue References, Move Semantics, and Perfect Forwarding

> 이 포스트는 Effective Modern C++(1st Edition)를 바탕으로 작성되었습니다.

## Item 23

### Understand `std::move` and `std::forward`
As we've covered through [**Primer**](https://sadoe3.github.io/cpp/primer-chapter16/#template-argument-deduction-and-references)
- `std::move` performs an unconditional cast to an rvalue
- In and of itself, it doesn't move anything
- `std::forward` casts its argument to an rvalue only if that argument is bound to an rvalue
- neither `std::move` nor `std::forward` do anything at runtime
- move requests on `const` objects are treated as copy requests


## Item 25

### Use `std::move` on rvalue references, `std::forward` on universal references
As we've covered through [**Primer**](https://sadoe3.github.io/cpp/primer-chapter16/#template-argument-deduction-and-references)
- apply `std::move` to rvalue references and `std::forward` to universal references the last time each is used
- do the same thing for rvalue references and universal references being returned from functions that return by value
- never apply `std::move` or `std::forward` to local objects if they would otherwise be eligible for the return value optimization


## Item 26

### Avoid overloading on universal references
O


## Item 27

### Familiarize yourself with alternatives to overloading on universal references
O


## Item 28

### Understand reference collapsing
As we've covered through [**Primer**](https://sadoe3.github.io/cpp/primer-chapter16/#template-argument-deduction-and-references)
- **reference collapsing** occurs in 4 contexts:
	* template instantiation
	* `auto` type generation
	* creation and use of `typedef`s, alias declarations
	* use of `decltype`
- when compilers generate a reference to a reference in a **reference collapsing** context, the result becomes a single reference
	* if either of the original references is an lvalue reference, the result is an lvalue reference
	* otherwise it's an rvalue reference
- universal references are rvalue references in contexts where type deduction distinguishes lvalues from rvalues and where **reference collapsing** occurs


## Item 29

### Assume that move operations are not present, not cheap, and not used
However, if you’re dealing with types or support for move semantics
- there’s no need for these assumptions


## Item 30

### Familiarize yourself with perfect forwarding failure cases
O


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}