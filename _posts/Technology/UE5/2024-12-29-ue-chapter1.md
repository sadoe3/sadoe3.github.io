---
title: "Unreal Engine 5 : Understanding the Basics"

categories:
    - ue5

tags:
    - [Game Engine, Unreal Engine 5]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-12-29
---

# Unreal Engine 5 : Chapter 1

> This post is based on [**Unreal Engine 5 Documentation**](https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-5-5-documentation).

## Fundamental Knowledge

### The Interface of Unreal Engine
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-editor-interface)
- The `Level Viewport` can generally display the **contents** of the `Level` in **two** different ways
    * `Perspective`, which is a **3D** view you can navigate to see the contents of the viewport from different angles
    * `Ortographic`, which is a **2D** view that looks down one of the main axes
- Type `help` and press **Enter** to open a list of **available console commands** in the `Command Console`

### Terminology
- **Project**
    * An Unreal Engine 5 **Project** holds **all** the `contents` of your game
    * Every project has a `.uproject` file associated with it
        * The `.uproject` file is how you create, open, or save a project
    * You can create any number of different projects and work on them in parallel
- **Blueprint**
    * The **Blueprint Visual Scripting** system is a complete `gameplay scripting` system that uses a `node-based` interface to create gameplay elements from within Unreal Editor
    * Objects defined using `Blueprint` are colloquially referred to as `Blueprints`
- **Content Browser**
    * A **Content Browser** is a tool you can use to view, manage, and work with all of the `Assets` in your project
- **Object**
    * **Objects** are the **most basic** `class` in Unreal Engine
        + Almost everything in Unreal Engine inherits (or gets some functionality) from an **Object**
    * In C++, `UObject` is the **base class** of all objects
        + It implements features such as `garbage collections`, `metadata` (UProperty) support for exposing variables to the Unreal Editor, and `serialization` for loading and saving
- **Class**
    * A **Class** defines the `behaviors` and `properties` of a particular **Actor** or **Object** in Unreal Engine
    * Classes can be created in `C++` code or in `Blueprints`
    * As you can guess, Classes support **inheritance**
- **Actor**
    * An **Actor** is any **object** that can be placed into a **level**
    * Actors support `3D transformations`
        * such as `translation`, `rotation`, and `scaling`
    * They can be created (spawned) and destroyed through `gameplay code` (`C++` or `Blueprints`)
    * In C++, `AActor` is the **base class** of all Actors
- **Casting**
    * The concept of **Casting** in Unreal Engine is similar to that in programming
    * It is an action that takes an **Actor** of a `specific class` and tries to **treat** it as if it were of a `different class`
- **Component**
    * A **Component** is a piece of `functionality` that can be **added** to an **Actor**
    * Components must be **attached** to an **Actor** and **cannot exist** by themselves
- **Pawn**
    * **Pawns** are a **subclass** of **Actor** and serve as an `in-game avatar` of that **Actor**
    * Pawns can be **controlled** by a `player`
        + or by the `game's AI`, as non-player characters (`NPC`s)
    * When a Pawn is **controlled** by a human or AI player
        + it is considered to be `Possessed`
    * Conversely, when a Pawn is **not controlled** by a human or AI player
        + it is considered to be `Unpossessed`
- **Character**
    * The **Character** is a **subclass** of **Pawn**
    * It is specifically designed for `player-controlled movement`
- **Player Controller**
    * A **Player Controller** takes player input and translates it into interactions in the game
    * Every game has **at least one** Player Controller in it
        +  A Player Controller often possesses a **Pawn** or **Character** as a representation of the player in a game
    * The Player Controller is also the primary `network interaction point` for multiplayer games
        + During multiplayer play, the server has one instance of a Player Controller for every player in the game since it must be able to make network function calls to each player
        + Each client only has the Player Controller that corresponds to their player and can only use their Player Controller to communicate with the server
    * The associated `C++` class is `PlayerController`
- **AI Controller**
    * Just as the **Player Controller** possesses a **Pawn** as a representation of the `player` in a game
        + an **AI Controller** possesses a **Pawn** to represent a non-player character (`NPC`) in a game
    * By default, Pawns and Characters will end up with a **base** `AI Controller` 
        + unless they are specifically possessed by a Player Controller or told not to create an AI Controller for themselves
    * The associated `C++` class is `AIController`
- **Player State**
    * A **Player State** is the state of a `participant` in the game
        + Non-player AI that exists as `part of the game world` does **not** have a Player State
    * It can contain information like
        + Name
        + Current level
        + Health
    * For multiplayer games, Player States for **all players** exist on `all machines` and can replicate data from the server to the client to keep things in sync
        + This is **different** from a **Player Controller**, which will only exist on the `single machine` of the player it represents as a **single instance**
    * The associated `C++` class is `PlayerState`
- **Game Mode**
    * The **Game Mode** sets the `rules` of the game that is being played
    * Rules can be like
        + How players join the game
        + Whether or not a game can be paused
        + Any game-specific behavior such as win conditions
    * You can set the **default Game Mode** in the `Project Settings` and **override** it for **different** `Levels`
        + Regardless of how you choose to implement it, you can only have **one** `Game Mode` for **each** `Level`
    * In a multiplayer game, the Game Mode **only exists** on the `server` and the rules are **replicated** (sent) to each of the `connected clients`
    * The associated `C++` class is `GameMode`
- **Game State**
    * A **Game State** is a container that holds information you want replicated to every client in a game
    * It can contain information like
        + Game score
        + Whether a match has started or not
    * For multiplayer games, there is **one** `local instance` of the Game State on **each** `player's machine`
        + `Local instances` get their **updated** information from the `server's instance` of the Game State
    * The associated `C++` class is `GameState`
- **Brush**
    * A **Brush** is an **Actor** that describes a `3D shape`
        + such as a `cube` or a `sphere`
- **Volume**
    * **Volumes** are `bounded 3D spaces` that have **different uses** based on the effects attached to them
    * For instance
        + `Blocking Volumes` are invisible and used to prevent Actors from passing through them
        + `Pain Causing Volumes` cause damage over time to any Actor that overlaps them
        + `Trigger Volumes` are programmed to cause events when an Actor enters or exits them
- **Level**
    * A **Level** is a `gameplay area` that you define
    * It contains everything a player can see and interact with, such as geometry, Pawns, and Actors
    * Unreal Engine saves each level as a separate `.umap` file
        + which is why you will sometimes see them referred to as `Maps`
- **World**
    * A **World** is a **container** for **all** the `Levels` that make up your game
    * It handles the streaming of Levels and the spawning (creation) of dynamic Actors

### Tools and Editors
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/tools-and-editors-in-unreal-engine)
- A **tool** is something you use to perform a specific task
    * such as placing Actors inside a level, or painting terrain.
- An **editor** is a **collection** of `tools` you use to achieve something more complex
    * `Level Editor` enables you to build your game's levels
- A **system** is a large collection of features that work together to produce some aspect of the game or application
    * `Blueprint` is a system used to visually script gameplay elements
- **Some** of these `tools` and `editors` are **built-in**
    + while `others` come in the form of **optional** `plugins` that you can enable or disable depending on your project needs

### Coordinate System and Spaces
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/coordinate-system-and-spaces-in-unreal-engine)
- You can navigate the level in Unreal Engine by pressing WASD while holding the right mouse button
- UE's **Z-up**, **left-handed** `coordinate system` is defined as follows
    * The X-axis (Red) determines how far forward or backward an actor is located
        + Positive values are forward
    * The Y-axis (Green) determines how far to the left or right an actor is located
        + Positive values are to the right
    * The Z-axis (Blue) determines how far up and down along a vertical line an actor is located
        + Positive values are upwards
- Once you select an **Actor** in the `level`, you can modify it using three `gizmos`
    * Press `W` to **move** it
    * Press `E` to **rotate** it
    * Press `R` to **scale** it
- There are various `coordinate spaces` which have their own coordinate system and origin
    * **World Space**
        + It is the coordinate system used for your entire level
        + Its origin is the center of the scene (the world grid)
        + This coordinate system is fixed
            - you cannot transform it
        + Use world space to translate or rotate an object in absolute units relative to the level's origin and scale relative to the entire level
    * **Local Space**
        + It is the coordinate system **relative** to the scene component to which the actor is attached. 
        + The space is also known as `object space`
        + Every actor has a local space coordinate system within a scene relative to the actor's `pivot point`
            - An actor's `pivot point` is where the three local coordinate axes for the actor intersect and represent the **origin** of local space
            - You can temporarily change the location of an actor's pivot
                * `Middle-click` on the sphere in the center point of the translation gizmo and `drag` to move the pivot
            - Then you can make this change permanent
                * `Right-click` the actor and select `Pivot` -> `Set as Pivot Offset`
        + Use local space to translate or rotate an object relative to its parent
    * **Screen Space**
        + Screen space is the projection of the three-dimensional world space onto the two-dimensional screen that constitutes the player's vision
            - In other words, it is the space where the camera in the level sees
        + To visualize the screen space, **pilot** the cameras or pawns in your scene
            - To pilot, right-click the object and select Pilot
    * **UV Space**
        + UVs are a parameterization (U,V) of a 3D surface mesh into a normalized (0-1) 2D space
            - In other words, they represent coordinates in 2D space that translate to vertices on your 3D model
        + The space is represented horizontally as U and vertically as V, thus the name UV coordinates
            - Also known as 2D or texture coordinates


## Assets and Content Packs
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/assets-and-content-packs-in-unreal-engine)
- Any piece of **content** in an Unreal Engine project is an **Asset**
- Assets can be of many different types
    * such as `Static Meshes`, `Materials`, `particle systems`, and `sound cues`
- Some Assets are created outside Unreal Engine
    * for example, in other 3D applications like `Maya` or `3ds Max`
- Other Assets, such as `Blueprints`, are created directly inside the engine
- You should always manage Assets through the `Content Browser`

### Version Control
If you prefer not to create a new file when modifying an existing one
- Go to `Edit` -> `Editor Preferences`
- Search for `Source Control`
- Uncheck `Add New Files when Modified`


## Playing and Simulating
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/playing-and-simulating-in-unreal-engine)
- There are two ways to preview your game in Unreal Engine
    * **Play In Editor** (PIE)
        + which you can access from the `Play button` on the Main Toolbar
    * **Simulate In Editor** (SIE)
        + which you can access from the Play drop-down menu or by using the `Alt + S` on Windows keyboard shortcut
        + In order to use this, you need to check the `Simulate Physics` check box
- The key difference between playing and simulating in the Editor is that
    * **Playing** will always start the game at the Player Start location and give you control of the player character
    * **Simulating** doesn't move the Camera and doesn't spawn a player character

### Play Modes
When you start a **PIE** session, you can select from several different **Play Modes**
- Choose from one of the following options
    * **Selected Viewport**
        + Launches the game inside the currently selected Viewport.
    * **Mobile Preview**
        + Launches the game in a standalone version outside of the Editor and provides additional tools used to mimic devices as closely as possible
    * **New Editor Window**
        + Launches the game within the Editor
        + however, it creates a new standalone window, leaving the Level Viewport the same
    * **VR Preview**
        + Launches a preview of the game on a connected VR device.
    * **Standalone Game**
        + Launches the game in a standalone version outside of the Editor
    * **Simulate**
        + Simulates the game world in the editor, including actors with Simulate Physics enabled, as well as other game systems like AI and environment interactions
        + However, player control is not active in this mode
- The **default** setting is **Selected Viewport**

### PIE Console
The **PIE Console** is an in-game console where you can enter commands to display performance data, enable and disable Unreal Engine features, and so on
- To **open** the PIE console, press the `tilde` (`~`) key while playing the game in **PIE** mode
    * Press the `~` key **again** to **expand** the console, and press `~` a **third time** to **close** it
- A great use case for the PIE Console is to profile a project's performance


## Packaging Projects
You can see the detailed information [here](https://dev.epicgames.com/documentation/en-us/unreal-engine/packaging-unreal-engine-projects)
- Several steps are performed during the packaging process
    * Project-specific source code will be compiled first
    * Once the code is compiled, all required content will be converted, or "cooked," into a format that can be used by the target platform
    * Following that, the compiled code and cooked content will be bundled into a distributable set of files, such as an installer

### Default Level
Before packaging your game, you will **first** need to set a `Game Default Map`, which will load when your packaged game starts
- If you do not set a map and are using a blank project, you will only see a black screen when the packaged game starts
- To set the Game Default Map, click on `Edit` -> `Project Settings` -> `Maps & Modes` -> `Game Default Mape`

### How to Build
Under the `main toolbar`, there is an button named `Platforms`, with a submenu
- This submenu provides a list of all supported platforms for which you can package your project
- Once you click that target platform, you will find the submenu called `Package Project`
- Click it and select the folder location where that package will be stored


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}