---
title: "Chapter 13"

categories:
    - cpp

tags:
    - [C++, Programming Language, Class, copy, assign, swap, destructor]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-10
---

# Copy Control

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Copy, Assign, and Destroy

### Copy Control
There are 5 operations called **Copy Control**
- Copy Control
    * `copy constructor`
    * `copy-assignment operator`
    * `move contructor`
    * `move-assignment operator`
    * `destructor`
- if you don't define them, compiler creates the **synthesized** versions of them by default
- also, as rules of thumb, if you need a destructor, you usually need others
    * if you need copy constructor, you usually need copy-assignment operator as well 
        + but not the destructor in this case

### Copy Constructor
A **copy constructor** is a constructor of which first parameter is a **reference** to the class type and any additional parameters have default values
```c++
class ClassName {
public:
    ClassName();                             // default constructor
    ClassName(const ClassName &);            // copy constructor
};
```
-  the first parameter **must** be a **reference**
    * and almost always a reference to `const`
- because the copy constructor is used implicitly in several circumstances
    * it usually should not be `explicit`
- unlike `default constructor`, `copy constructor` is synthesized although other constructors are defined
    * the default version usually **memberwise copies** data members
    * if the member is
        + class type : then it calls its `copy constructor`
        + built-in type : then it directly copies it
        + array : copies each element with the same rule (class type or built-in type)

### Difference between Direct Initialization and Copy Initialization
```c++
Type object(paramA, paramB, ...);               // direct initialization

Type object = literal;                          // copy initialization
Type object = existing_object;                  // copy initialization
Type object = Type(paramA, paramB, ...);        // copy initialization
```     
- **copy initialization** calls `copy constructor` or `move constructor` based on the **right-hand operand**
    * the right-hand operand can be
        + a literal
        + an existing object
        + a temporarily constructed object
    * **copy initialization** happens not only when we define objects using an `=`, but also when we
        + pass an object as an argument to a parameter of nonreference type
        + return an object from a function that has a nonreference return type
        + brace initialize the elements in an array or the members of an aggregate class
        + initialize the container
        + call an `.insert()` or `.push()` methods
- **direct initalization** uses () to get parameters so that it can **choose** which **contructor** to call based on the given parameters (possibly empty)
    * there's no right-hand operand for **direct initialization**

### Overloaded Operators
**Overloaded operators** are member functions that have the name `operator` followed by the `symbol` for the operator being defined
```c++
class ClassName {
public:
    ClassName & operator=(const ClassName&);     // assignment operator
}; 
```
- like any other function, an operator function has a `return type` and a `parameter list` 

### Copy-Assignment Operator
There are two types of assignment operators
- copy-assignment operator
    * it takes an argument of the **same type** as the class
        + it can be a reference or a non-reference
    * it ordinarily should return a reference to their left-hand operand
    * the **synthesized** version works in the same way as the default copy constructor
```c++
ClassName& ClassName::operator=(const ClassName &rhs) {
    dataMemberA = rhs.dataMemberA;
    dataMemberB = rhs.dataMemberB;
    return *this;
}
```
- move-assignment operator
    * this would be covered later in this chapter

### Destructor
**Destructor** is automatically called when the object is **destroyed**
```c++
class ClassName {
public:
    ~ClassName();     // destructor
}; 
```
- the following shows when object is destroyed
    * objects are destoryed when they go out of scope
    * members of an object are destroyed when the object of which they are a part is destroyed
    * elements in a container - whether a library container or an array - are destroyed when the container is destroyed
    * dynamically allocated objects are destroyed when the `delete` operator is applied to a pointer to the object
    * temporary objects are destroyed at the end of the full expression in which the temporary was created
- **destructor** takes **no parameters**
    * hence, it cannot be overloaded
- we declare the **destructor** by placing `~` before the name of the class 
- when it's called, the `function body` is executed first, then the `destruction phase` happens **implicitly**
    * `function body` takes codes which should be executed sebsequent to the last use of an object
        + it's usually to **free** the dynamic objects
    * `destruction part` destroys the data members in **reverse** order from the order in which they were initialized
        + because it's **implicit**, there's nothing akin to the **constructor initializer list** in **destructor**
- when the data member is destroyed, if it's a
    * class type : **destructor** calls `it's destructor`
    * built-in type : **destructor** does nothing
        + the same thing happens as the local built-in type object is destroyed
        + note that `the member's destructor` is not called when the member is a reference or a normal pointer (**not smart pointer**) to an object of the class type 
            * therefore, if the normal pointer points to the dynamic memory, it should be deallocated from the `function body` of the **destructor**
            * if you don't want this, try **smart pointers**
- the **synthesized** version is just the **empty body** function

### Default Member Functions
We can **explicitly** make the compiler create the **synthesized** version of member functions or **prevent** it from creating them
```c++
class ClassName {
public:
    ClassName() = default;
    ClassName(const ClassName&) = delete;
    ClassName & operator=(const ClassName&) = delete;
    ~ClassName() = default;
}; 
```  
- as we've covered before using `=default` make the compiler create the default version of some speical methods
    * note that it's not true that every method has their own default version
- if you don't want the default version, you can prevent it from being created by the compiler by using `=delete`
    * unlike `=default`, we can specify `=delete` on any function
- the default version of a method might be defined as `deleted` when
    * the synthesized destructor
    * p508
    * 
    * 
- in essence, the copy-control members are synthesized as `deleted` when it's impossible to copy, assign, or destroy a member of the class 


## Copy Control

### Key Concepts of Assignment Operators
There are two points to keep in mind when you write an `assignment operator`
```c++
ClassName& ClassName::operator=(const ClassName &rhs) {
    auto newp = new std::string(*(rhs.ps));   // copy rhs.ps first before deleting
    delete ps;
    ps = newp;                                          
    i = rhs.i;                                // copy other data members which are valid after deleting ps
    return *this;
}
```
- `assignment operators` must work correctly if an object is assigned to **itself**
    * hence, it's usually a good pattern to copy the right-hand operand before destroying the left-hand operand
- most `assignment operators` share work with the deestructor and copy constructor


## Swap

### swap Functions Should Call swap, Not std::swap
When you implment the custom `swap` function, try to call `swap` not `std::swap`
```c++
void swap(Type &lhs, Type &lhs) {
    using std::swap;                // important
    std::swap(lhs.a, rhs.a);        // doesn't call the custom swap although it's defined
    swap(lhs.b, rhs.b);
    ...                             // swap every nonstatic data member
}
```
- otherwise, there's no way to call a custom `swap` for the data member although it's defined
- by calling `swap`, the custom version is called if it's defined, otherwise, the library version is called

### copy and swap
**copy and swap** is the technique which swaps the left-hand operand with a **copy** of the right-hand operand
```c++
ClassName& ClassName::operator=(ClassName rhs) {
    using std::swap;      
    swap(*this, rhs);
    return *this;
}
```
- `assignment operators` that use **copy and swap** are automatically exception safe and correctly handle self-assignment


## Moving Objects

### 


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}