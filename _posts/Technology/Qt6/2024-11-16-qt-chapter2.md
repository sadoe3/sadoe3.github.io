---
title: "Qt6 : Event Handling"

categories:
    - qt6

tags:
    - [Qt6, GUI, Event Handling, Event, C++]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-11-16
---

# Event Handling
This post covers things related to **event handling** of `Qt Wdiget` Applications


## Core Architecture
There 3 **classes** you can choose to develop a certain type of Qt Widget applications

### QCoreApplication
`QCoreApplication` is the base class for **non-GUI** applications
- it handles the **basic functionality** needed for `any Qt application` that does **not involve** a graphical user interface (**GUI**)
    * this class manages the event loop and application settings, but it does not provide any GUI functionality
- Use Case
    * if you’re writing a **command-line** application or a non-GUI-based application
        + e.g., a server, a daemon, or a background process
    * you would use `QCoreApplication`

### QGuiApplication
`QGuiApplication` is a **subclass** of `QCoreApplication`
- it adds **GUI-specific functionality** for applications
    * that do **not** use the **full Qt Widgets** system but still require some basic GUI features, such as handling windowing systems, events, and interactions
- Use Case
    * if you are building an application that involves **low-level GUI elements**
        + such as handling `OpenGL` windows, QML-based UIs, or custom widgets without relying on the full Qt Widgets system
    * `QGuiApplication` is appropriate

### QApplication
`QApplication` is the **most commonly used class** in Qt applications when you need both event handling and GUI elements from the Qt Widgets module
- it provides all the necessary event handling and GUI features for creating and managing widgets
- Use Case
    * if you're building a traditional desktop application with a standard set of **Qt Widgets**
        + like buttons, text fields, labels
    * you should use `QApplication` 


## QObject
`QObject` is the **base class** for `most Qt object types`
- it provides **core functionality** for all Qt objects
    + such as object memory management
    + properties
    + event handling
    + signal-slot connections
- it's **not directly** related to **GUI components**, but rather to object model and event management in Qt
- `QObject` is based on **parent-child** relationship
    ```c++
    // constructor of QObject
    QObject(QObject *parent = nullptr);
    // Parent adds the object to its list of children
    ```
    * the **parent-child** relationship in Qt is a memory management model for automatic deletion of objects
        + it's worth noting that it is **not related to inheritance**
        + which means that if class `B` is a child of class `A`, this doesn't mean that `B` is the derived class of class `A`
    * if object has children and is being destroyed, **its children** would be **deleted first**
- `QObject` can be constructed on `heap` area with `new` expression, or on `stack` area as a local object
    * **Most** of `QObject`s need to be **dynamcially allocated** with `new`
    * but some may not
        + `QApplication`
            * local to `main()`
        + top level `QWidget`
            * like `QMainWindow`
        + `QFile`
            * usually local to a certain function
        + value types
            * such as `QString`, `QColor` because it's cheap to copy

### QWidget
`QWidget` is a **subclass** of `QObject` and is the **base class** for **all** user interface **objects** in Qt that appear on the **screen** (such as windows, buttons, labels, etc.)
- it adds **graphical** and **interactive** features to `QObject`
    * it's worth noting that `QObject` **doesn't provide** any **visual representation** functionality
        + which means that if you want to **paint** (drawing widgets on the screen) a certain object, you need to make that object **inherit** from `QWidget`
    * the additional features that `QWidget` provides are **mouse** and **keyboard** events, **focus** management, and widget **positioning**
- if a certain `QWidget` object **doesn't have** a **parent**, then a **new window** is created
    * if you want that widget to be used for **user interaction**
        + such as input collection or displaying messages
    * it may be called a `dialog` 
        + but only if it's **inherited** from a `QDialog`, `QMessageBox`, or similar
- the widget position of a **child** uses its **parent's** coordinate system
    * if the child widget **crossed the boundary** of its parent, it would be **clipped** on the screen
- **children** follow the `state` or `enable-ness` of their **parent**
- you should **never include** `<QWidget>`
    * you need to include **specific widget** like `<QPushButton>`
    * class hierarchy of `QPushButton`
        + `QObject` -> `QWidget` -> `QPushButton`

### Multiple File Handling for a Custom Widget



### How to use a Custom Widget


## Basic Event Handling

### Events

### How to Handle the Event

### How to Create a Custom Event Handler

### Signals and Slots

### How to Setup Event Handling through Qt Designer

### How to setup the custom slot through Qt designer


## Extra Details

### How to Pass the Text to the Console

### 



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}