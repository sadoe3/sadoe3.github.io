---
title: "Project 2: System Calls"

categories:
    - pintos

tags:
    - [Operating Systems, PintOS, Linux, System Call, Argument Passing]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-03-22
---


# Upgrading PintOS with System Calls and Argument Passing
- This project enhanced the PintOS operating system through three key improvements:
  1. Enabling child processes to load and execute files.
  2. Implementing argument passing to child processes.
  3. Adding system call functionality with robust synchronization.
- Below, I outline the objectives, challenges, solutions, and implementations for each component.


## Part 1: Executable Loading

### Objective
- The goal is to reimplement `process_wait()` to allow a parent process to wait for its child process to load and execute a specified file.

### Current Problem
- The original `process_wait()` function was non-functional, lacking the ability to synchronize parent and child processes effectively.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  int
  process_wait (tid_t child_tid UNUSED) 
  {
    return -1;
  }
  ```
  </details>

### Original Grade
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkIAAADFCAYAAAC4jZ1JAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsEAAA7BAbiRa+0AAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAABqb0lEQVR4Xu39fUxj2b3g/X7PaW3rHFuKNiePrRPtnsQox9ZERv2Ansh5IqME67Rc6gM3rd1UinRDV66r+kL1yKGHKgaKuYQ6dHNFU5cqRIURDQ9Vvg+B6y40jkct0JmyOoKbi/UkzhOBOliJbLWwTnrP7bGVYD0tM/14a/rcP2zAmBebaqpS1ayPVFJhby+vtV/W+u211vb6i6997Wv/giAIgiAIwhn0l6UvCIIgCIIgnBUiEBIEQRAE4cwSgZAgCIIgCGeWCIQEQRAEQTizRCAkCIIgCMKZJQIhQRAEQRDOLBEICYIgCIJwZv3Fob8jZLTR2HGJpjorFhNkUxrxtRBT0xHSgNU7zi1XgoHXJogVPqK0jnLnnMZblycw9c5ytQ7WfvI6QyuZ/PvqKHfaqtlafovXFh2M33qJZ1MPuP76NAkAyUnX3V7qTXHuXe5jKf8xkD0MTnZQo68ycnmMqL6TSTPq6Du0Ve/8nWProxjRBT/+iIZudNJ1pwtrZIBuf4Ldjykqw6MqOf81boTTO68eydgwyE9/VLP7dy67hbaxzNz0POsZM57BW3gN9+nuW0Lb2Uiy4R19E1dyjM6xKNu7nz6EVEvX3R9Tbyp9o6Cwj9KNw9y9ZC99l9zabS4ORdCRMDvb6Gh14Xi2CrJbpDZjhBemWIrpNPS/y4/qSj+9Y5O5K92Eyu8OJGsDXq9Kvf1ZTGRJaZvEw37GwkkA5OPyOZLFV0FZE6WvC4IgCMIj8owsy/+4/yUZT+/b/FD5kP94d4q50DJryU+Qq7/Ex7/8PX8C5LoXOPfVP7H8XpSdtvNLz3l44e8+4RfvRTHUq/xPf5XF9OUMv1j5kE9R+N5rL/C3/DV8/Avei1t44dxX+e+5L2P4cInfpMH47VZ++JyJz57ZJrb0cxKf5tM1/s8v8+r/8Hui//05vqr9E7/8+LPCN5r4hqeJryen6BueJfz/WeOfTU5efPV5vhwL85v/8gd+/+k3eOn8t/j0Fz8nsZ0vm+v1q3g+CzE8+Rs+KaR0HMnq5qVvZZi7PsjMe++z+sHHfOX5V2l5LsPPV35LLAHfvnCer3+8TOQP+UybX/h3+L6ZYn50nt8fGwUBn/2RD9f+N1aXl3n//f+NT7/+XezpnzHw//xfefD++/zTz3/NHz75FIP9eV50/P+Y+7/f5v/9/vu8//77vP/+PxGOfMiftnUkx2vc7P0un0ZmmJz6j7wf/T1p6at89dPf8ps/bJP6XZTo6jLvv/8+HzzzHN+2xLk3MM7999/n/X/6/xJLf8KnO7v2KEYnbwz7qPnTEv7p/5X/+H6U5CcmrF/JEF3/mM+Avzoun598XFFZy2VDEARBEE7LwaExqRanQ2JtYYKlaIJkMsF6ZInpsdCJ7tT1eJSYxYVTBqwN1EnrRLXc3ga5FOvrGepcDiSM1LmqSa7HyBYngpG6ejupjUXCMR1HvQNp3/tANoOmaSQT66z4F1jLWnA4FQAyYT8hzYrqdWEEJMcF2uq2CE8t7vXeVCTLVlJD05Ik1sMsRj/CoNhRALRFpsJb1LVdwCHlgwWvakULTVNBhxOgk04mSSQSJBJJtCyQ1YgnEiQSCZJaZq83iyypZP71ne2T6XykZXU6kFMP8PsjxJJJErEo4fkxpiP5rrXt9M53JEhuZYEs2k5aSY3M3pccSbK7qDPFCU2EiMSSJBMxIkt+bvrXi/LIMfk8SVkFQRAE4dE7GAixTVY3oNQ5kEvfOgk9RiRmweUyY3U5kdaXyQ+e7NGWV8nUubHLdbjsGqvR/WEQUh0ue5Z4NEl8PQ4OJwcHXXYYUZwu7CbQczvNqcbiVJhsXRttDitNXjdSdJ77iYdvbiXZQb3DQlaLF4IpncR9P1HJjbfJhqOllbpsmKnFk4Van1cmo0OVHYdyIFQ8NXo2Q9agUOswHwxIBUEQBOEpdDAQ0qPM3VsF14+ZnB1nuN9Hq6cW84lbPp2N5RiW+jZUp050+ZDAIBNlNeWg0evBHl/mYBzkpCYXJ5oEfSNK0lSHy7Z/G1N9L+8GgwSDP+XO1Xrk1Cqhpb3v0hP38UfA3fsmqiXGnL/MnJ1D1fGjd4MEg0HevfsmbpaZGAuzM42J7XX8czEsF35Mr8dE1H+fzxFrHc3wLa4W8rHzb1TN936lH/hZ3FS4dGeWmdFBetpVXLbPFcoelAjhf5Ch5uo73J0cpb/LS6NTwVi63TH5FARBEIQnycFACEivjPHG5SsMTYXZSBmpu9DLnVEftQdavOPp8WXW5HrqWWMlWTQstiOXJhJJUVdfTTyyxva+TSQcLgfEo8R0YDtGdFOmrn5/JJRdu8f1a9cYGPkZa5sbLIxMUBgNKthmfW6RuMnE1oM5CnO3TyjO3PVOOq9d4/pbU6xSj6/Lg7loi8zKHA9SJkzJEP71k4daFcltMHf9Otd3/11jbDmVf287xvyN17l8bYS5SBJdaaDj7TsMNp5mAJIhOt3N5SvXmQhFSGGnqesOd3oa9u2LY/MpCIIgCE+QQwMhALbTxCJLzE/fpLtzgrUqFy3uQg/DITENADkdvbgnRI+x5L/H1HTRE1UlMqtzTN2bYiFaEjxIDuodVZi+dbXQ43OXjhoDllon1uLtsmmSySSx6DwTIZ3Grrb8XJ1922TI5mA781BR0N4coWR+jtD01DLZmkaa9mUkQ2YbctlMyTyn03Rw7o22b3KPTia5zkrIz9iNbgZ+tkWNqlJbtMVp0NMJouEQ02N9dI4so39LxbP/oJTJpyAIgiA8GY4OhIptp8hkDUhy/rnnTGYbDBKmooDDaDBBNnsgCNCiS4RjxwQg2wlWliIkS9tJu5Na0yY/G7hGZ2cnnZ2dXBt5wEcWJ64jOjkykftEDB7aPPv6J06fDjlMmI56DPyJoJNKZ8iZjBhKA8NTpKc1sk/8vhAEQRCEwx0SCNXiHe6nvdFFrc2K1VaLp72DekuKeDTfr5OJbbAp1aF6XTisVmxOlTaXha3E2pE9Pydlc9VRlVojEkuiaVr+ybBohET2WeoKT4UdlCAc1rCqLdSeauNvosqqoChWbA4XrV4Xz2bjrG2WbveombBYbdhse/+siowEmD09DHe14nE6sFmtOFwqV9Ua9FiUeGmQ+bCsKv2DPtQGJw6rFavDhbe9keqtGOv79sXR+RQEQRCEJ8khgZBGbCOL4vFy9c1b3Hq7lwuODKu3h/DvPD+fnGdkbJmso4P+W7d40+fBsP4ThqZKH6N+WDbq6yxsJdZLnjSLE41nqXY5989JKaItLxIzuGg51V4hO21v3+HOnVu83e/FyTpTb00QeURTgY5kqKHt7bd5u+jfrS43FiCzuY5mqkNt7+XNW7fo7/Bgis8xcntlb1L355WKs5Yx42rx0X/rFrf6vdSyztTQFPtGNo/JpyAIgiA8SQ7/ZWlBEARBEIQz4JAeIUEQBEEQhLNBBEKCIAiCIJxZIhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiCIAjCmSUCIUEQBEEQziwRCAmCIAiCcGaJQEgQBEEQhDNLBEKCIAiCIJxZIhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiCIAjCmSUCIUEQBEEQziwRCAmCIAiCcGaJQEgQBEEQhDNLBEKCIAiCIJxZIhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiCIAjCmSUCIUEQBEEQziwRCAmCIAiCcGaJQEgQBEEQhDNLBEKCIAiCIJxZf/G1r33tX0pfFARBEAThaSTh6p/lap0BgOyvRrh8M4peupmw60Ag1NAf5Ed1xa8U22TuSjehdOnrD8tK6/gwdSvddIe00jcrIFPb2k6buwalSkLfSqHFo9yfnmc9U7rtMWQPg5Mq2sDrTCdK3xQEQTiravHN/Bh31c7fObY+ihFZ8DMX0Yoa189blx9nJw+bzHV2k09exjM4SUcNrN2+yFDkSWjmjTjUq7Q32qnSNaJzt5mInLCxtHoZv9XEs6WvF2RXR7g8lg9qJFcPsx06Y5fHiB5afAlXzywdjD2CQOgUyvoEHdcDQ2PRqWtcv36d69evc3s5Bdk17hX+vn5tjOWTBBiPmKL203vOQnLhNgPX+hiZCBHdrsJiKt1SEARBeFip5RGudXZy7foYIU3Bc7WHNlvpVo/W1paMy6nk/5CduJQsW7nSrf6MbC20N6Twd1/k8tAq5jYvLmPpRmVoIW5eK7S31+fYyMFHD0YKf19jYG7jlAOah3QaZS14Eo7rgUBoO50kkUiQSCRIbmWBLFoy/3ciqZEpHAVJcdE+OM5sIEgwMMNoVyO24h0h19LaP85MIEgwMMvM+CCtjp0NbLRPBgkGb/HSswaq2+4QDAYJBgP0uKSiRI5jptapkI36mQivk0gmia2vEJqYIFx0Q3JsPs0qo8Egwbsd1BgsnHs7WMjHIB55Lw1BEISzLLeVIqlpJBNRlsbmWMs9S63TWnFdbnSo9IzOEAgGCczOMD7YjvNEdWwOLbqO5GpAAWSXC0ssSnI3KjDiUHsYHp9hNpD/jtEeld0mByPOrhkCoyrWnWxJDtrHA4y3O6i01amEvtOI70vUiLGSQEHP7Gtvs8C2tllok5Mk09sYGwYJBoO8e/VbGEz19L5baLfGW7GWpveIfa6ywhNzXA8EQhUxOvENdmBPLzHSfYXOAT8xSwu9Phf5/Ek4vVdpkteZ7rvC5c4BxhbW2es4SzD9ejPNzdf42Uc5Nuc6aW5uprn5ZW5W3BWWJZsFk7V2fwBWrFw+0yG6m5tpvjzFRi7Fg+vNhXzcIPwE9XwJgiA8OXR0HQwGqcK63Eab7wKK5mfgymU6+8ZYiGoljWcFksusS3U0WM246i3EIjGyu28akOUM0YUxBrqv0DkwTaxKpfdqA/l4a5vo1ATLpgv4LtiQMFLb4cOtLzLhj51OL0viPtNRC+13ZrnbX0/aP09k24jV5aVn0Mc55aQFPtz2yg2am5v5we1fkcuuMvKDQrv1xjzJ0o0fldMs6xNwXB8qEDKfU3Fml5mYCBPT0miJCHNzUahz4zQCmDBbJLLaGmvJNJl0klgkRDi2XZrU57BNZG6OmKmJt+/OMD7Yg6+1AYe8dwDK51MQBEGomGSmtk2lzrRFfK3CZleyIMuQXlsjkc6Q1mJElpaInnRKSW6T5Sg41Tbq5RjLG8XNXIaIf5pQJEZSS5NORplb3ECy1+31FGyv478dRmry0dHqo8OZYWFinkSlrWVZ28Tmh3jjtYtcfH2A+1knXYO9qJY1/EM3CZ3eFz0BTrGsT8BxfYhASKLaqmB4tolbwZ2hpCDvvummyiBTZQLIEH2wBs5eJkf76WpvxeNUTnwDUI6eXGLo9ct0jswRjm8jOy/x5uQwrTapwnwKgiAI5Tz70q18HfruO/zYI7P5swn86xW2NPoaK5EMjo47+RtWbyMu68PdiSZX1qC+HvPaMvGSrzc7vfSP5odQdoeOJIniql5PzDG2qON6qY7M/QlCFcZyJ2G0NdDe309H3RahkRuMhdZJV7irnjanVdY/93F9iEAoL7fxE15t3hlK2vm390RZeuUmr3cOMB2OkZXraOsdZbj1UYxgbqOtr7A0P8HQG9e4l1RoanHuBl3l8ikIgiAcL7V8m2vXrnGt8wqvXnydG/PrVD57YJvoRCev900TWk8j2VV8t27R7niIW2Ntiempe0wvlQx7KCq9XW6ktQmuXc7X8z8Y+RUH59zK2O0WAMwOa2F45bTIONsH6W2qIjo1xFAog6t3nJnZGcb7W6k93S/7Mzvlsv6Zj+tDBEI6m8kUKHXUlDmP9XSCaDjE9M0+Rh5kUOrqMO/fAnSQHu7m4BAZ0ikdJBPSCfKZ36sShvzPLgiCIAhFclsayWSSpJZm+9A7/nJ1uU4mGWUl5Ges7waLH8nUOR/mxjhDLLxEtOQJfcnqQNHXWFpYJ12YgWGxWSit0hX1Km3KBhPX/Wg1Hfga9rdIn0+GjbkRboyFWE/r1LZ1UJecoPNiJxObdXS01Z7uqIgOSNKxaeq6jmQ4bouHddpl/fMe14cIhCC9HGINJ+29Kk6rGbNio7ahlS6fh/xDcGZcrV4anTYUWcZsdeJ2yGQ1reQuYgstA5YaJzZZQpJOsuskXL5RerweXLU2rFYbzkYfrU4JbT3GdkX5LNBTpLMmbK5aZEniRNkQBEE4846py421qO0qLoeCWTZjdXqoqdLRNk+vW17XNFKSlVp74XEdqwevu3rfNpKtla4LZtamJ4gkwkzci2O/5KNxX2Pw+Wxvl8yDzeno6OjbOpJU2nx/PnoqTcpQjdNpxnhou6WzGdfA7sZjMyPLMsYD2zy8x1HWx3VcHyoQIhNh7MYEURpoH36Hd0Z/jE+1w6bGFgA6WYOC2/tjRu/e5Z1hL1ZtgbGp0h91yk94XjOqvHn3Xd59d/YEj8/rJNfiYFfxXn2TW7fexKcqaIsjjOz8oFfZfO4ktU5oLoLu7OXuu+/y7rvi8XlBEITKHVOX6zpYXLR1DXPn7jsMt9eSfXCbiZXKB9fKSt5nYk7D0fUOszOT3OlwsLa8tvf0kdGB19eEKTLBVDTfgKdXJpjaUGjrat2beHuK1u/7idf0cnf2Lr3OTabnStu/zykZYv5BBnvHO/z03Xd5d/Tg4/Pp8BRzG2Za3n6Hu3cn8TkfQUEfZVkf03E98MvSgiAIgiAIZ8XD9QgJgiAIgiB8AYhASBAEQRCEM0sEQoIgCIIgnFkiEBIEQRAE4cwSgZAgCIIgCGeWCIQEQRAEQTizRCAkCIIgCMKZJQIhQRAEQRDOLBEICYIgCIJwZolASBAEQRCEM0sEQoIgCIIgnFkiEBIEQRAE4cwSgZAgCIIgCGfWkavPO9pnePNcVf6P3Bq3Lw4R0Ys2kD0MTnZQY8j/+dHiNd7wJ4s2UGgdvcNL1fm/cvF7vN63RKZoC8nVw+zVb5FPYovlt15jYr1og9NIo2w+RVlFWfN/HkzjFPJ5GmmUzacoqyhr/s+DaZTPZ3nl0ziNspZVNo1TyGcFyqZRNp+P57iWzWcFyqZRNp9PR1mPDIQkWcFi2vkry5aWYXvfFkbMSlXhiyGXTZHOFJdOwmi2ULW7wRZaen8KSDLK3peQTWnsS+JU0iiXT1FWUda8g2mcRj5PI41y+RRlFWXNO5hGBfksq4I0TqGs5ZVL4zTyWYGyaZTL52M6rmXzWYGyaZTL59NR1iMDIUEQBEEQhC86MUdIEARBEIQzSwRCgiAIgiCcWSIQEgRBEAThzBKBkCAIgiAIZ5YIhARBEARBOLNEICQIgiAIwpklAiFBEARBEM4sEQgJgiAIgnBmiUBIEARBEIQzSwRCgiAIgiCcWSIQEk6VWR0lMO7FWvrGwzA2MBiYod1R+sZpkrB6ehifDRAMBgmOqphLN3kiKKijAUZbldI3HgMJV39h/wSDzPY4kUo3KWJrnyQw6EEufUMQBOEJdHQgJHsYDEzSbit94zRZaR0PMKqeUuUu1eKbCTDoeTKbsieOtZXxwDithajF5p3cbeyCwQCzM6P0tDr/fIGBnmY9GiV+sqWyT8bopM1bQ+Z+H5dffZVX+xZJl27zyFVyHWTR1qLEEtnSNx4DncjQyzQ3/4Dbv8qVvnlAJrZGdF3j8JxWUlbhi0ZSGvANTzIbCBKYGaWr0YaxdKNiJXUTyNS29jA4OslsMEhwsp3SpsnsaqdneJyZQJBgcBT1QMUlU9vaz/hMPqgPzIzSozr+DAG7jGMnH4FZJgfbcR7IaxlGG41do8wEAgRmJxn2NaDs3J1IVjxdo8zMzjI52oXHetxtyx5z4zCBSR+OyjYHxUPX8Dgzs4F8ezE5TJfq2Hdca30zRW1K/t+Mr7Zoiwo8grKWOjoQegrJbhUnUULLj78pe/oYcapuqmIhlpJFL2+tcvtaJ9euDXB7QUNp6qJ3rzZ6vPQYobFpVrTSN05RlQWZLeKxJJntbbb1EyxZ/FhliM6P4Y8+yqjwdKQj04yFYjype1J4zCQH3v4f4cyFud3XydBCCvulXjqcR4VCh9VNEibDNslIiNCvtvZvXmAyQWYjzMLixqFBuNnTRW+TmYS/jyuXrzCwkKK6rRdfw1H5eDR28zE3QGffBFFDPV296gl60Y04O3q5ZE+xMNRN3+0wudof0e91IAHmpg5UKUTf5csMLEqoXk/5m1nJgdpkJbl4n1ilF66UI7WxhH9iiIHrQ0yFs9jbeun17A8tc/GfMXD9OtevX+f69WsM3Y/te/94j6CshzgYCJlVRoNBgnc7qDFYOPf2TiQ3SHH5JMVF++A4s4EgwcAMo12N2IrPJ7mW1v5CdB6YZWZ8kFbHzgY22ieDBIO3eOlZA9Vtd3Z7IXpcRRHdsWmUsqE22kktLbC+cyCtXsYDwzQW7Zla3wyB/oairn0FV/sgk7tR7Sj9jfvvNcqWtTBsMe514fEN59MKzDLuzY/pKOoogcke2rtGmZydZXZmnJ4Dd0THp5EfwvExPDlLIBhgdnKQdpeyb4jC7GxneLLwuR6V1v7A0cMYZjeqU2c1FGFf06pnSSU1kskE6+EpQjED1TWO/Mkl1dI1G6C/YS9FydVPYLYL574vkXG1DzMTCBKYHae/5C6hbFklF/27dxBHDY3JONSuov0xSk+j7fCyHsbqZTwYJHinjWrDs7x0q/B9O0NjFZQ1fwfVheodZHwmQCAww7C39sAdptnZSs/oTP5ueHaS4a4G8v0hlVwHZhqH9+6mDh0ak4rO4cAsk8Mld0ZWL+OBUdobC+dPYJbJfhXb7iZGHGoPw+M7eZxhtEflyEvtCFbv+N6d34GhsXJllajtmjk4pKa0MhqYxFt6+y88NaQ6D/WWTULTIdaTGrHwNKENE87G+gPXChxVN6WJ+Cfwh8KspQ8LcyAZnmZ6fonlWJqD/ZYSil3BoK0QiiRJZ9IkwiGiKRNK9SHX1COjUO+pgeg8UysJtGQU/71VMtUePJWe43I9jU4TG6FpwjGN5HqI6aVNLPUe6nau6Z02UAcMRZ81Gg/tiZNdKvXSCTsRkivMz4eJRGPEEjEioSnCmyaqHfb99XBWI55IkEgkSCSSJNOVRlqPpqyHORgIpUN0NzfTfHmKjVyKB9ebaW5uprn5BuGds9LoxDfYgT29xEj3FToH/MQsLfT6XIUvlnB6r9IkrzPdd4XLnQOMLawXDTkkmH69mebma/zsoxybc52F73iZm5GdUpVLYz+jS8VdtUbowcm6D2RPO756WL3dzZUr3QxMLbJZfJzKlnWHAYu7DdfWfQauXOTVzrdYiO1dxgZLHdWpKa5dvMiVkSiWtsPuiI5OQ6rtoL+jluziCN1Xurm9CvW+Htp2WjOlkatd9UjRMa519uHXanHXFZ8VxSQcahPW5CKhI8N/CaPVTb0Vcjn9RHf3hmed1MvLjHR3MnAviflCLz5X5WVFjzDU3Ezzqz9h42CNlg8KW/vpv6Cg3R+h+0onA1NhMhYLptJNj5L080ZzM82dc2zmPuJnnYXzvDt05Dl2GIOlDmdujr7XXubySBSjpwO1qEIz1vp4s+scVTE/bxXOn1VdwSxR4XWQZqmvmebmTuY2D90Z2Np6CudwH1e6R1jMOujo91FbvMsN1Tjr4kx0XuTl16fYtF6go2mnATAgyxmiC2MMdF+hc2CaWJVK79WGwxuqIyT9b9Dc3Mz1B6lDGqJyZdWJhaNk7G5cRTcu1gYnSmqV5URxWsLTRLFZMW0lie9WzRli8RQGxX5IL0glddPD0EluJMkqThoKd7Gyox6HnGItWtwl/ohJVmwKbMbie3VqMsZmzkK1vcKrTbGjGFLEi+YMaPEkW6Z82unFeyxKKsN37zKs6oSmwqQlBafaxeBVlYNfY6WxycHWcojodul7lZIw1zbhUnJo8c197YXBcYm7hWGt0R4Vx4HvP8apl/VwBwOhCpjPqTizy0xMhIlpabREhLm5KNS5ybftJswWiay2xloyTSadJBYJEY6dZC+fJA2Fc2od2Yc4kLJZhq0k0XWNdFojub7CfHiv1i1f1iLaIhPz66S3dbbTCSLRoqAsu8biQoJtYDsRIhQz4WyoO9iDcWgaEnUeJ6aNBSaWYmhpjfX5aR5oz+I6ZwdAafBgz6zin4uSTGusz/uJfFSaeIHsQq2XiIbCBxt9yzneDgYJBt/lp7cuUWf6iOXQ6v5eo3JycUITYRKaRmJlioWYRJ3beTA6P7SsFZDqUM8paAtjTKzE0NJpkuthpv0lvVuPQ3aN0M5xXV8mlpGxVu9cfTL1qgs5do8Rf4SEliadjLI0Mb/Xa/m5OXC7niX1YJr59SRpLcbSxAIbJiee3VsmgBTR+2E0HchEWYnpKDZr4fzLEPFPE4rESBbyOLe4gWSv4yGH3B+KHlsmmrLirt8J0Gy46y1oKys8xqZKOGVylQmyW2TNDfTPzDKsWsmmM2CSMZWeX8fVTZ9TZuU2by3kcL/9U4LBIHf7naSmhpg+1YCrDJNMlSFHNpvD5h1ndtKH05RhOwtGubJWW5KNmMiQzlhRh2eZ6W/AnN0ii4kqGdATLN3s5rWLF3mt28+m3Ut/fys2bYGhoXnWSypJo1PFbYkR2jdHolIK6mi+vXjnx270xSHeWto7cum1Je5N3GZkYICRe1Gy9jb6e9VCj3h5p13WozxEICRRbVUwPNvEraIJUO++6abKIFNlIj+f4cEaOHuZHO2nq70Vj3P/ME55lach1ao0KnFCi4kT9VwAJCNh4lVNvDk5TH9XO60eR+FunQrLuiNHJh4/8uLNbaXzjRAA26S0DFisWPZvdUQaFhSLREbTihr6FIlUliqzgoyEoljIpZJFvVka8fTB+3IAa6OKI7VMKHrI3tpa5SfXrnF94Cc82NjkV1NDTK+fLLrMZZJs7n5kG01Lgbm6wrJWwGJDkTLENyoMnB6hXDbD1u5u1NFzYNqt3RWsCmix2KML0IwKiimHlkjtvZbR0DIGLNaiPZ7LkN7NhE5Oz4Fh72oyO730F4bvgsEg7179FgZJqryH7VQkCEc1lIaGfE+BzY1TTrK8+uc/zsIp0LfJZLbY2jp8aItyddPnZKxtw9doYn1qgGvXrvPW3CbVHf349nWdPi46eibDViZL9vBq+hg7Pf1ZsltbZDLbh7R7EoqrlZ5BH+dYZuLGTeaj2iHbmXGrTvTVEJGHqqRSLI9d49r1AW7PbSCf83HJuRfQaZEQS5F1YokE6yt+RqZXydpPMAx4qmU92kMEQnm5jZ/wavPOsNnOv25ChZYtvXKT1zsHmA7HyMp1tPWOMnzCSbeVpSHjVp0QCVF+ePOQMCq5xI0rnQzNrbKpW3C2vcmt/v0TrsqVdXe73DG73lDy7dL+4cwdx6ZxGoxOVHcVscWlw++y9SxaMkkitsL0xDJVl66y7wGfE1+0R3vkZf28TrGsj1Zl+/HI4igqvV1upLUJrl3On98/GPnV0ds/Qlp4maTFidsm4TjnRI4vEyl7XQtPssxWFkxVmDJRJrrf4OZKGpNZhmyGbPGpW65u+lzMuFvcVMUWmArH8nMglya4H5NxqfUHe6sflWyGrZwBk8lEMnSDN/r8xHQZowm2M5VFInomQxYZs5wmfPMNuieiZExVmMiylQGMDloH+2m1JpgfGuLeZg3t4zPMzk4y3O7a17ZJDpUma5LFh364QSejJUkmYkRCY0xFJdwX3Ef2+GxvJkljwlx1SFt8iNMs63GODoRyABKGA621zmYyBUodNWXKoqcTRMMhpm/2MfIgg1JXV5IxHXSQjjkLy6ZhU2m0p1gKrR88kHoOHQl5twwSsmw6GIBsa8QiS8xPDNE99SuwOwsTRSsvazkGWUHZLadMtSKTSyUpuo8/RopUSkdWlKI5GxZsFhNb6RQZdDQthcFipXr3fQW7+UBJ80N9+iqhSsL/dJjQmhnV68p/r66T1UEq6kmQLfKB/WmQrUVlNaIoFkhvVljWCqQSaLqMvab8aS7JZsxm+bAQ+HgVlvV4GkkNFEe5R3TLXwdH2tbQsiYUW1Hvj6ygyDkyycr2uGR1oOhrLC2sky705FlslkPLquv6vn1ycmXKmo6wHLfgPHcBT62BWPiEw7LCE0dLJMlWWbHvto5GbNUWclp8X8BzorrpxExYjIZDbwcMBunQc/2R0JMkNPZPKLY6qDak2DzwOyFGZLMZs7HketPiaDkL9qIJMGa7lapsPm22NwmN3ODmfBRNt6L6Gtj2d3Px8hCrShsdu0/J5YNAKVpJJ8IJSEfXt1K1FTNZ0nvd6AWPuqzHOzoQ0lOksyZsrlpkSUIqyl96OcQaTtp7VZxWM2bFRm1DK10+TyESNONq9dLotKHIMmarE7dDJrtvaAdgCy0DlhonNllCKv6SitIw4lLdVK2FOHSOdCqGllWoa8jPhTDaVJoc+095q8eL11OL1Swjm224XdWYMhpaoUEoX9YKGRy0dHiwKQo2jxfVniW6snYweDuUzlp4jWzNBdobHShmhdrWds5Vp4gu5x9F1FbCxOV62rxOFLOCQ/Xi2j8WBZKDFo+V5GKowkckdaKLEbKOC6hWgE3iGlS76vPDh3ItasMhe8FgL5TVjK2hgwuOLGvLUU42wHYMfY3FBxqK2kt7gwPFbEZxuGhVnSUBh4TTd4d33unCfXwkcogKy3qsTP7JF8clurwubIoZs9WBx6tSu+96P+46KCfOcuQjLOfaaa1VMCsOGtsvUJONEl6r6CCjaxopyUqtPV9pSFYPXvdeSL1HZzOugd2Nx2ZGlmVK663yypU1w+pyDJP7JeoNG4RPOulPeOLoa2FWU9U0tqvUWhUcHh8tdVmiS0VBbgV1k9FsxWqzocgGkEwoNhtWq3mvN8eoYLXZsCoyBiTM1TZsVmthqoNGNJbC5GzD67Ll60hPB6oDNqPrjzHY1lgNb4CzlY4GG4rVifdSPfJmmKKpqXlWlcF33mH4Un4e6K7MKkvRLDVqOx6HgrVWpaOxmtRqmPwlv8120WVjgPxQODl0veh6szaiOrZYDj1c3Wxr7MLX6sFV68Bmq8WldtHhqiK1vooGINXS2uOl0eXEYXNQ29BKf3s9pvifoaxlPCPL8j+WvgjAZx+j/R9fwfnCy/zw1RbOn3eQCa/w4afAp38g+puPsdQ18r2XX+H7nm/z3FefIf2bX7KaSKNj4MvffJ4Xm17i/CvnedH9ryH+n5ic/Dkf7zvJdbR//hTrd87zyquv0HL+e1i194j84TOoJA2liTd++FWik5P8+k/F6RZ89jEf/vEr1Ktefvi95/mm5Z9Z+/hv+fozHxD6RZLPAOlv6/Go3+Ol8y2cf+HbfPX/XGdu3M+vM5/l0yhbVoAv8Q2PB+vHP+c///bgJfWlb3j4+7/5Pe+na2h7rY1zNX/J74JjTP78vxYFQsenoX/8Gz7IVFN//jxt33+Bb375E6L3Rpn5dYbPAD5J8MEfzHxbfZm2F93YcitE/vSv+btPf8l7v9T4DJCf7+C155LM3vk5WqF4xb5c18Tzyse8v/QbdnfnnzQM3zzPC9/4I8u/SPDhh5/w9b9v41JLI88/Z+I3sSyO6k/55Xu/RPsMTN/w4Pmb3/O+VkNbxw859z/+Jcngf2A8/F8qLqutfZL/5d9fouWlb2F55q/5O3cLLS0ttDgyhFc+5FM+40+/jfJ7vs53XzzPhZYm3A6FT3+3yi8Sf8rvDwCe4avfUfn2V/7Ib94rnLulvvQNPB4rH4f/M7/9pPgNHa1cWe3P84L9jywvrRf2l0zdC89jSf4T4d/nr0794yjRPxhxuFVeeeX7vFDvoCrzv7MSSbL3dUdfB5Kzi//XnX9HW8sLPFf1DFXfeCG/L1QryfciaJ99xp9iv+XjL/9PNLW8TMuL38GqrxMYn2Llvxb2uFzHC89/mQ//6eckCpXG3zq/R/1fFa6DTJwPP/0GTd5LvPI9D89/4xl+Ef0jdvt/5zehCH8oOle2kx/y6df/npb/6yucf/EFlH8uXK/GBgbfvcWPWlp4/u9MPGP5Ji+2tNDS4kGOvcdvdu84jy7r7hap/47t3LcxrfmZiXxcdDyFp9JnaT5YT/Hst1/k5VfO852v6/wuMM7kyl79V65uAgnn1f/AP756jm9/1QR//VW+9fzznHObSb6XP0dlz7/nP/y7Fp6v+woGvsTf1T/P8+ecmD54j2j6M9IfrJOSn+M7L52n5aUmXF//S5LhacYXfv9QgcDD2v5wnfhf1eD5fgstnm8ip1aZHJvnwHNA8nO8cO4bGJLLvBct7rLR0T74Hdnq73L+5Vd4sf5f8cmvZxid+TU7zdaeDPE/fJkXfP+WS+fd/O0/zzEZTPDJZ0ac3n/DdzML3HkvyWFVYznPWJ6j3u3m3Ase/uFcPc/9q89IrkwzOvdbPvkMeObLPPd8Iy88/zz/8A/P8+2aL/PJB/eZuP0eH5YGu4+0rKXbHfQXX/va1/6l9MWng0Stb5Je8wKv3wg/xoj+5BR1lNGGNfremH8EY99HkWkcnqQpPsDr/gRgxTs+jCPaTff8Yd1ngvCEMDcyfEdFG3qdiaO6B4QvEFE3PXbmRobvNLE51Pl4n5p7Qh09NPbEs2DQlpnyLz/RQdDjI+No8FBrlTFKRhRXGx5riuhqoQ9SlklF/fhDoqIRnlQSRtlKQ1sT1lSERVFBnw2ibnrsjLLOxtwUC+Iag6e7R+jp8Xh6hGRcvn7anAoWE2RTSaL3J5haOdljhILwZ+PwMfOmG1NqjYXbI4QS4swVBOHRE4GQIAiCIAhn1lM8NCYIgiAIgvD5iEBIEARBEIQzSwRCgiAIgiCcWSIQEgRBEAThzBKBkHCqzOoogXFvftHMz8vYwGBghnZH6RtPhlMtqyAIgvBncXQgJHsYDEzSXvEqsQ/DSut4gNF9q3p+DlItvpkAg57ya1AJgLWV8cA4O+vY2ryTBIP51ceDwQCzM6P0tDorXrju1Olp1qNRDizBcwY5fDMEBj2Pb3FIQThFktKAb3iS2UCQwMwoXY2248/lkrqpEpLVs/sdwcAsk4PtNCjFyyzI1Lb2Mz4TIBjM56NHLbcO4KMg49jJRyGfzpNWskYbjV2jzAQCBGYnGfY1sFtUyYqna5SZ2VkmR7vwWCtbasLcOExg0oejss2RFBfenmEmZ2YJBAPMTg7j8+w/rrW+maI2Jf9vxldbtEUFHkFZSx0dCD2FZLeKkyihU11B7ovKiFN1UxULsVT840Zbq9y+1sm1awPcXtBQmrroPUltdJr0GKGxaVbE76wJwtNLcuDt/xHOXJjbfZ0MLaSwX+qlw3lUKHRE3XQcyYG3twNnLsxI92WudE+waqjnRz1t7NzLmz1d9DaZSfj7uHL5CgMLKarbevFVuDDnadnNx9wAnX0TRA31dPWqJ+hZNuLs6OWSPcXCUDd9t8Pkan9Ev9eBBJibOlClEH2XLzOwKKF6PeVvZiUHapOV5OL9I9d6KyXZnNiJszg3wdDACPei4Oz4MVcb9oeWufjPGLh+nevXr3P9+jWG7ufXx6zMIyjrIQ4GQmaV0WCQ4N0OagwWzr29E8kN4ikqn6S4aB8cL0TfM4x2NWIrPp/kWlr7x5kpROcz44O05pd0B2y0TwYJBm/x0rMGqtvu7PZC9LiKIrpj0yhlQ220k1paYH3nQFq9jAeGaSzaM7W+GQL9DUWr4yq42geZnA3ke0EmR+lv3N8NVrasKKijAca9Ljy+4XxagVnGvfkxHUUdJTDZQ3vXKJOzs8zOjNNz4I7o+DRAwurxMTy5E30P0u5S9q3ya3a2MzxZ+FyPSmt/gNke5+ErAZvdqE49vyho8et6llRSI5lMsB6eIhQzUF3jyJ9cUi1dswH6G/ZSlFz9BGa7cO77EhlX+zAzgSCB2XH6VcfJyiq56N+9gzhqaEzGoXYV7Y9Rehpth5f1KIWhN1+DC+9g4W51dhLfTgW97/ybYbRH5eDpd0xZK9pfElbPXjkCs5MMdzUUFvSVcHbNEgwGedNdhaGmg5/u3lXtnRcN/QFme1pRe8aZmQ0QmBnF59pfHZQ9h8tea8flUxCOJtV5qLdsEpoOsZ7UiIWnCW2YcDbWH94bc1TddBzZSrUly8bSIjEtQ1qLsvAgDs8qKEYACcWuYNBWCEWSpDNpEuEQ0ZQJpfpxnsUK9Z4aiM4ztZJAS0bx31slU+3BU+noi1xPo9PERmiacEwjuR5iemkTS72Hup16ZacN1Asrke4wGg/tiZNdKvXSyToRtlfG6LvpZ2klSiy2zop/igcfmXA480HKrqxGPJEgkUiQSCRJpiuMtHg0ZT3MwUAoHaK7uZnmy1Ns5FI8uN5Mc3Mzzc03CO+clUYnvsEO7OklRrqv0DngJ2ZpodfnKnyxhNN7lSZ5nem+K1zuHGBsYZ29XZxg+vVmmpuv8bOPcmzOdRa+42VuRnZKVS6N/YwuFXfVGqFDl6E/muxpx1cPq7e7uXKlm4GpRTaLj1PZsu4wYHG34dq6z8CVi7za+RYLsb3L2GCpozo1xbWLF7kyEsXSdtgd0dFpSLUd9HfUkl0coftKN7dXod7XQ5utcDYojVztqkeKjnGtsw+/Vou7rvisKCbhUJuwJhcJHRn+SxitbuqtkMvpJ/p1asOzTurlZUa6Oxm4l8R8oRefq/KyokcYam6m+dWfsJEr+RjkG+XWfvovKGj3R+i+0snAVJiMxYKpdNOyTDhbmpCWhrhy8Qe8PuAnuqUDCo29vTTJMfx9V+gcmENTLtB7tWFf5V1ZWY+hNOHzOtgKjdB9uZPut/wsJ/eu7OjYRZqbmxlY3iK3McWrzfnr8bWJ/XdVpro6zOEbvHbxIgPL4Opo2wu2yp7DFVxrx+ZTEI6m2KyYtpLEd6vmDLF4CoNiP6QXpJK66RDpOPGPJKpdzvxq85KCu95KdiNaWMxUJ7mRJKs4aSjcAciOehxyirVopd1Op0CyYlNgMxbfq1OTMTZzFqrth4aFByl2FEOKeNGcAS2eZMuUTzu9eI9FSWX47l2GVZ3QVJi0pOBUuxi8qnLwa6w0NjnYWg4RLV349UQkTAbIZFL72guD4xJ3C8Naoz0qjgPff4xTL+vhDgZCFTCfU3Fml5mYCBPT0miJCHNzUahzk2/bTZgtElltjbVkmkw6SSwSInxged3jnCQNhXNqHdmHOJCyWYatJNF1jXRaI7m+wny4sD5XRWUtoi0yMb9OeltnO50gEi0KyrJrLC4k2Aa2EyFCMRPOhrqDPRiHpiFR53Fi2lhgYimGltZYn5/mgfYsrnN2AJQGD/bMKv65KMm0xvq8n8hHpYkXyC7UeoloKHwwsLSc4+1gkGDwXX566xJ1po9YDq1WfmcGkIsTmgiT0DQSK1MsxCTq3M6D0fmhZa2AVId6TkFbGGNiJYaWTpNcDzPtP8Ed5A6Dga3VKaajGtu6TiYZJZrQQWnAbc+y7PcTSabREitMLKyB4xyu4our0rIeRVaQDWkSazG0TBotESUcilDhntiVi4eZW88AOomVCFqhwqWic7iCa+2U8imcPXKVCbJbZM0N9M/MMqxayaYzYJIxlVaAx9VNx0rgH5ogZvXxzrtBgu/eoU2OMDKyl05m5TZvLeRwv/1TgsEgd/udpKaGHu+ioyaZKkOObDaHzTvO7KQPpynDdhaMcmWttiQbMZEhnbGiDs8y09+AObtFFhNVMqAnWLrZzWsXL/Jat59Nu5f+/lZs2gJDQ/Osl1SSRqeK2xIjVPE45OHMnhbqTRssLu21n+m1Je5N3GZkYICRe1Gy9jb6e9WKe5JPu6xHeYhASKLaqmB4tolbRROg3n3TTZVBpsoEkCH6YA2cvUyO9tPV3orHuX8Yp7zK05BqVRqVOKHFxIl6LgCSkTDxqibenBymv6udVo8jf0cBFZZ1R45MPH7kxZvbSqPtZm6blJYBixXL/q2OSMOCYpHIaFpRQ58ikcpSZVaQkVAUC7lUsqg3SyOePrQ7BWujiiO1TCh6yN7aWuUn165xfeAnPNjY5FdTQ0yvnyy6zGWSbO5+ZBtNS4G5usKyVsBiQ5EyxDdOoRnOZUkmDqYjKRYsOY1kUfegnkyQMphRiq7iysp6jPgykU0rbbfGGe7x4VUbsFVWH+6jF9+FZXPoGDBIVHgOV3CtnVI+hTNM3yaT2WJrK1v6zq5j66ZjKXg6vDjSC4xcv8a1gdss6256ext3G11jbRu+RhPrUwNcu3adt+Y2qe7ox1db8W3LKdLRMxm2Mlmyh1fTx9jp6c+S3doik9k+pN2TUFyt9Az6OMcyEzduMh89bN1JM27Vib4aIlJh0HAYY207/W0KaxNjLBVVp1okxFJknVgiwfqKn5HpVbL2EwwDnmpZj/YQgVBebuMnu930e/+6CRVatvTKTV7vHGA6HCMr19HWO8rwCSfdVpaGjFt1QiRE+eHNQ8Ko5BI3rnQyNLfKpm7B2fYmt/r3T7gqV9bd7XLH7HpDybdL+4czdxybxmkwOlHdVcQWlw5fAFbPoiWTJGIrTE8sU3XpKvse6jvxRXu0R17WiuTQs48wH+X2lx7D332ZztshVtMSVk8Hb4/27O91OgXlzuGy19pjyqfwxZPZyoKpClMmykT3G9xcSWMyy5DNsO/SK1c3HUOqVblQlyE8FSKaSJKMRfDfWyZb00R+yqcZd4ubqtgCU+FYfg7k0gT3YzIutb7yHtzPK5thK2fAZDKRDN3gjT4/MV3GaILtTGWRiJ7JkEXGLKcJ33yD7okoGVMVJrJsZQCjg9bBflqtCeaHhri3WUP7+Ayzs5MMt7v2tW2SQ6XJmmQxFDtR4FDM6PDy5lUn2r0BxqLHl2F7M0kaE+aqQ9riQ5xmWY9zdCCUA5AwHGitdTaTKVDqqClTFj2dIBoOMX2zj5EHGZS6upKM6aCDdMxZWDYNm0qjPcVSaP3ggdRz6EjIu2WQkGXTwQBkWyMWWWJ+YojuqV+B3VmYFFt5WcsxyDuT9gBkqhWZXCpJav9mR0iRSunIilI0P8WCzWJiK50ig46mpTBYrFTvvq9gNx8oaX6YRF8lVEn4nw4TWjOjel3579V1sjpI+a4GAGSLfGB/GmRrUVmNKIoF0psVlrUCqQSaLmOvKX+aS7IZs1k+LAQ+lq6l2DIoWKv3PilZbVhyabSiO55jy1rh/oJttPUVlvxj3Ojzs2GqwWkvyXEhoDr42XIqP4fLXmuV5FMQSmiJJNkqK/bdGyojtmoLOS2+L+A5Ud1UyiQfOj8wh4TBBGDCYjQcemdiMEgPcV09JD1JQoNqh32vTrI6qDak2DzwOyFGZLMZs7HkGtPiaDkL9qIJMGa7lapsPm22NwmN3ODmfBRNt6L6Gtj2d3Px8hCrShsdu0/J5YNAKVpJJ8LhjI5W3ux1kZm7wdhK+USkaitmsqS3SlvrR13W4x0dCOkp0lkTNlctsiQhFeUvvRxiDSftvSpOqxmzYqO2oZUun6fQDWnG1eql0WlDkWXMViduh0x239AOwBZaBiw1TmyyhFT8JRWlYcSluqlaC3HoHOlUDC2rUNdgRQKMNpUmx/5T3urx4vXUYjXLyGYbblc1poyGVhjuKF/WChkctHR4sCkKNo8X1Z4lurJ2MHg7lM5aeI1szQXaGx0oZoXa1nbOVaeILucnzWorYeJyPW1eJ4pZwaF6cZWOz0gOWjxWkouhCh+R1IkuRsg6LqBaATaJa1Dtqs8PH8q1qA2H7AWDvVBWM7aGDi44sqwtRznZANsx9DUWH2goai/tDQ4UsxnF4aJVdZY8hSLh9N3hnXe6cJ+050JbYSVuwu314rKaUWwN+C7UQWx5fxfysWWtYH85GmlvbcBhNSPLCrVuF9WkSO6NowKQ0tJQ7cSpGJEk6USBXflzuIJrrcJ8CkIpfS3MaqqaxnaVWquCw+OjpS5LdKlo7uGJ66b99HiUeK6axg6VWqsZxeqktc3Ns1sxonEAjWgshcnZhtdly9eRng5UB2xG108+t/ChaayGN8DZSkeDDcXqxHupHnkzTNHU1DyryuA77zB8KT8PdFdmlaVolhq1HY9DwVqr0tFYTWo1zJoOsM12UWVrAHJ6Lt/7rRfVHNZGVMcWy6GHq5slWys/7m1Civq5v2nEarNhs9mw7twZSrW09nhpdDlx2BzUNrTS316PKf5nKGsZz8iy/I+lLwLw2cdo/8dXcL7wMj98tYXz5x1kwit8+Cnw6R+I/uZjLHWNfO/lV/i+59s899VnSP/ml6wm0ugY+PI3n+fFppc4/8p5XnT/a4j/JyYnf87H+05yHe2fP8X6nfO88uortJz/HlbtPSJ/+AwqSUNp4o0ffpXo5CS//lNxugWffcyHf/wK9aqXH37veb5p+WfWPv5bvv7MB4R+keQzQPrbejzq93jpfAvnX/g2X/0/15kb9/PrzGf5NMqWFeBLfMPjwfrxz/nPvz14SX3pGx7+/m9+z/vpGtpea+NczV/yu+AYkz//r0WB0PFp6B//hg8y1dSfP0/b91/gm1/+hOi9UWZ+neEzgE8SfPAHM99WX6btRTe23AqRP/1r/u7TX/LeLzU+A+TnO3jtuSSzd36OVihesS/XNfG88jHvL/2G3d35Jw3DN8/zwjf+yPIvEnz44Sd8/e/buNTSyPPPmfhNLIuj+lN++d4v0T4D0zc8eP7m97yv1dDW8UPO/Y9/STL4HxgP/5eKy2prn+R/+feXaHnpW1ie+Wv+zt1CS0sLLY4M4ZUP+ZTP+NNvo/yer/PdF89zoaUJt0Ph09+t8ovEn/L7A4Bn+Op3VL79lT/ym/cK524xyYr7xefY/sV7RA/czHzC73/zB7703N9z/uVXeNFt5y/j/4k7k0v8oZBO+bLqaGX2F6ZqvvMP3+N7L56n5byHb/7NH1n1/wcWYp8UlQO2tY/5K/vzvNT2Kq+0nOfvLTHei6aBZ7B+R6VOj/DeLz/Of+av7DzfZOePy0us/6mSc7iCa63CfArCAZ+l+WA9xbPffpGXXznPd76u87vAOJMre/VfubqprO0PWf+9jvXbjbzY8n1edNfx5U+izI3N8Iu0DnxG+oN1UvJzfOel87S81ITr639JMjzN+MLvHyoQeFjbH64T/6saPN9vocXzTeTUKpNj84Wn24rIz/HCuW9gSC4XrvUdOtoHvyNb/d183VT/r/jk1zOMzvyanWZrT4b4H77MC75/y6Xzbv72n+eYDCb45DMjTu+/4buZBe68l6S0aqzEV777Q9q++T/wpepv8/zzz+/+O/f1DOGfJ/j0mS/z3PONvPD88/zDPzzPt2u+zCcf3Gfi9nt8WBrsPtKylm530F987Wtf+5fSF58OErW+SXrNC7x+I/wYI/qTU9RRRhvW6Htj/sRj3w9PpnF4kqb4AK/7E4AV7/gwjmg33fOHdZ8JgiD8OYi66bEzNzJ8p4nNoc7H+9TcE+roobEnngWDtsyUf/mJDoIeHxlHg4daq4xRMqK42vBYU0RXC32Qskwq6scfEhWNIAhPEFE3PXZGWWdjbooFEQTB090j9PR4PD1CMi5fP21OBYsJsqkk0fsTTK2c7DFCQRAEQThLRCAkCIIgCMKZ9RQPjQmCIAiCIHw+IhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiHkZx0zQbod1X+66THsbVPEhj0lPzytSAIgvDndnQgJHsYDEzSXvEqsQ/DSut4gNF9q3p+DlItvpkAg57ya1AJgLWV8cA4B9axfeoYcfXMMtvjyi+eKDXQX7TSejAwy/igD4+1snVnHoVMbI3ousbR624LwheXpDTgG55kNhAkMDNKV6Pt+IVOH0XdJDlo7BpkdHKWQDDIbJfzREvVnB4ZR2s/4zMBgoFZJgfbcZ60yTLaaOwaZSYQIDA7ybCvAWWnMJIVT9coM7OzTI524bFWVkpz4zCBSR+OyjYHZGpbexgcnWQ2GCQ42c7BcOHJLGupowOhp5DsVnESJfSwK8idKUacqpuqWIilR/fjRo+Hcg61bovlUGTfT+XH567T2XmNa0NTRKmlo9+H89ja99FJR6YZ+xwrPAvCU0ty4O3/Ec5cmNt9nQwtpLBf6qXjyIvxEdVNkoSsa0RCc0Q+Kn3z8TF7uuhtMpOYG6Czb4KooZ6uXpXKYz4jzo5eLtlTLAx103c7TK72R/R7HUiAuakDVQrRd/kyA4sSqtdTfhV2yYHaZCW5eP8Ea71JmAzbJCMhQr/aKn0TntSyHuJgIGRWGQ0GCd7toMZg4dzbO3fWg3iK+vUlxUX74DizgSDBwAyjXY3Yis9ruZbW/nFmAvk78pnxQVrzS7oDNtongwSDt3jpWQPVbXcK3xGgp3go4tg0StlQG+2klhZY3zmQVi/jgWEai/ZMrW+GQH9D0Z2Agqt9kMnZAMFggNnJUfob98e1ZcuKgjoaYNzrwuMbzqcVmGXc68i/q44SmOyhvWuUydlZZmfG6TlwR3R8GiBh9fgYnpwlEAwwOzlIu0vZd0djdrYzPFn4XI9Ka3+A2Z4j7nrMblSnzmoosvfL3FYv44FR2hsL3xOYZbJfxVacwL5jMsNoj8qRh+QQsmeQwEzJXYfRRc/sLP0uI0gu+gOTDPePMhOYZbS9kdbBGQKBGQYbD7t8JGrVRizxJUIlC/nltjQ0LUkyFmF+LkKqqgbXzmrpFZ0bINmb6BnP7/OZYR+u3VuRwvvOLmYD/TQ6W+kvbDc72cNOp6TVO77XM3XU0JjRhsdXOAcDs8yM9tNae+iWgvDUkeo81Fs2CU2HWE9qxMLThDZMOBvrD78eDqubTsP2OvMT04TCa2yWruv12CjUe2ogOs/USgItGcV/b5VMtQfPwe6Uw8n1NDpNbISmCcc0kushppc2sdR7qNupnnbaQL2wEukOo/HQnjjZpVIvnbQTIU3EP4E/FGYtfVhf95NZ1sMcDITSIbqbm2m+PMVGLsWD6800NzfT3HyD8M5ZaXTiG+zAnl5ipPsKnQN+YpYWen2FoQkknN6rNMnrTPdd4XLnAGML6+zt4gTTrzfT3HyNn32UY3Ous/AdL3MzslOqcmnsZ3SpuKvWCB26DP3RZE87vnpYvd3NlSvdDEwtslkcEZct6w4DFncbrq37DFy5yKudb7EQ27uMDZY6qlNTXLt4kSsjUSxth90RHZ2GVNtBf0ct2cURuq90c3sV6n09tO1EKUojV7vqkaJjXOvsw6/V4q4rPiuKSTjUJqzJRUKl4b+hGmddnInOi7z8+hSb1gt0NO0MXSo09vbSJMfw912hc2AOTblA79WGwyu0Q2SiEeKmWtw7AQlgrHNRwwbLazu1kwyxKYb8cSznWqiODDGwoFHd5D7Y9Wp2o7ogGjpmqRXJjNNdi0yWrF7x7Q5goMbtJD0/QGfnCMs5J76eCwfvZgx2VNXC6lgnF39wmb6pCDuLsif9b9Dc3Mz1BylypZ+Dwj79MV5HlsXbfVzp7GNsUcNkMZVuKAhPJcVmxbSVJL5bNWeIxVMYFPvBa+m4uumLQLJiU2AzFt/rHU7G2MxZqLZXWIsqdhRDinh8r8bT4km2TPm004v3WJRUhu/eZVjVCU2FSUsKTrWLwasqB7/GSmOTg63lENHTDBCfyLIe7mAgVAHzORVndpmJiTAxLY2WiDA3F4U6d2HowYTZIpHV1lhLpsmkk8QiIcIHltc9zknSUDin1pF9iAMpm2XYShJd10inNZLrK8yH97oWype1iLbIxPw66W2d7XSCSLQoKMuusbiQYBvYToQIxUw4G+oO9tYcmoZEnceJaWOBiaUYWlpjfX6aB9qzuM7ZAVAaPNgzq/jnoiTTGuvz/qO7f2UXar1ENBQ+JLBMEb0fzjfkmSgrMR3FZs3nU2nAbc+y7PcTSabREitMLKyB4xyuCk84MlEicRO1bnuh7BJ1rhrYiLAbB5EivpEguRYjldOIrSVJrCXZks1Y9u0wCVuTil1bIrTbDbin5kc/zffEvPsOveeeJbsWYilWutXxUqv38EeTpLV15v3LpJ6tx30gGsuxPjfBSjKDrm+jrUcoioGPZ2ukqSZL+PYYS+tJ0mmN2Iqf6fDJAnpBeFLJVSbIbpE1N9A/M8uwaiWbzoBJxlRaAR5bN30BmGSqDDmy2Rw27zizkz6cpgzbWTDKlVWikmzERIZ0xoo6PMtMfwPm7BZZTFTJgJ5g6WY3r128yGvdfjbtXvr7W7FpCwwNzbNeUjcZnSpuS4zQqY5DPpllPcpDBEIS1VYFw7NN3CqakPrum26qDDJVJoAM0Qdr4OxlcrSfrvZWPM79wzjlVZ6GVKvSqMQJLSZOPAcjGQkTr2rizclh+rvaafU4MO9+SSVl3ZEjE48fefHmttK7vQSwTUrLgMWKZf9WR6RhQbFIZDStqNcjRSKVpcqsICOhKBZyqWRRb5ZGPH14H4S1UcWRWiYUPWRv5TKkd79EJ6fnwFAIWRQLlpxGsqjLTE8mSBnMKEXz3SVXD4Hd/TWDr3bvPcgQjcQx1bqxS4BURz4OWts3vye3Deg5dCCn5/8Phv3H3+hEdZtYCz3gsLAh/rMBrl27zsi9X7EZX2TsdvjQ7Y6WQ9u7jQUtTjono+yPxiCXZCN+yL6sgFytIGfjxJIP93lBeGro22QyW2xtHTaMknds3fSFoqNnMmxlsmQPr6aPsdPTnyW7tUUms31IuyehuFrpGfRxjmUmbtxkPnrYupNm3KoTfTVEpMKg4eSelLIe7SECobzcxk94tXln2GznXzehQiueXrnJ650DTIdjZOU62npHGT7hIwCVpSHjVp0QCVF+ePOQMCq5xI0rnQzNrbKpW3C2vcmt/v0TrsqVdXe73DG73lDy7dL+4cwdx6ZxGoxOVHcVscWlIxeAPfG5WkKPTtPd2UlnZyednTeYK+mFKR4ek+oaqGGDyF53UIl8MHQYRVWp21omFDn8szltk2QyQXRpjDnNSVeH85gx40POjYodnUdBOOsyW1kwVWHKRJnofoObK2lMZhmyGbLFF04FddNTL5thK2fAZDKRDN3gjT4/MV3GaILtTGWRiJ7JkEXGLKcJ33yD7okoGVMVJrJsZQCjg9bBflqtCeaHhri3WUP7+Ayzs5MMt7v2tW2SQ6XJmmTxUTzI8YSV9ThHB0I5AAnDgdZaZzOZAqWOmjJth55OEA2HmL7Zx8iDDEpdXUnGdNBBOrp1Kp+GTaXRnmIptH7wQOo5dCTk3TJIyLLpYACyrRGLLDE/MUT31K/A7ixMAK68rOUYZAVlt5wy1YpMLpUktX+zI6RIpXRkRSmai2PBZjGxlU6RQUfTUhgsVqp331ewmw+UND/Up68SeojwX9dSbBkUrNV7O0Oy2rDk0mjFXS16Bk3Tdv9lSg9MJspy3EStuw5nQw1srJx4SBOplgtuC/GlECVzpA+hsx4Kk3G20rITR1d0bhhQ7EVdXYodsyGDliot0MPLbGpkTHYcD/nYpyA86bREkmyVlb1LyYit2kJOi+8LeD5P3fTU0JMkNKh27EwNAKwOqg0pNovmweQZkc1mzMaSukGLo+Us2IsmwJjtVqqy+bTZ3iQ0coOb81E03Yrqa2Db383Fy0OsKm10NOw0RDIutR4pWkknwkN4osp6vKMDIT1FOmvC5qpFliSkovyll0Os4aS9V8VpNWNWbNQ2tNLl85A/1824Wr00Om0osozZ6sTtkMnuG9oB2ELLgKXGiU2WkIq/pKI0jLhUN1VrIQ6dI52KoWUV6hryc1yMNpUmx/6mzurx4vXUYjXLyGYbblc1poyGVmiYy5e1QgYHLR0ebIqCzeNFtWeJrqwdDN4OpbMWXiNbc4H2RgeKWaG2tZ1z1Smiy/nuFm0lTFyup83rRDErOFQvrv3jbiA5aPFYSS6GTvCIZBFthZW4CbfXi8tqRrE14LtQB7HlE3arZoguxzDVemmrgbWK98Mes0fFqUdZWK7wi7VlFmNVuNsKE7srODcALPWXaK1VMCu1tHrdWDZXWS4feVUuscTihgmPz0djrRWzWcHmVGltONHZJQhPLH0tzGqqmsZ2lVqrgsPjo6UuS3Rpda8u/7x1U0UkzFYrNls1igSSyYzVZsO6d4f6GGishjfA2UpHgw3F6sR7qR55M0zR1NQ8q8rgO+8wfCk/D3RXZpWlaJYatR2PQ8Faq9LRWE1qNcyaDrDNdtGNpQHyUxzIoetFbay1EdWxxXIoum9awkkYzVasNhuKbADJhGKzYbWaCz3vT1BZyzgmEFonNBdBd/Zy9913effdosfnMxHGbkwQpYH24Xd4Z/TH+FQ7bGrkf01AJ2tQcHt/zOjdu7wz7MWqLTA2FS1p8LaJzM2xZlR58+67vPvubNHj8xWkoZxDrcse+P2YXfo6c/4IuIeZnZnkTRXW1rb2Df1ksyasjT7evHOXu3d+jFoVY2pkbq+XoWxZK5P7KMqq7qZ39A5vtlnZXBhh6gTdINvrEwxNxahSe7nzzihX6w1EfzKEf6fW0Ja4PbYKri7u3Bmm3bbOciy392ghhd9ZkqKEwg8b/muERsYIZxx0DL/DnTfbsGoLjEyEj35i6wjb0VViJgsW1ojkz+jKSTbUJjta+CSVZobI4hq5OhXVVtm5ATk2lqMo3mHu3OnFbYgyMTZfebe9sYHBwlypt89ZMNR0cLcwb6p951cR0FgaeQt/Qqbp6jDv3Bmlt9UBmaPnUQjCU0WP4R/6CesGD7237tB/wcLmvf313+evmyrhoKX/Fm+/3cu5ajDUXeLtt9/mls9d8VOvpyEdHmNkMY3t0pvcGfbhzK0yNhKqvF5hm+jUCPfiFi703+FWbyOm9Z8w5D9seCvJ/ekoiu8dZu8O48nO4Y9sczq/1SRR1zHMrbff5mq9Barq+dHbb3Nr2Lv7aPuTUdby/uJrX/vav5S++HSQqPVN0mte4PUbJ2+IHydFHWW0YY2+N07QiH5uMo3DkzTFB3jdnwCseMeHcUS76Z4/rPvs6WF09fNOR46pKzep8DwXBOGJ9cWpm54a5kaG7zSxOdTJdOV3k19YR/cIPfEsGLRlpvzH/H7MmSLjaPBQa5UxSkYUVxsea4roaqFvS5ZJRf34Q097RSNhkTYJTc2LIEgQvgi+MHXT08Mo62zMTbEggiB4unuEnh6Pp0dIxuXrp82pYDFBNpUken+CqZWTPUYoCIIgCGeJCIQEQRAEQTiznuKhMUEQBEEQhM9HBEKCIAiCIJxZIhASBEEQBOHMEoGQIAiCIAhn1hkJhCSsnh7GZwP5hUBH1QNrkEjOLmYDPThLfoxSbhzeXWw1ONnO7u/gPXUkGvoDzOxfAfUL6nTLamufJDDoeaw/uiYIgiA8HkcHQrKHwcAk7bbSN06TldbxAKPqKS0nINXimwkw6CkJc4xO2rw1ZO73cfnVV3m1b/HACu96KkY0EmOr5FnzzFIfzc3NXJ7a+NyLkT5eRlw9s8z2uI5ZaPTJYG4cJjDpwyEBmFFHd1auDxIMBpgZ76fdpXyuZVE/j0xsjei6hvitZ0F4OJLSgG94ktlAkMDMKF2NtuPrJWsr44FxDqyxfSQbjf3DjM/kb3YDs5MM+zxYS77E7PQyODlLIBhgdryfVsef4/ZGxtHan89rYJbJwXacpXfm5RhtNHaNMhMIFMragLJTQUpWPF2jzMzOMjnahafCdQz318MVUDx0DY8zMxsgGAwwOzlMl+ooOa5PZllLHR0IPYVkt4qTKKHSFeSqLMhsEY8lyWxvs60f8ss6yTATE0sVLOD5lFDOodZtHb38yJNCcqA2WUku3t+3XEZ2bYprnZ1cuz7CXEym/mo/3oqv0NOVjkwz9ihWZxaEs0By4O3/Ec5cmNt9nQwtpLBf6qXDeVQo9HDLP+halCX/CAPXrzNyL0qutoP+Dudew6yo9Ha5MUUn6OscYCphpqm3i9L75kfN7Omit8lMYm6Azr4JooZ6unpVKo75MOLs6OWSPcXCUDd9t8Pkan9Ev9eBBJibOlClEH2XLzOwKKF6PQdGQA44oh4+lpQjtbGEf2KIgetDTIWz2Nt66d1di+sJLeshDgZCZpXRYJDg3Q5qDBbOvb1zZ1601hggKS7aB8eZDQQJBmYY7WrEVnxey7W09o8zEwgSDMwyMz5Ia35Jd8BG+2SQYPAWLz1roLrtzu7d/95aY+XSKGVDbbSTWlpgfedAWr2MB4ME77RRbXiWl24VylI0NCbV+pjZ6X04ZGisIkYrHt8wk7OFqHfYR8NuyEphaK6L4cKdSGB2kuGuht1FW40N/czO9uDaVzQH7ZMBRtXdnB6bxn4StWojlvgSodLIzuigtX+S2UCA2clBvM7ig2rF0zXI+MwsgWCQwMw4/V7n/hOrgmNidrbSPz6zl0Zr7ZHDSrJLpV46JHjN5lewTybWWfEvsJa14HAWSmv1Mh4YprEoY7W+GQL9Dft7jY4rK4W1wAIz+BpceAcLd6uzk/gKFbTVO77XM3XU0JjRhsc3uHvsZ0b7aa09dEtBOJOkOg/1lk1C0yHWkxqx8DShDRPOxvrDrymzG9WpsxqKnGDVgARhf4hwZJ1YIsH6ip+5SIoqe+1uHWlr9FCdWWXKHyWpJYhMzROlBk/94bXoo6FQ76mB6DxTKwm0ZBT/vVUy1R48lY6+yPU0Ok1shKYJxzSS6yGmlzax1Ht21/javWvTCyuR7jAaD+2JO7IePk5yhfn5MJFojFgiRiQ0RXjTVLTa/JNZ1sMcDITSIbqbm2m+PMVGLsWD6800NzfT3HyD8M5ZaXTiG+zAnl5ipPsKnQN+YpYWen07wzASTu9VmuR1pvuucLlzgLGF9aLhqATTrzfT3HyNn32UY3Ous/AdL3MzslOqcmnsZ3SpuKvWCBUvQ5/080ZzM82dc2zmPuJnnYWydId209HXJ3ituZkfjKw+5NCHGU/vm7QpceZGurnS/Rb3NRsd/d69LkalCZ/XwVZohO7LnXS/5Wc5uRd2b0fDbFCDu+gOSXK4ccpJllcLOS2Txj5mN6oLoqHS5UcMVH3LTXVsgr7OPqbWTHi6iu+IZMz6OqGJt+i+coW+iRUkVxdXd4cuyx8TydFOf1c9ufAEfTtpuK/Sdehtl5XGJgdbyyGOXn/WiOJ0YTeBnjuivIcqV9YdJpwtTUhLQ1y5+ANeH/ATLYyPJv1v0NzczPUHqSOGRRUae3+M15Fl8XYfVzr7GFvUMFlMpRsKwpml2KyYtpLEd6vmDLF4CoNiP6RnQMKhNmFNLhKquGviIKPi4lytTHYzRv5rZezVFnKbsb1f99fjxDZBcVgf37C7ZMWmwGYsvtfDnIyxmbNQbT80LDxIsaMYUsTje7W7Fk+yZcqnnV68x6KkMnz3LsOqTmgqTFpScKpdDF5VOfg1ldTD5UiYa5twKTm0+Ga+bE9kWQ93MBCqgPmcijO7zMREmJiWRktEmJuLQp2bfFtuwmyRyGprrCXTZNJJYpEQ4dhJ9vJJ0lA4p9aR/VwH8iHZmlDtGvdv+4nENNJagpWpBdZMTtw7kZCsIBvSJNZiaJk0WiJKOBQpXKDA9hrhtRwO984dkoTDU4sp9oDITpRRLo1dErYmFbu2RGi3a6zI5hL+UAwtnSTinyOSteOpL0QH+jrzEyFW1hNo6TTJ9RAL61msDluhoih3TIy4VDemyBRjS+skC2n4l7ewu0t6lgCjU8VtiRE6pP/bVN/Lu8EgweBPuXO1Hjm1SmjpYGmPdVxZdxgMbK1OMR3V2NZ1Msko0cQh++0wtkaaarKEb4+xtJ4kndaIrfiZDp8wn4LwBSZXmSC7RdbcQP/MLMOqlWw6AyYZU2kEIrtQ6yWiofCRN73HcbRPEgwG+emdq9Sm53hrYmdqgIxshOx2BpPTx+TsOF5Hjmw2h8Ek89huXUwyVYb899q848xO+nCaMmxnwShX1mpLshETGdIZK+rwLDP9DZizW2QxUSUDeoKlm928dvEir3X72bR76e9vxaYtMDQ0z3pJN9tx9XB5SmFO57u882M3+uIQby0VjtwTWNajPEQgJFFtVTA828St3QmtQd59002VQabKBJAh+mANnL1MjvbT1d6Kx3nSya6VpyHVqjQqcUKLicc+j8NYbcVisHPpnaIJvu9e5VumKnaPdXyZyKaVtlvjDPf48KoN2PadBzqxcJSM3YVLBqQ63HUG1pajez06ZdMoMDpR3SbWQg8OCZJyZDWN1M6fepLNNMjKTo+PTK3aw+hkfmgsGAzyprsKg2QoVBTljomCXTFQ5f5xIYjJ/7v10rMYZEtJN7gZt+pEXw0ROeRkza7d4/q1awyM/Iy1zQ0WRiYO3e5o5cq6s1mWZOLgnqqEXK0gZ+PEjuqZEwRhj75NJrPF1tbRfe/WRhVHaplQ9OGuqfjCENeuXeetnyyiWVvoaCmdvAu5bJbMVoZM9uG+43To6JkMW5ks2cO7m4+xM/6TJbu1RSazfUi7J6G4WukZ9HGOZSZu3GQ+eti6k8fXw+WlWB67xrXrA9ye20A+5+NS6RSEJ6asR3uIQCgvt/ETXm3eGTbb+ddNqBAMpldu8nrnANPhGFm5jrbeUYYrfwQAKk5Dxq06IRLiJMObpymXXWXkB6X7opmhlcKh0GP4uy/TeTvEalrC6ung7dGefNBToMfCRFN26l1mjM4G6nJrrBR3b1WQBoCiqtRtLRN6iKXZ5QYfVy9YiPv7uFwoz8CDFDnDXqhT/pjk2Jy7cmBfNL/u3zcRXXKoNFmTLB41CTmbJplMEovOMxHSaexqO+ZphiPfqEAO/c9aIQrCF1tmKwumKkyZKBPdb3BzJY3JLEM2w75Lz+hEdVcRW1x66MWp9YxGMpmfIzTij6N4LhRGKTJktsFklNFjfvreuEEoacJkMpDLZh5yWsRDyGbYyhkwmUwkQzd4o89PTJcxmmA7U1kkomcyZJExy2nCN9+geyJKxlSFiSxbGfJzIwf7abUmmB8a4t5mDe3jM8zOTjLc7trXM1+2Hi5LJ6MlSSZiREJjTEUl3Bfc+XlZT1hZj3N0IJQDkDAUTz4CQGczmQKljpoy7Y+eThANh5i+2cfIgwxKXV1JxnTQQSoN2YuUTcOm0mhPsRRaf8gDWZn87jAcaHK3N5NkTHYcZR/b20ZbX2HJP8aNPj8bphqc9uLPJAlHNaxuFdVdQ259mbUDBSqThlTLBbeF+FLoiKffDJgUZa9nRrJSbYa0lu8RsdZYkeJh5qIa2zqAjKLI++afcewx0YhrYHE4Dp8EuUvGpdYjRSsLXjOR+0QMHtp2JvjoOXQk5N2MSciyqSSfx5f1NGQ2tQqPvSCcXVoiSbbKin23M9aIrdpCTovvC3jM51Sc+iqhh+uaOJzBgKkwShHfTGGoduzNS5LsOKpBiyUfaduxj54koVE0oRiwOqg2pNgsmgeTZ0Q2mzEbS+oXLY6Ws2AvmgBjtlupyubTZnuT0MgNbs5H0XQrqq+BbX83Fy8Psaq00dGw0+CerB6umCTny/ZElfV4RwdCeop01oTNVYssSUhF+Usvh1jDSXuvitNqxqzYqG1opcvnKczQN+Nq9dLotKHIMmarE7dDJqtpJZN3t9AyYKlxYpMlpOIvqSiN/JyUqrUQxXOkH4XteJJUlQN3gxWznB9vBiCxSGjDhMfno7HWitlsxeH04O1p33sKzNFIe2sDDqsZWVaodbuoJkVS23/5aeFlkso5XqrLEl0uCewqSMPsUXHqURaWS0+yItWNdDQ6UMxWnN42XIb47oRsbTMNioM6GUDC7PKi2ovDi3LHZJtIaJms4xK9Xhc2xYxiq8Wl+uhSix4TsDaiOrZYDkUrfLQ/QTisYVVbqJWAVAwtq1DXkJ/kaLSpNDlKw7Xjy3oqEkss7jv2CjanSmvD43wKRRCebPpamNVUNY3tKrVWBYfHR0tdlujS6l5dLjlo8VhJLoYqf3y7mKOVnnaVBmctDpuD2gYvvd462IyyXrjkE+Ewm3I9HV4nVsWGq6MVJxuEVx9x47GPxmp4A5ytdDTYUKxOvJfqkTfDhEvvXq0qg++8w/Al+/7XM6ssRbPUqO14HArWWpWOxmpSq+HCzfM220UVqwHI6bl877de1MaeuB7ez9bYha/Vg6vWgc1Wi0vtosNVRWp9tTAt4wkqaxl/8bWvfe1fSl/coTT46GpzUV1lADaYurz35JikuPB6L+B0PEsVWbZSm8TCC0wtxdhGptbro81pR7GYMOS22Fxbwj8RonSus2RtpKurhbpnTRjI8avbFwtPjlWQhqIyOuohNvA6/tIdW0xRGR1tYK37Deb3nfMK6ugd2qqLX8vb/Fkn3fs2NuJo7cXXVIPFAFvLA7w2ESu8ZcVzyYvqtGMxQTalEY+FmZsKk9QBq4eujkYcioUqE2Q/irO6MI0/UjqOKeMZnKTDEuZ6yVBS2TQkG+133sQe7qY7dNiFLdHQP0tbbpFlUz3naiyQ2mB5agz/zowyScHj6+JCnQVyWTLxVSJ6PRcsi7zet0SmkmNSeHzee8FNjVKFpG+R0uJEQ9PMRzOAEWfXHXymOTqHVg55PNaMOvoOqjbC5bHo3v6RG+i/04Hpfid9S2nMLh+9XhcKGbT4Kmu4aTLMcXFoBb2SskL+8fm7baSHXmPnUO5776c/oqbkZdjiwcBrTO9sb7ThudSWP/YSbKViLPsnmK90lp4gnAGS0kCHrwWX3QJbm6yFpphYSuw2wLKnnzsXsky8PsZDTQ+yeujyNmKvtiCbDJBNkVwLM+cPESu6FM1OLz6vG7tFQv8oxoM/y7Uq42j10X7OwbOSTiq+in9immjpPZq1lfFbL2Eqbmt2GG00dnSgOqupYot4ZI6JqRVK7q3zmzpa6fWdo9qUI7U2x9jECpperh4uz+xqp0Otw67ImAyQ3dKIRxaYmouS3qu4n4Cylm510LGB0JNNotY3Sa95gddvhB/qQD55rLSOD+OM9vHG/MlGyY2uft7pyDF15SYPMT3o8TE3Mnynic2hTqYf6tZPEIQvFive8WEc0e6Sm0/hkRH18D5HD4098SwYtGWm/KW/lfM0kjDKZmyNbbgtScLhkwVBIGGRNglNzT/ZQRBglHU25qZYEBefIAgAskwq6sd/aE+28CiIeni/p7hH6AtEctEze5Vv6R/xq7mbjIVLh8wEQRAEQXgURCAkCIIgCMKZ9RQPjQmCIAiCIHw+IhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiCIAjCmSUCIUEQBEEQziwRCAmCIAiCcGaJQEgQBEEQhDNLBEKCIAiCIJxZIhASBEEQBOHMOnKJDUf7DG+eq8r/kVvj9sUhIsULYMkeBic7qDHk//xo8Rpv+IsXC1VoHb3DS9X5v3Lxe7zet7RvgVTJ1cPs1W+RT2KL5bdeY2K9aIPTSKNsPkVZRVnzfx5M4xTyeRpplM2nKKsoa/7Pg2mUz2d55dM4jbKWVTaNU8hnBcqmUTafj+e4ls1nBcqmUTafT0dZjwyEJFnBYtr5K8uWlmH/wuZGzEpV4Yshl02RzhSXTsJotlC1u8EWWrpkaXRJRtn7ErIpjX1JnEoa5fIpyirKmncwjdPI52mkUS6foqyirHkH06ggn2VVkMYplLW8cmmcRj4rUDaNcvl8TMe1bD4rUDaNcvl8Osp6ZCAkCIIgCILwRSfmCAmCIAiCcGaJQEgQBEEQhDNLBEKCIAiCIJxZIhASBEEQBOHMEoGQIAiCIAhnlgiEBEEQBEE4s0QgJAiCIAjCmSUCIUEQBEEQziwRCAmCIAiCcGaJQEgQBEEQhDPryV1iw9rK+K2XeBaATeY6uwlppRsJgiAIgiA8vAOBUEN/kB/VFb9SbJO5K92E0qWvH05y9TDboTN2eYzoCRZA20dpZXy0jpVuEQgJgiAITzsZR6uPdreDZ006qfgq/olpohW2qwAYbTR2dKA6FUx6hmT0PhNTK2g6IFnx+HxcqLOgp9YITUwQTpZvgM2Nw9xp0hjqnCCmA5KDRt8F3PZqFIsJfXWEy2NR9i2HqjTQ4WvBabUgZTeJhqaYWkoULar6ZJa11IGhsejUNa5fv87169e5vZyC7Br3Cn9fvzbGcqb0E4IgCIIgVMLs6aK3yUxiboDOvgmihnq6elWspRseyYizo5dL9hQLQ9303Q6Tq/0R/V4HEmBu6kCVQvRdvszAooTq9WAuTaKU5EBtspJcvJ8PggAkCVnXiITmiHxUsj35z3j7f4QzF+Z2XydDCynsl3rpcBp3N3kiy3qIA4HQdjpJIpEgkUiQ3MoCWbRk/u9Ecm9pe6NDpWd0hkAwSGBmnP7WWuRCGsaGQYLBIO9e/RYGUz297wYJBoMEx1v3doDSQHv/KJOzAYLBALPjg7S7FKSd9wVBEAThC0Wh3lMD0XmmVhJoySj+e6tkqj14bKXbHkGup9FpYiM0TTimkVwPMb20iaXeQ91OA7oTzOiAoeizRiN7Ycoe2aVSL0UJLRd11WyvMz8xTSi8xuZeF88uqc5DvWWT0HSI9aRGLDxNaMOEs7G+EAs8mWU9zIFAqCJyA1d7L6Bocwx0XqHPH0Nu6qVXVQDYXrlBc3MzP7j9K3LZVUZ+0ExzczPNb8yT3EnDaMKwGcb/Vh9XrnQzspSlztdPW6U7SBAEQRCeJpIVmwKbsfjeEFMyxmbOQrV9pyuhDMWOYkgRj+8Nz2jxJFumfNrpxXssSirDd+8yrOqEpsKkJQWn2sXgVZWDX2OlscnB1nKI6CEBz1EUmxXTVpL47pSVDLF4CoNiz3d4PJFlPdxDBUKy042DNRYmVkhoaZIRP/7lDPaGhsq7vBJLTMyHiSaSpNMasfACqykZe83DdGwJgiAIwhPOJFNlyJHN5rB5x5md9OE0ZdjOglGurNWWZCMmMqQzVtThWWb6GzBnt8hiokoG9ARLN7t57eJFXuv2s2n30t/fik1bYGhonvWS6S1Gp4rbEiO0tNtNURG5ygTZLbLmBvpnZhlWrWTTGTDJmKQns6xHeahAyGy1QEpjb06SzmYyBRYFpdKxLaONxq7hwtBYkGDwFi89a8BoNJVuKQiCIAhfIDp6JsNWJks2V/peOTvjP1myW1tkMtv7JjDnSSiuVnoGfZxjmYkbN5mPaodsZ8atOtFXQ0QqDBoO0LfJZLbY2sqWvlPwpJT1aA8VCB2nsi+XcHb00mZNcX/gdX7Q3Exzcyc/2zzxXhIEQRCEp0M2w1bOgMlkIhm6wRt9fmK6jNEE25nKIhE9kyGLjFlOE775Bt0TUTKmKkxk2coARgetg/20WhPMDw1xb7OG9vEZZmcnGW537ZtMLDlUmqxJFkOxCtvuPZmtLJiqMGWiTHS/wc2VNCazDNkMWf3JK+txHioQShd6f6y7vT8S1YVeolTx3tTzM88PdhIp2KwmtJUFVpKZ/AGQFBRL8UynHdvoSBgPJiIIgiAITw89SUKDaod9r120Oqg2pNgsmgeTZ0Q2mzGXNn5aHC1nwV40AcZst1KVzafN9iahkRvcnI+i6VZUXwPb/m4uXh5iVWmjo2FnCrGMS61HioYoniNdKS2RJFtlxZ6fGgwYsVVbyGnx/FzgJ6qsx3uoQCgTXSZGHRd8DdgUM1anF69bZnNlZW8yNKCn0qQM1TidZoyShLRbxhRaWsdS6ygMpcnUei9Qd9ioWGqTZNaC0+NEMcvIpTtKEARBEJ4KGqvhDXC20tFgQ7E68V6qR94ME06UbGpVGXznHYYv2fe/nlllKZqlRm3H41Cw1qp0NFaTWg2zpgNss1006dkA5PQckEPXi9pPayOqY4vlULTod3+KSZitVmy2ahQJJJMZq82GVckHF/pamNVUNY3tKrVWBYfHR0tdlujSKvkw5wkqaxnPyLL8j6Uv7vjScx5e+LtP+MV7v+Tjz4re+DTJ/x7/jG985zyvvPJ9nq/7Kz7++TRjgd/v36GZJH+Sv8nzL/2QV185z/n/WSL6n39LBp3k71KY61u41KbS6HGh/OHnfCA5sHz8c/7zb4uixc8+Jv7xl/nW916m7fsv8aLzLwtpCIIgCMLTZfvDdeJ/VYPn+y20eL6JnFplcmyeWGk0Ij/HC+e+gSG5zHv7foFQR/vgd2Srv8v5l1/hxfp/xSe/nmF05tdkittpADLE//BlXvD9Wy6dd/O3/zzHZDDBJ58ZcXr/Dd/NLHDnvSSfln4MgOe4NPr/4P/2f6nn76rgma/U8fzzz3Pu6xnCP0/w6WdpPlhP8ey3X+TlV87zna/r/C4wzuTKf90dZnsyylq63UEHfllaEARBEIQvMHMjw3ea2BzqZHr3FxTProcaGhMEQRAE4elklHU25qZYEEEQiB4hQRAEQRDOMtEjJAiCIAjCmSUCIUEQBEEQzqwDQ2N//dd/XfynIAiCIAjCF5boERIEQRAE4cw6skfov/23/1b8siAIgiAIwhfO/x8Yy4IpRJzwdAAAAABJRU5ErkJggg==" alt="Description of image">

### Solution
- I redesigned `process_wait()` to:
  * Maintain a **parent-child** hierarchy using a child process list in `struct thread`.
  * Enable the parent to wait until the child completes execution.
  * Use `semaphore`s for synchronization, ensuring the parent is notified when the child exits.

### Implementation Details
- **`thread.h`**
  - **`struct thread`**
    - Added `list` and `list_elem` for child process management.
    - Added `semaphore`s to synchronize.
    - Added `int` for storing `exit_status`.
    - They are initialized in `init_thread()` just like `donors`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
        struct thread
        {
          /* Owned by thread.c. */
          tid_t tid;                          /* Thread identifier. */
          enum thread_status status;          /* Thread state. */
          char name[16];                      /* Name (for debugging purposes). */
          uint8_t *stack;                     /* Saved stack pointer. */
          int priority;                       /* Priority. */
          struct list_elem allelem;           /* List element for all threads list. */

          /* Shared between thread.c and synch.c. */
          struct list_elem elem;              /* List element. */

          int64_t tick_wakeup;                /* Tick till wake up */
          struct lock *lock_to_wait;          /* Address of the lock to wait */
          int original_priority;              /* Original Priority value */
          struct list donors;                 /* Doners for priority inversion */
          struct list_elem donelem;           /* List element for donors list */


        #ifdef USERPROG
          /* Owned by userprog/process.c. */
          uint32_t *pagedir;                  /* Page directory. */

          struct list children;               /* List of child processes */
          struct list_elem childelem;         /* List element for child processes */
          struct semaphore sema_parent;       /* Semaphore for waiting parent process*/
          struct semaphore sema_child;        /* Semaphore for waiting child process*/
          int exit_status;                    /* Exit status for exit() */
        #endif

          /* Owned by thread.c. */
          unsigned magic;                     /* Detects stack overflow. */
        };
      ```
      </details>
- **`thread.c`**
  - **`init_thread()`**
    - Sets up new data members.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      init_thread (struct thread *t, const char *name, int priority)
      {
        // other codes
        list_init(&t->donors);

        #ifdef USERPROG
        list_init(&t->children);
        sema_init(&t->sema_parent, 0);
        sema_init(&t->sema_child, 0);
        t->exit_status = -1;
        #endif

        old_level = intr_disable ();
        list_push_back (&all_list, &t->allelem);
        intr_set_level (old_level);
      }
      ```
      </details>
  - **`thread_create()`**
    - Adds the child process to the parent's list.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      tid_t
      thread_create (const char *name, int priority,
                    thread_func *function, void *aux) 
      {
        struct thread *t;
        // other codes
        sf->ebp = 0;

        #ifdef USERPROG
        /* push child process to parent */
        list_push_back(&thread_current()->children, &t->childelem);
        #endif

        // other codes
      }
      ```
      </details>
  - **`thread_exit()`**
    - Signals the parent via `sema_up()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_exit (void) 
      {
        ASSERT (!intr_context ());

      #ifdef USERPROG
        sema_up(&thread_current()->sema_child);
        process_exit ();
        sema_down(&thread_current()->sema_parent);
      #endif
        /* Remove thread from all threads list, set our status to dying,
          and schedule another process.  That process will destroy us
          when it calls thread_schedule_tail(). */
        intr_disable ();
        list_remove (&thread_current()->allelem);
        thread_current ()->status = THREAD_DYING;
        schedule ();
        NOT_REACHED ();
      }
      ```
      </details>
- **`process.c`**
  - **`process_wait()`**
    - Waits until the given process exits if it is the child process of the current process.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int
      process_wait (tid_t child_tid) 
      {
        struct thread *child_thread = NULL, *current_thread = thread_current();
        for(struct list_elem *current_element = list_begin(&current_thread->children), *end_element = list_end(&current_thread->children); current_element != end_element; current_element = list_next(current_element)) {
          struct thread *thread_current_element = list_entry(current_element, struct thread, childelem);
          if (thread_current_element->tid == child_tid) {
            child_thread = thread_current_element;
            list_remove(current_element);
            break;
          }
        }
        if(child_thread == NULL)
          return -1;

        sema_down(&child_thread->sema_child);
        int exit_status = child_thread->exit_status; 
        sema_up(&child_thread->sema_parent);

        return exit_status;
      }
      ```
      </details>

### Conclusion
- The parent process now waits reliably for its child,
  * though the child's ability to load executables required further work (addressed in **Part 2**).



## Part 2: Argument Passing

### Objective
- Modify `start_process()` to parse and pass arguments to child processes for use in loaded executables.

### Current Problem
- The original `start_process()` assumed `file_name` contained only the executable name, ignoring additional arguments.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  static void
  start_process (void *file_name_)
  {
    char *file_name = file_name_;
    struct intr_frame if_;
    bool success;

    /* Initialize interrupt frame and load executable. */
    memset (&if_, 0, sizeof if_);
    if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
    if_.cs = SEL_UCSEG;
    if_.eflags = FLAG_IF | FLAG_MBS;
    success = load (file_name, &if_.eip, &if_.esp);

    /* If load failed, quit. */
    palloc_free_page (file_name);
    if (!success) 
      thread_exit ();

    /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
      threads/intr-stubs.S).  Because intr_exit takes all of its
      arguments on the stack in the form of a `struct intr_frame',
      we just point the stack pointer (%esp) to our stack frame
      and jump to it. */
    asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
    NOT_REACHED ();
  }
  ```
  </details>

### Solution
- I reimplemented `start_process()` to:
  * Parse arguments from the input string.
  * Push arguments to the user stack following the **80x86 Calling Convention**
    + which is to push `argv` from right to left, followed by their starting addresses, `argc`, and return address.
  * It's crucial to align arguments with `4-byte padding` and include a fake return address (`0`) to signal program termination.

### Implementation Details
- **`syscall.c`**
  - **`collapse_spaces()`**
    - Collapses multiple spaces to a single space for consistent parsing.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void collapse_spaces(char *str) {
        char *source = str, *destination = str;
        bool in_space = false;

        while (*source) {
          if (*source == ' ') {
            if (in_space == false) {
              *destination++ = ' ';
              in_space = true;
            }
          } else {
            *destination++ = *source;
            in_space = false;
          }
          source++;
        }

        *destination = '\0';
      }
      ```
      </details>
  - **`start_process()`**
    - Parses arguments and pushes them to the user stack.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      start_process (void *file_name_)
      {
        /* Parse the first argument */
        collapse_spaces(file_name_);
        const int MAX_COUNT_ARGUMENT = 32;
        const int MAX_LENGTH_ARGUMENT = 64;
        char argv[MAX_COUNT_ARGUMENT][MAX_LENGTH_ARGUMENT];
        int argc = 0;
        char *saveptr, *token = strtok_r(file_name_, " ", &saveptr);
        
        while (token != NULL && argc < MAX_COUNT_ARGUMENT) {
          strlcpy(argv[argc], token, MAX_LENGTH_ARGUMENT);
          
          ++argc;
          token = strtok_r(NULL, " ", &saveptr);
        }
        char *file_name = argv[0];

        /* Initialize interrupt frame and load executable. */
        struct intr_frame if_;
        bool success;
        struct thread *current_thread = thread_current();


        memset (&if_, 0, sizeof if_);
        if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
        if_.cs = SEL_UCSEG;
        if_.eflags = FLAG_IF | FLAG_MBS;
        success = load (file_name, &if_.eip, &if_.esp);


        /* If load failed, quit. 
          it should be file_name_ not file_name, because file_name_ points to the allocated page */
        palloc_free_page (file_name_);    
        if (!success) 
          thread_exit ();

        /* Push arguments to interrupt frame with the 80x86 calling convention. 
          The registers in interrupt frame will be restored to user stack of the loaded executable  */
        int sum_bits = 0;
        int64_t arguments_starting_points[MAX_COUNT_ARGUMENT];
        for(int length, current_count = 0; current_count < argc; ++current_count) {
          length = strlen(argv[current_count]) + 1;
          if_.esp -= length;                 // decrement is needed because stack should be moved downward
          memcpy(if_.esp, argv[current_count], length);
          arguments_starting_points[current_count] = if_.esp;
          sum_bits += length;
        }  

        uint8_t padding_value = (4 - sum_bits % 4) % 4;
        if(padding_value != 0) {
          if_.esp -= padding_value;
          memset(if_.esp, 0, padding_value);      // use memset instead of memcpy
        }
        
        if_.esp -= sizeof(char*);
        memset(if_.esp, 0, sizeof(char*));
        for(int current_count = argc - 1; current_count > -1; --current_count) {
          if_.esp -= sizeof(char*);
          memcpy(if_.esp, &arguments_starting_points[current_count], sizeof(char*));        // store the actual physical memory address, not the address of local variable
        }

        int64_t start_point = if_.esp;
        if_.esp -= sizeof(char**);
        memcpy(if_.esp, &start_point, sizeof(char**));
        if_.esp -= sizeof(int);
        memcpy(if_.esp, &argc, sizeof(int));
        
        if_.esp -= sizeof(char*);
        memset(if_.esp, 0, sizeof(char*));
        
        /* Start the user process by simulating a return from an
          interrupt, implemented by intr_exit (in
          threads/intr-stubs.S).  Because intr_exit takes all of its
          arguments on the stack in the form of a `struct intr_frame',
          we just point the stack pointer (%esp) to our stack frame
          and jump to it. */

        asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
        NOT_REACHED ();
      }
      ```
      </details>

### Conclusion
- Child processes now receive arguments correctly,
  * but system call support was needed to fully utilize them (addressed in **Part 4**).



## Part 3: Synchronization Issues
- Before implementing system calls,
  * it's crucial to implement synchronization mechanisms to prevent **race conditions** during file operations.

### Objective
- The goal is to avoid any race conditions when system calls are called
  * by implementing `filesys_lock` and calling `file_deny_write()`.

### Current Problem
- Current PintOS lacked a `filesys_lock` and did not call `file_deny_write()` after loading executables, risking concurrent file modifications.
  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  bool
  load (const char *file_name, void (**eip) (void), void **esp) 
  {
    struct thread *t = thread_current ();
    // other codes

  done:
    /* We arrive here whether the load is successful or not. */
    file_close (file);
    return success;
  }
  ```
  </details>

### Solution
- I introduced:
  * A `filesys_lock` to synchronize file system operations.
  * Modified `load()` to call `file_deny_write()` upon completion, delaying `file_close()` until `process_exit()`.
  * Enhanced `process_execute()` to verify the existence of `file_name`.

### Implementation Details
- **`syscall.h`**
  - **`filesys_lock`**
    - Added filesys_lock, initialized in `syscall_init()`.
    - It is initialized in `syscall_init()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #ifndef USERPROG_SYSCALL_H
      #define USERPROG_SYSCALL_H

      void syscall_init (void);
      struct lock filesys_lock;

      #endif /* userprog/syscall.h */
      ```
      </details>
- **`syscall.c`**
  - **`syscall_init()`**
    - Initializes `filesys_lock`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      syscall_init (void) 
      {
        intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
        lock_init(&filesys_lock);
      }
      ```
      </details>
- **`process.c`**
  - **`load()`**
    - Calls `file_deny_write()`.
    - Sets `current_running_file` to keep track of the loaded `file` object.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      load (const char *file_name, void (**eip) (void), void **esp) 
      {
        struct thread *t = thread_current ();
        // other codes

      done:
        /* We arrive here whether the load is successful or not. */
        file_deny_write(file);      // call this instead of file_close()
        t->current_running_file = file;
        return success;
      }
      ```
      </details>
  - **`process_exit()`**
    - Closes the `file` object, implicitly allowing writes.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      process_exit (void)
      {
        struct thread *cur = thread_current ();
        uint32_t *pd;

        file_close(cur->current_running_file);

        /* Destroy the current process's page directory and switch back
          to the kernel-only page directory. */
        pd = cur->pagedir;
        if (pd != NULL) 
          {
            /* Correct ordering here is crucial.  We must set
              cur->pagedir to NULL before switching page directories,
              so that a timer interrupt can't switch back to the
              process page directory.  We must activate the base page
              directory before destroying the process's page
              directory, or our active page directory will be one
              that's been freed (and cleared). */
            cur->pagedir = NULL;
            pagedir_activate (NULL);
            pagedir_destroy (pd);
          }
      }
      ```
      </details>
  - **`process_execute()`**
    - Validates `file_name` existence.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      tid_t
      process_execute (const char *file_name) 
      {
        char *fn_copy;
        tid_t tid;

        /* Make a copy of FILE_NAME.
          Otherwise there's a race between the caller and load(). */
        fn_copy = palloc_get_page (0);
        if (fn_copy == NULL)
          return TID_ERROR;
        strlcpy (fn_copy, file_name, PGSIZE);

        /* Create a new thread to execute FILE_NAME. */
        const unsigned MAX_PROCESS_NAME_COUNT = 32;
        char new_process_name[MAX_PROCESS_NAME_COUNT];
        strlcpy(new_process_name, file_name, MAX_PROCESS_NAME_COUNT);
        char *saveptr, *token = strtok_r(new_process_name, " ", &saveptr);       // parse the first argument only to make it as name of the thread

        lock_acquire(&filesys_lock);
        struct file* current_file = filesys_open (token);
        if (current_file == NULL) {
          lock_release(&filesys_lock);
          palloc_free_page (fn_copy); 
          return TID_ERROR;
        }
        lock_release(&filesys_lock);


        tid = thread_create (token, PRI_DEFAULT, start_process, fn_copy);
        if (tid == TID_ERROR)
          palloc_free_page (fn_copy); 
          
        return tid;
      }
      ```
      </details>

### Conclusion
- These changes ensured thread-safe file operations, paving the way for system call implementation.



## Part 4: System Call Implementation.

### Objective
- The goal is to enhance `syscall_handler()` to support a range of system calls for process and file management.

### Current Problem
- The original `syscall_handler()` was rudimentary, printing text and exiting without handling system calls.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
    static void
    syscall_handler (struct intr_frame *f UNUSED) 
    {
    printf ("system call!\n");
    thread_exit ();
    }
  ```
  </details>

### Solution
- I reimplemented `syscall_handler()` to:
  * Validate and parse arguments from the stack (`f->esp`).
    + `esp[0]` is the system number,  
      - which is used to identify which system call handler to call.  
    + `esp[1]` is the file descriptor.  
    + `esp[2]` is the buffer.  
    + `esp[3]` is the size of the buffer.  
  * Dispatch to appropriate system call handlers based on the system call number.
  * Store return values in the `eax` register.
- Morever, I modified `process_exit()` to ensure all open files are closed.

### Implementation Details
- **`thread.h`**
  - Defined `FD_TABLE_MAX_SLOT` as `32`.
  - **`struct thread`**
    - Added `fd_table` which is an array of pointers to `file` objects.
      * It contains all `file` object's address information based on the `fd` value which is an integer.
    - Added `next_fd` which represents the currently available `fd` value.
    - They are initialized in `init_thread()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct thread
        {
          /* Owned by thread.c. */
          tid_t tid;                          /* Thread identifier. */
          enum thread_status status;          /* Thread state. */
          char name[16];                      /* Name (for debugging purposes). */
          uint8_t *stack;                     /* Saved stack pointer. */
          int priority;                       /* Priority. */
          struct list_elem allelem;           /* List element for all threads list. */

          /* Shared between thread.c and synch.c. */
          struct list_elem elem;              /* List element. */

          int64_t tick_wakeup;                /* Tick till wake up */
          struct lock *lock_to_wait;          /* Address of the lock to wait */
          int original_priority;              /* Original Priority value */
          struct list donors;                 /* Doners for priority inversion */
          struct list_elem donelem;           /* List element for donors list */


      #ifdef USERPROG
          /* Owned by userprog/process.c. */
          uint32_t *pagedir;                  /* Page directory. */

          struct list children;               /* List of child processes */
          struct list_elem childelem;         /* List element for child processes */
          struct semaphore sema_parent;       /* Semaphore for waiting parent process*/
          struct semaphore sema_child;        /* Semaphore for waiting child process*/
          int exit_status;                    /* Exit status for exit() */

          struct file* fd_table[FD_TABLE_MAX_SLOT];              /* File Descriptor table*/
          int next_fd;                                           /* Empty fd value for next file object */

          struct file *current_running_file;                     /* File object which is currently loaded */
      #endif

          /* Owned by thread.c. */
          unsigned magic;                     /* Detects stack overflow. */
        };
      ```
      </details>
- **`thread.c`**
  - **`init_thread()`**
    - Initializes file descriptor data.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      init_thread (struct thread *t, const char *name, int priority)
      {
        // other codes
        list_init(&t->donors);

        #ifdef USERPROG
        list_init(&t->children);
        sema_init(&t->sema_parent, 0);
        sema_init(&t->sema_child, 0);
        t->exit_status = -1;
        t->next_fd = 3;
        for(unsigned current_index = 0; current_index < FD_TABLE_MAX_SLOT; ++current_index)
          t->fd_table[current_index] = NULL;
        t->current_running_file = NULL;
        #endif

        old_level = intr_disable ();
        list_push_back (&all_list, &t->allelem);
        intr_set_level (old_level);
      }
      ```
- **`syscall.c`**
  - **`is_valid_address()`**
    - Verifies stack addresses using `is_user_vaddr()`.
    - `is_user_vaddr()` is a function that checks whether the current address is inside the user stack.  
      * in order to use this, `#include "threads/vaddr.h"` is needed.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
        bool is_valid_address(void *ptr) {
            if(ptr != NULL && is_user_vaddr(ptr) == true) {
                if(pagedir_get_page(thread_current()->pagedir, ptr) != NULL)
                    return true;
                else {
                    int* trigger_to_handler = ptr;
                    *trigger_to_handler = 0;
                    if(pagedir_get_page(thread_current()->pagedir, ptr) != NULL)
                        return true;
                }
            }
            return false;
        }
      ```
      </details>
  - **`syscall_handler()`**
    - Validates arguments, calls handlers, and stores results.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

        ```c
        static void syscall_handler(struct intr_frame* f) {
            int *current_esp = f->esp;

            if(is_valid_address(current_esp) == false)
                return; 

            switch (current_esp[0])
            {
                case SYS_HALT: halt(); break;
                case SYS_EXIT: exit(current_esp[1]); break;
                case SYS_EXEC: f->eax = exec(current_esp[1]); break;
                case SYS_WAIT: f->eax = wait(current_esp[1]); break;
                case SYS_CREATE: f->eax = create(current_esp[1], current_esp[2]); break;
                case SYS_REMOVE: f->eax = remove(current_esp[1]); break;
                case SYS_OPEN: f->eax = open(current_esp[1]); break;
                case SYS_FILESIZE: f->eax = filesize(current_esp[1]); break;
                case SYS_READ: f->eax = read(current_esp[1], current_esp[2], current_esp[3]); break;
                case SYS_WRITE: f->eax = write(current_esp[1], current_esp[2], current_esp[3]); break;
                case SYS_SEEK: seek(current_esp[1], current_esp[2]); break;
                case SYS_TELL: f->eax = tell(current_esp[1]); break;
                case SYS_CLOSE: close(current_esp[1]); break;
            }
        }
        ```
      </details>
- **System Call Handlers**
  - **`halt()`**
    - Shuts down PintOS.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void halt(void) {
        shutdown_power_off();
      }
      ```
      </details>
  - **`exit()`**
    - Terminates the user program with the `exit_status`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void exit(int status) {
        if(status < 0)
          status = -1;
        struct thread *current_thread = thread_current();
        printf("%s: exit(%d)\n", current_thread->name, status);
        current_thread->exit_status = status;

        thread_exit();
      }
      ```
      </details>
  - **`exec()`**
    - Runs a new executable with arguments.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int exec(const char *cmd_line) {
        if(is_valid_address(cmd_line) == false) 
          return -1;

        const unsigned MAX_PROCESS_NAME_COUNT = 32;
        char new_process_name[MAX_PROCESS_NAME_COUNT];
        strlcpy(new_process_name, cmd_line, MAX_PROCESS_NAME_COUNT);
        char *saveptr, *token = strtok_r(new_process_name, " ", &saveptr);  
        lock_acquire(&filesys_lock);
        struct file *temp_file = file_open(token);
        if(temp_file == NULL) {
          lock_release(&filesys_lock);
          return -1;
        }
        file_close(temp_file);
        lock_release(&filesys_lock);

        return process_execute(cmd_line);
      }
      ```
      </details>
  - **`wait()`**
    - Waits for a child process and retrieves its `exit_status`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int wait(int pid) {
        return process_wait(pid);
      }
      ```
      </details>
  - **`create()`**
    - Creates a file of specified size.
    - Returns `true` if successful; `false` otherwise.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool create(const char *file, unsigned initial_size) {
        if(is_valid_address(file) == false)
          exit(-1);

        lock_acquire(&filesys_lock);
        int return_value = filesys_create(file, initial_size);
        lock_release(&filesys_lock);

        return return_value;
      }
      ```
      </details>
  - **`remove()`**
    - Deletes a file.
    - Returns `true` if successful; `false` otherwise.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool remove(const char *file) {
        lock_acquire(&filesys_lock);
        int return_value = filesys_remove(file);
        lock_release(&filesys_lock);
        
        return return_value;
      }
      ```
      </details>
  - **`open()`**
    - Opens a file.
    - Returns a `current_fd` if successful; `-1` otherwise.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int open(const char *file) {
        if(is_valid_address(file) == false)
          exit(-1);

        lock_acquire(&filesys_lock);

        struct thread *current_thread = thread_current();
        if(current_thread->next_fd == -1) {
          lock_release(&filesys_lock);
          exit(-1);
        }

        struct file *current_file = filesys_open(file);
        if(current_file == NULL) {
          lock_release(&filesys_lock);
          return -1;
        }

        current_thread->fd_table[current_thread->next_fd] = current_file;
        int current_fd = current_thread->next_fd;

        while(true) {
          if(current_thread->fd_table[current_thread->next_fd] == NULL)
            break;
          ++current_thread->next_fd;
          if(current_thread->next_fd == FD_TABLE_MAX_SLOT) {
            current_thread->next_fd = -1;
            break;
          }
        }
        lock_release(&filesys_lock);

        return current_fd;
      }
      ```
      </details>
  - **`filesize()`**
    - Returns the size, in bytes, of the file open as `fd`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int filesize(int fd) {
        if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || thread_current()->fd_table[fd] == NULL)
          exit(-1);

        lock_acquire(&filesys_lock);
        int return_value = file_length(thread_current()->fd_table[fd]);
        lock_release(&filesys_lock);

        return return_value;
      }
      ```
      </details>
  - **`read()`**
    - Reads size bytes from the file open as `fd` into buffer.
    - Returns the number of bytes actually read (0 at end of file), or -1 if the file could not be read (due to a condition other than end of file). 
    - `fd 0` reads from the keyboard using `input_getc()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int read(int fd, void *buffer, unsigned size) {
        if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || thread_current()->fd_table[fd] == NULL || is_valid_address(buffer) == false || size < 0)
          exit(-1);

        if(fd == STDIN_FILENO)
          return input_getc();
        else {
          lock_acquire(&filesys_lock);
          int return_value = file_read(thread_current()->fd_table[fd], buffer, size);
          lock_release(&filesys_lock);

          return return_value;
        }
      }
      ```
      </details>
  - **`write()`**
    - Writes size bytes from buffer to the open file `fd`.
    - Returns the number of bytes actually written, which may be less than size if some bytes could not be written.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int write(int fd, const void *buffer, unsigned size) {
        if(is_valid_address(buffer) == false || size < 0)
          exit(-1);

        if(fd == STDOUT_FILENO) 
          putbuf(buffer, size);
        else {
          struct file *target_file = thread_current()->fd_table[fd];
          if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || target_file == NULL)
            exit(-1);
          lock_acquire(&filesys_lock);
          int return_value = file_write(target_file, buffer, size);
          lock_release(&filesys_lock);

          return return_value;
        }
        return size;
      }
      ```
      </details>
  - **`seek()`**
    - Changes the next byte to be read or written in open file `fd` to `position`, expressed in bytes from the beginning of the file.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void seek(int fd, unsigned poisiton) {
        if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || thread_current()->fd_table[fd] == NULL)
          exit(-1);

        lock_acquire(&filesys_lock);
        file_seek(thread_current()->fd_table[fd], poisiton);
        lock_release(&filesys_lock);
      }
      ```
      </details>
  - **`tell()`**
    - Returns the position of the next byte to be read or written in open file `fd`, expressed in bytes from the beginning of the file.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      unsigned tell(int fd) {
        if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || thread_current()->fd_table[fd] == NULL)
          exit(-1);

        lock_acquire(&filesys_lock);
        int return_value = file_tell(thread_current()->fd_table[fd]);
        lock_release(&filesys_lock);
        return return_value;
      }
      ```
      </details>
  - **`close()`**
    - Closes file descriptor `fd`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void close(int fd) {
        struct thread *current_thread = thread_current();
        if(fd < 0 || fd >= FD_TABLE_MAX_SLOT || current_thread->fd_table[fd] == NULL)
          exit(-1);

        lock_acquire(&filesys_lock);
        file_close(current_thread->fd_table[fd]);
        lock_release(&filesys_lock);

        current_thread->fd_table[fd] = NULL;
        current_thread->next_fd = fd;
      }
      ```
      </details>
- **`process.c`**
  - **`process_exit()`**
    - Closes all remaining `file` objects
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      process_exit (void)
      {
        struct thread *cur = thread_current ();
        uint32_t *pd;

        if(lock_held_by_current_thread(&filesys_lock) == false)
          lock_acquire(&filesys_lock);

        /* deallocate opened file objects */
        for(--cur->next_fd; cur->next_fd > -1; --cur->next_fd)
          file_close(cur->fd_table[cur->next_fd]);

        file_close(cur->current_running_file);

        /* Destroy the current process's page directory and switch back
          to the kernel-only page directory. */
        pd = cur->pagedir;
        if (pd != NULL) 
        {
          /* Correct ordering here is crucial.  We must set
              cur->pagedir to NULL before switching page directories,
              so that a timer interrupt can't switch back to the
              process page directory.  We must activate the base page
              directory before destroying the process's page
              directory, or our active page directory will be one
              that's been freed (and cleared). */
          cur->pagedir = NULL;
          pagedir_activate (NULL);
          pagedir_destroy (pd);
        }
        lock_release(&filesys_lock);
      }
      ```
      </details>
    
### Conclusion
- PintOS now supports a robust set of system calls, enabling advanced process and file operations.

### Improved Grade


## Final Thoughts
- These enhancements transformed PintOS into a more capable operating system, with improved process management, argument handling, synchronization, and system call support. 
- This second project optimized resource utilization and thread coordination, demonstrating my ability to tackle complex OS-level challenges.


[Top](#){: .btn .btn--primary }{: .align-right}