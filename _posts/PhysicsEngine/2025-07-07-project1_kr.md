---
title: "3D Physics Engine"

categories:
    - physics

tags:
    - [physics, Physics, GamePhysics, C++, DirectX12, Win32API, GameEngineDevelopment, CustomEngine, RigidBodyDynamics, CollisionDetection, ConstraintSolver, SweepAndPrune, SAP, BroadPhase, NarrowPhase, GJK, EPA, CCD, TimeOfImpact, TOI, ContactManifolds, VisualDebugging, PerformanceTuning]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-07-07
---

[English](https://sadoe3.github.io/physics/project1/){: .btn .btn--primary }{: .align-center}


# 사용자 정의 3D 물리 엔진 (Custom 3D Physics Engine)

## 1. 프로젝트 개요
* 본 프로젝트는 **Win32 API**와 **DirectX 12**를 사용하여 **C++**로 구현된 종합적인 **3D 물리 엔진** 개발 사례를 보여줍니다.
* 주요 목표는 상용 미들웨어를 사용하지 않고 물리 시뮬레이션을 기초부터 설계함으로써, 현대 게임 개발에서 흔히 사용되는 강체 역학(Rigid Body Dynamics), 충돌 탐지 파이프라인 및 제약 조건 해소(Constraint Resolution) 전략에 대한 깊은 이해를 얻는 것이었습니다.
* 본 엔진은 견고한 **하이브리드 충돌 해소(Hybrid Collision Resolution)** 시스템, 최적화된 **스윕 앤 프룬(Sweep and Prune, SAP)** 광역 단계(Broad-phase), 그리고 복잡한 물리적 상호작용을 검증하기 위해 설계된 강력한 **시각적 디버깅 도구(Visual Debugging Suite)**를 특징으로 합니다.

[add image/gif here]
(캡션: DirectX 12에서 실행 중인 물리 엔진 시뮬레이션 개요)

### 핵심 기술 스택
* **언어:** C++ (현대적인 C++17 표준)
* **그래픽/시스템:** DirectX 12, Win32 API
* **주요 알고리즘:** 스윕 앤 프룬(SAP), GJK, EPA, 순차적 임펄스 해결기(Sequential Impulse Solver), 연속 충돌 탐지(Continuous Collision Detection, CCD).


## 2. 아키텍처 및 파이프라인
* 시뮬레이션은 성능과 정확성의 균형을 맞추기 위해 설계된 다단계 파이프라인을 실행합니다.

### 1. 적분 (Integration)
* 중력, 외부 임펄스 및 사용자 개입을 포함하여 누적된 힘을 바탕으로 선속도와 각속도, 그리고 위치를 업데이트합니다.

### 2. 광역 단계 (Broad Phase)
* 축 정렬 알고리즘(스윕 앤 프룬)을 사용하여 충돌하지 않는 쌍을 빠르게 제거함으로써, 이후 단계의 계산 부하를 최소화합니다.

### 3. 협역 단계 (Narrow Phase)
* 정확한 교차 테스트를 위해 볼록 헐(Convex Hull) 알고리즘(GJK/EPA)을 활용하여 접촉점 및 법선을 포함한 충돌 매니폴드를 정밀하게 결정합니다.

### 4. 해소 (Resolution)
* 물리적 안정성을 보장하기 위해 순차적 임펄스 기반 해결기를 사용하여 기계적 제약 조건과 접촉 관통을 해결합니다.


## 3. 충돌 탐지

### 3.1. 광역 단계: 최적화된 스윕 앤 프룬 (SAP)
* 많은 수의 객체가 포함된 장면을 효율적으로 관리하기 위해 엔진은 **스윕 앤 프룬(SAP)** 알고리즘을 활용합니다.
* 여기서 구현된 중요한 최적화는 **동적 축 선택(Dynamic Axis Selection)**입니다.
    * 시스템은 고정된 축을 고수하는 대신, 매 프레임 객체의 공간적 분산을 평가하고 가장 넓게 퍼진 축을 따라 객체를 정렬합니다.
    * 이를 통해 투영 축 상의 중첩 구간 수를 최소화하여 오탐지(False Positives)를 크게 줄입니다.
* 구현 하이라이트:
    * 중첩된 본체의 활성 목록(Active List)을 유지함으로써 메모리 안전성을 보장하고  검사를 방지합니다.

    ```cpp
    void SweepAndPrune1D(const Body* bodies, const int numBodies, std::vector<collisionPair_t>& finalPairs, const float deltaSecond) {
        // 최적화: 밀집된 장면에서 스택 오버플로를 방지하기 위해 std::vector 사용
        std::vector<pseudoBody_t> sortedBodies(numBodies * 2);

        // 1. 경계 계산 및 최적의 축 선택
        SortBodiesBounds(bodies, numBodies, sortedBodies.data(), deltaSecond);

        // 2. 활성 목록 방식을 이용한 충돌 쌍 구축 (O(N + K))
        BuildPairs(finalPairs, sortedBodies.data(), numBodies);
    }

    void BuildPairs(std::vector<collisionPair_t>& collisionPairs, const pseudoBody_t* sortedBodies, const int numBodies) {
        // 참고: finalPairs는 호출자(BroadPhase)에서 초기화됨
        std::vector<int> activeList; // 현재 중첩된 본체들의 ID 저장

        const int doubleNumBodies = numBodies * 2;
        for (int i = 0; i < doubleNumBodies; ++i) {
            const pseudoBody_t& targetBody = sortedBodies[i];
            int bodyId = targetBody.id;

            if (targetBody.isMin) {
                // 본체가 스윕 축에 진입: 현재 활성화된 모든 본체와 쌍을 생성
                for (int activeId : activeList) {
                    collisionPair_t pair;
                    pair.a = std::min(bodyId, activeId);
                    pair.b = std::max(bodyId, activeId);
                    collisionPairs.push_back(pair);
                }
                activeList.push_back(bodyId);
            } else {
                // 본체가 스윕 축을 벗어남: 활성 목록에서 제거
                auto it = std::remove_if(activeList.begin(), activeList.end(),
                    [bodyId](int id) { return id == bodyId; });
                activeList.erase(it, activeList.end());
            }
        }
    }
    ```

### 3.2. 협역 단계: GJK & EPA
* 볼록 다면체 간의 정밀한 충돌 탐지를 위해 엔진은 **GJK(Gilbert-Johnson-Keerthi)** 알고리즘을 채택합니다.
* **교차 테스트:** 
    * GJK는 구성 공간 객체(Configuration Space Object, CSO) 내부에 심플렉스(Simplex)를 반복적으로 구축하여 원점을 포함하는지 여부를 판단합니다.
* **접촉 생성:**
    * 충돌 시, **EPA(Expanding Polytope Algorithm)**가 실행되어 심플렉스를 CSO 경계까지 확장함으로써 관통 깊이와 접촉 법선을 계산합니다.
* **구체(Sphere)**와 같이 성능이 중요한 기본 도형의 경우, **비싼 GJK 반복 계산을 우회**하기 위해 특화된 대수적 테스트(Ray-Sphere, Sphere-Sphere)가 구현되어 있습니다.


## 4. 하이브리드 충돌 해소
* 엔진은 충돌 상황에 따라 감지된 접촉을 서로 다른 해결기에 지능적으로 배분합니다.

### 4.1. 연속 충돌 탐지 (CCD)
* 고속 물체가 기하 구조를 통과하는 "터널링 현상"을 완화하기 위해 **예측 임펄스 해결기(Predictive Impulse Solver)**가 구현되었습니다.
* **메커니즘:** 
    * 시스템은 동적 객체에 대한 **충돌 시간(Time of Impact, TOI)**을 계산합니다.
* **실행:**
    * 접촉은 TOI 순으로 정렬됩니다. 
    * 시뮬레이션은 가장 이른 충돌 시간($TOI > 0$)까지 진행되어 충돌을 해결한 후 이를 반복합니다.
    * 이를 통해 빠르게 움직이는 물체가 정적인 환경과 올바르게 상호작용하도록 보장합니다.

### 4.2. 순차적 임펄스 해결기
* 정적 접촉($TOI > 0$) 및 기계적 제약 조건(조인트, 정지 접촉)을 위해 **반복적 제약 조건 해결기(Iterative Constraint Solver)**가 사용됩니다.
* 이 해결기는 복잡한 적재 상황에서 안정성을 확보하기 위해 이전 프레임의 해를 초기 추정값으로 사용하는 "웜 스타팅(Warm Starting)" 기법을 적용합니다.


## 5. 시각적 디버깅 도구
* 물리 프로그래밍에서 엄격한 시각적 검증이 매우 중요하다는 점을 인식하여, **런타임 검사 도구(Runtime Inspection Tools)** 개발에 상당한 비중을 두었습니다.

### 5.1. 성능 모니터
* 실시간 성능 그래프가 현재 FPS와 CPU 부하를 추적합니다.
* 이는 스트레스 테스트 중 최적화 기법의 효율성에 대한 즉각적인 피드백을 제공합니다.

[add image/gif here]
(캡션: 부하 상황에서도 안정적인 FPS를 보여주는 성능 모니터)

### 5.2. 대화형 객체 검사기
* 사용자는 시뮬레이션을 일시 중지하고 마우스 피킹을 통해 객체를 선택할 수 있습니다.

#### **속성 검사기** 
* 검사기 패널은 선속도/각속도, 질량, 방향을 포함한 실시간 물리적 속성을 보여줍니다.

[add image/gif here]
(캡션: 객체의 속성을 보여주는 객체 검사기)

#### **기즈모 조작** 
* 선택된 객체는 3D 기즈모를 사용하여 이동하거나 회전할 수 있습니다.
* 조작 후 안정성을 보장하기 위해 물리 상태(속도 초기화)가 자동으로 관리됩니다.

[add image/gif here]
(캡션: 기즈모를 이용한 객체 조작)

### 5.3. 심층 접촉 시각화
* 협역 단계와 해결기의 정확성을 검증하기 위해 엔진은 상세한 시각화 모드를 제공합니다.

#### **와이어프레임 및 하이라이트**
* 가려짐을 방지하기 위해 선택된 객체와 충돌 쌍을 와이어프레임 모드로 전환할 수 있습니다.
* 볼록 형상의 경우, 충돌에 관여하는 특정 **삼각형**이 강조 표시됩니다.

[add image/gif here]
*(캡션: 충돌에 관여하는 특정 삼각형을 강조하는 와이어프레임 렌더링)*

#### **접촉 데이터**
* 접촉점은 상호작용 가능한 빨간색 상자로 렌더링되며, 충돌 법선은 노란색 화살표로 시각화됩니다.
* 이를 통해 수치적인 충돌 해소 결과에 대한 시각적 검증이 가능합니다.

[add image/gif here]
*(캡션: 접촉 매니폴드 시각화: 빨간색 상자는 접촉점을 나타내고, 노란색 화살표는 법선 벡터를 나타냄)*

#### **충돌 결과 트리 UI (Hit Result Tree UI)**
* 다중 충돌이 발생할 때 트리 뷰 UI가 모든 접촉 쌍을 정리하여 개발자가 특정 매니폴드를 격리하고 검사할 수 있도록 합니다.
* 특정 접촉점을 선택하면 계층 구조 내의 해당 서브트리가 자동으로 강조됩니다.

[add image/gif here]
*(캡션: 접촉점 선택 시 해당 서브트리를 강조하는 충돌 결과 트리 UI)*

### 5.4. 프레임별 히스토리 (되감기/재생)
* 일시적인 버그나 고속 이벤트를 분석하기 위해 **순환 히스토리 버퍼(Circular History Buffer)**가 구현되었습니다.
* **기능:** 
    - 엔진은 마지막 120프레임 동안 모든 강체의 전체 상태(변환, 속도)를 기록합니다.
* **디버깅:** 
    - UI 슬라이더를 통해 사용자가 시간을 앞뒤로 탐색할 수 있어, 충돌의 시작과 반응에 대한 프레임 단위의 완벽한 분석이 가능합니다.

    [add image/gif here]
    (캡션: 이전 프레임으로 되감기)


## 6. 스트레스 테스트 및 검증
* 다양한 조건에서 엔진의 성능과 안정성을 벤치마킹하기 위해 전용 스트레스 테스트 장면이 제작되었습니다.

[add image/gif here]
(캡션: 설정 가능한 매개변수가 포함된 스트레스 테스트 장면 설정)

### 6.1. 테스트 환경 설정
* 이 장면은 다양한 하위 시스템을 테스트하기 위해 구성 가능한 매개변수를 제공합니다.
* **밀도 (Dense vs. Sparse):** 객체 간격을 제어합니다.
    * *Dense (밀집):* SAP 중첩 검사를 엄격하게 테스트하기 위해 객체들을 촘촘하게 배치합니다.

    [add image/gif here]
    (캡션: 밀집 구성: 광역 단계의 중첩 효율성을 테스트하는 높은 객체 집중도)
    * *Sparse (희소):* 컬링(Culling) 효율성을 검증하기 위해 객체들을 분산시킵니다.

    [add image/gif here]
    (캡션: 희소 구성: 효과적인 공간 컬링을 검증하는 넓게 분산된 객체들)
* **형상 선택:**
    * *Sphere (구체):* 해석적 충돌 알고리즘을 테스트합니다.
    * *Diamond (볼록 다면체):* GJK/EPA 알고리즘의 성능을 테스트합니다.

    [add image/gif here]
    (캡션: 복잡한 볼록 다면체를 이용한 GJK/EPA 알고리즘 스트레스 테스트)
* **초기 높이:**
    * 초기 높이를 수정하여 위치 에너지를 조절함으로써 고속 충돌 안정성과 적재 동작을 테스트할 수 있습니다.

    [add image/gif here]
    (캡션: 고속 충돌 안정성 테스트를 위한 초기 낙하 높이 수정)

### 6.2. 최적화 검증
* **광역 단계 최적화**의 런타임 토글 기능을 통해 스윕 앤 프룬(SAP) 알고리즘과 브루트 포스(Brute-force) 기준 방식 간의 즉각적인 A/B 테스트가 가능합니다.
* 이 설정은 다양한 공간 분포에 따른 알고리즘의 효율성을 검증합니다.

#### **밀집 시나리오 (Dense Scenario)**
* **밀집** 구성에서는 객체들이 촘촘하게 모여 있어 공간적 중첩도가 높습니다.

[add image/gif here]
*(그림 1: 밀집 시나리오 - SAP 활성화)*

[add image/gif here]
*(그림 2: 밀집 시나리오 - 브루트 포스 / 비최적화)*

* **분석:**
    * 위 그림에서 관찰되듯이, 밀집 시나리오에서는 성능 차이가 미미합니다.
    * 객체 농도가 높기 때문에 광역 단계 전략에 관계없이 잠재적인 충돌 쌍의 수가 높게 유지됩니다.
    * 결과적으로 SAP 알고리즘이 쌍을 효과적으로 제거하지 못하며, 계산 부하가 주로 협역 단계에 집중됩니다.

#### **희소 시나리오 (Sparse Scenario)**
* **희소** 구성에서는 객체들이 장면 전체에 넓게 분포되어 있습니다.

[add image/gif here]
*(그림 3: 희소 시나리오 - SAP 활성화)*

[add image/gif here]
*(그림 4: 희소 시나리오 - 브루트 포스 / 비최적화)*

* **분석:** 
    * 이 시나리오에서는 성능 격차가 뚜렷해집니다.
    * SAP 알고리즘은 상호작용하지 않는 멀리 떨어진 객체들을 효과적으로 제거하여 안정적인 프레임 속도를 유지합니다.
    * 반면, 브루트 포스 방식은 복잡도로 인해 성능이 크게 저하되며, 멀리 떨어진 객체 간의 충돌을 확인하느라 연산 주기를 낭비합니다.


## 7. 샌드박스 장면 (Sandbox Scene)
* 샌드박스 장면은 제약 조건 해결기의 안정성과 다재다능함을 확인하기 위해 전형적인 시뮬레이션 시나리오를 보여주는 종합 검증 환경 역할을 합니다.

[add image/gif here]
*(캡션: 여러 물리 테스트 케이스가 포함된 샌드박스 환경 개요)*

### 7.1. 시뮬레이션 시나리오
#### **상자 쌓기 (Stacked Boxes)**
* 이는 **반복적 해결기의 수렴성**과 안정성을 검증합니다.
* 특히 수직 적재 중 지터(Jitter) 현상을 방지하는 데 있어 "웜 스타팅"의 효과를 테스트합니다.

[add image/gif here]
*(캡션: 해결기 안정성을 보여주는 수직 적재 시연)*

#### **체인 (Chain)**
* **거리 제약 조건(Distance Constraints)**과 오차 보정을 테스트합니다.
* 이 시나리오는 중력과 인장력 하에서도 링크가 늘어나지 않고 연결 상태를 유지하는지 확인합니다.

[add image/gif here]
*(캡션: 다수의 거리 제약 조건을 활용한 체인 시뮬레이션)*

#### **이동 플랫폼 (Moving Platform)**
* **운동학적 본체(Kinematic bodies, 무한 질량)**와 동적 본체 간의 상호작용을 검증합니다.
* 이동하는 표면에서의 마찰력 적용 및 상대 속도 처리를 테스트합니다.

[add image/gif here]
*(캡션: 선형 운동학적 이동 장치와 상호작용하는 동적 객체들)*

#### **회전자 (Rotator)**
* **각속도** 적분 및 충돌 반응을 보여줍니다.
* 이 시나리오는 동적 객체가 고속으로 회전하는 운동학적 장애물의 충돌에 어떻게 반응하는지 테스트합니다.

[add image/gif here]
*(캡션: 회전하는 운동학적 본체가 포함된 충돌 해소)*

#### **래그돌 (Ragdoll)**
* 이는 복잡한 **관절 시스템(Articulated System)** 테스트입니다.
* 계층적 변환과 조화롭게 작동하는 다중 제약 조건(조인트 및 제한 범위)의 안정성을 검증합니다.

[add image/gif here]
*(캡션: 계층적 조인트 제약 조건을 보여주는 관절형 래그돌 시뮬레이션)*


## 8. 향후 발전 방향
* 엔진의 기능과 성능을 더욱 향상시키기 위해 다음과 같은 개선 사항이 계획되어 있습니다.

### **협역 단계 최적화**
* 지속적인 접촉에서 계산 오버헤드를 줄이기 위해 GJK에 시간적 일관성(Temporal Coherence) 또는 고급 캐싱 기법을 구현합니다.

### **샌드박스 케이스 추가** 
* 복잡한 복합 형상과 추가적인 제약 조건 유형(예: 볼앤소켓, 슬라이더)을 도입합니다.

### **스트레스 테스트 형상 추가**
* 더 넓은 범위의 충돌 기본 도형을 검증하기 위해 캡슐(Capsule) 및 원기둥(Cylinder)을 테스트 제품군에 포함합니다.


[Top](#){: .btn .btn--primary }{: .align-right}
