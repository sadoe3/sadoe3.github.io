---
title: "Qt6 : QTableWidget and QTableView"

categories:
    - qt6

tags:
    - [Qt6, GUI, Design, Qt Designer, C++, QTableWidget, QTableView]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-11-17
---

# `QTableWidget` and `QTableView`


## `QTableWidget`
`QTableWidget` is a **higher-level**, easier-to-use widget

### When to Use
Use `QTableWidget` if
- you have a relatively **small** and **simple** dataset
- you want to **quickly display** and edit a table **without** worrying about **external data** models
- you **don't need** advanced features like `sorting` or `filtering`

### How to Use
You can easily use `QTableWidget` by following the steps below
1. set proper number of columns
    ```c++
    Ui->tableWidget->setColumnCount(i);   // i[1~n]
    ```
2. set header (you can skip this step)
    ```c++
    QStringList header;
    header << “name1” << “name2”;
    Ui->tableWidget->setHorionztalheaderLabels(header);
    ```
    * or you can set the header inside `Qt Designer`
        + right click `QTableWidget` object -> edit items -> columns
3. add rows
    ```c++
    // what you need to do is:
    // A. insert new row
    ui->tableWidget->setRowCount(currentRow + 1);
    // B. create proper widgets which resides in that row
    QLineEdit *myLineEdit = new QLineEdit(ui->tableWidget);
    // C. place them on a row with the exact row and column index
    ui->tableWidget->setCellWidget(0, 0, myLineEdit);
    ```
4. Resize rows and columns properly
    ```c++
    // automatic resize

    // resize based on the individual contents
    // each column of different rows may have the different width
    ui->tableWidget->resizeColumnsToContents();
    ui->tableWidget->resizeRowsToContents();

    // resize evenly
    // every column of all rows always has the same width
    ui->tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    ```
    ```c++
    // manual resize
    tableWidget->setColumnWidth(0, this->width()/3);
    tableWidget->setColumnWidth(1, this->width()/3);
    tableWidget->setColumnWidth(2, this->width()/3);
    ```

### How to Get the Pointer to the Widget in the `QTableWidget`
```c++
static_cast<QLineEdit*>(ui->tableWidget->cellWidget(data.rowIndex, 3);
// then you can do anything that you want to do for the proper widget
static_cast<QLineEdit*>(ui->tableWidget->cellWidget(data.rowIndex, 3)->setText(converter.toString(tempString.toULong()));
```

### How to Add Empty Item for `QTableWidget`
Add `nullptr`

### How to Change the Widget of Columns Dynamically
```c++
// this code sets the third column's width dynamically, and gives fixed width to other columns
ui->tableView->horizontalHeader()->setSectionResizeMode(2, QHeaderView::ResizeToContents);
// set other columns
ui->tableView->setColumnWidth(0, ui->tableView->width()/15 * 3);
ui->tableView->setColumnWidth(1, ui->tableView->width()/15 * 2);
ui->tableView->setColumnWidth(3, ui->tableView->width()/15 * 4);

// check to stretch or fix the width
if(ui->tableView->columnWidth(2) < ui->tableView->width()/15 * 5) {
    ui->tableView->horizontalHeader()->setSectionResizeMode(2, QHeaderView::Fixed);
    ui->tableView->setColumnWidth(2, ui->tableView->width()/15 * 5);
}
```


## `QTableView`
`QTableView` is a **lower-level**, more flexible widget

### When to Use
Use `QTableView` if
- you need to manage **large** or **complex** datasets
- you want **more control** over the way data is **presented**, **edited**, and **interacted with**
- you need to work with **external data** sources like `databases` or `CSV files`
- you need **advanced features** like `sorting`, `filtering`, and `custom cell rendering`

### How to Use
You can easily utilize `QTableView` by using this code
```c++
#include <QStandardItemModel>

QStandardItemModel *model = new QStandardItemModel;
// setting up header
model->setHorizontalHeaderLabels({"Date", "Content"});
// using appendRow()
for(auto currentData : dataSet) {
    QList<QStandardItem*> items;
    if(currentData.date == targetDate) {
        items.append(new QStandardItem(QString::number(currentData.date.year()) + "년" + QString::number(currentData.date.month()) + "월" + QString::number(currentData.date.day()) + "일"));
        items.append(new QStandardItem(currentData.content));

        model->appendRow(items);
    }
}
// using setItem()
model->setItem(1, 0, new QStandardItem(QString::number(certainData.date.year()) + "년" + QString::number(certainData.date.month()) + "월" + QString::number(certainData.date.day()) + "일")));
model->setItem(1, 1, new QStandardItem(certainData.content));


// set the model to the table view
tableView->setModel(model);
// optionally, you can resize QTableView like QTableWidget
tableView->resizeColumnsToContents();
```
- it's worth noting that if you don't want the `QTableView` to be edited, you can accomplish this through `Qt Designer`
    * `Qt Designer` -> click the `QTableView` Widget -> table properties -> QAbstractItemView -> editTriggers -> no edit triggers –> check it

### How to Align the Item
If you want to **align** the item in the `QTableView`, try this code
```c++
auto itemValue = new QStandardItem(converter.toString(currentData.value) + "원");
itemValue->setTextAlignment(Qt::AlignmentFlag::AlignRight | Qt::AlignmentFlag::AlignVCenter);
items.append(itemValue);
```

### How to Implement a Custom Scroll Area
In `Qt Designer`, you can use basic **scroll area** by using **drag and drop** the scroll area object and then drag and drop the proper item to the scroll area
- however, you don’t want to **hide** the **scrollbar** try this 
    ```c++
    ui->tableView->resizeRowsToContents();
    unsigned height = ui->tableView->horizontalHeader()->height();
    for(unsigned row = 0, endRow = ui->tableView->model()->rowCount(); row < endRow; row++)
        height += ui->tableView->rowHeight(row);
    ui->tableView->setMinimumHeight(height);
    ```
    * then go to the properties of table view widget -> QAbstractScrollArea -> verticalScrollBarPolicy -> ScrollBarAlwaysOff -> check



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}