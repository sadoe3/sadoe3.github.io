---
title: "C++ Primer : Chapter 9"

categories:
    - cpp

tags:
    - [C++, Programming Language, Sequential Container, string, vector]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-5
---

# Sequential Containers

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Overview of the Sequential Containers
A Container holds a **collection** of objects of a specified type

### Sequential Container Types
The **Sequential Containers** are the containers which support the **sequential access**
||Sequential Container Types|
|:---:|:---|
|`vector`|flexible-size arrary. supports fast random access. inserting or deleting elements other than at the back may be slow|
|`string`|a specialize container, similar to `vector`, that contains characters. fast random access. fast insert/delete at the back|
|`forward_list`|singly linked list. supports only sequential access in one direction. fast insert/delete at any point in the list|
|`list`|doubly linked list. supports only bidirectional sequential access. fast insert/delete at any point in the list|
|`deque`|double-ended queue. supports fast random access. fast insert/delete at front or back|
|`array`|fixed-size array. supports fast random access. cannot add or remove elements|
- in order to use the container, you need to **include** the header of which name is the name of the type itself
    * for `std::array`, include `<array>`
- With the exception of `array`, which is a fixed-size container, the containers provide efficient, flexible memory management
- `std::string` and `std::vector` hold their elements in **contiguous** memory
    * therefore, it's fast to comptue the adress of an element from its **index**
    * however, adding or removing elemetns in the middle of one of these containers takes time
        + all the element after the one inserted or removed have to be moved to maintain **contiguity**
        + moreover, adding an element can sometimes require that additional storage be **allocated**, then, every element must be moved into the new storage
- `std::list` and `std::forward_list` containers are designed to make it fast to add or remove an element **anywhere** in the container
    * in exchange, these types do **not** support **random access**
        + we can access the element only through **sequential access**
    * moreover, the memory overhead for these containers is often **substantial**, when compared to `std:::vector`, `std::deque`, and `std::array`
- `std::deque` is similar to `std::string` and `std::vector` with one exception
    * adding or removing elements at either **end** of the `std::deque` is a **fast** operation, comparable to adding an element to a `std::list` or `std::forward_list`
    * other features are simliar to `std::vector`
        * support fast random access
        * adding or removing elements in the middle of a `std::deque` is a (potentially) **expensive** operation
- `std::array` is a safer, easier-to-use, and faster alternative to built-in arrays
    * because it's just C++ sytle array, it doesn't suuport operations to add and remove elements or to resize the container
- it's usually better to use the library containers rather than primitive structures like arrays
 
### Deciding which container to use
There are a few rules of thumb that apply to selecting which container to use
- Unless you have a good reason to use another container, use a `std::vector`
- If your program has lots of small elements and space overhead matters, **don't use** `std::list` and `std::forward_list`
- If the program requires random access to elements, use a `std::vector` or a `std::deque`
- If the program needs to insert or delete elements in the middle of the container, use a `std::list` or `std::forward_list`
- If the program needs to insert or delete elements at the front and the back, but not in the middle, use a `std::deque`
- If the program must support to insert into the middle and the ramdom access
    * choose one of the following solutions by performing the performance test
        + use `std::list` for inserting phase, then copy the `std::list` into a `std::vector` to support the random access
        * just use `std::vector`

## Container Library Overview

### Operation Hierarchy
- some operations are provided by all containers
- some operations are specific to the **sequential**, the **associative**, or the **unordered** containers
- others are specific to only a smaller subset of the containers

### Container Operations
The Following table shows the common type aliases and operations defined in all containers
||Container Operations|
|:---:|:---|
|**Type Aliases**||
|`iterator`|type of the iterator for this container type|
|``||
|``||
|**Construction**||
|`C c;`|default constructor, empty container|
|``||
- the relational operators uses their element's relational operator
    * which means, it's valid to compare different types only if there's an appropriate conversion operator defined

### Iterators
Basically, iterator is like a pointer which points to the element of the container.
- hence, you can perform pointer operations on the iterators as well
    * however, some containers don't support them
        + `std::forward_list` iterators do not support the `--(decrement operator)`
        + the iterator arithmetic operations apply only to iterators for `std::string`, `std::vector`, `std::deque`, and `std::array`
- an **iterator range** is denoted by a pair of iterators each of which refers to an element, or to **one past the last element** in the same container
    * these two iterators often referred to as `begin` and `end`
    * this range is called a left-inclusive interval
        + \[ begin, end )
    * `end` may be equal to `begin` but must not precede it
        + if they are equal, the range it empty
        + otherwise, there is at least one element in the range, and `begin` refers to the **first** element 
        + we can increment `begin` untile `begin == end`
    * you can get the iterators by calling `.begin()` and `.end()` methods
- the **reverse** iterator is an iterator that goes **backward** through a container
    * for instance, `++` on a reverse iterator yields the previous element
- if write access it not needed, use `const` version of iterators

### Initialization of Containers
||Defining and Initializing Containers|
|:---:|:---|
|`C c`|default constructor. if `C` is `std::array`, then the elements in c are default-initialized, otherwise `c` is empty|
|`C c1(c2)`|`c1` is a copy of `c2`. `c1`and `c2` must have the same or convertible type to each other. for `std::array`, must have the same size as well|
|`C c1 = c2`|same as `C c1(c2)`|
|`C c{a, b, c, ...}`|`c` is a copy of the elements in the initializer list. type of elements in the list must be compatible with the element type of `C`. for `std::array`, any missing element are value-initialized|
|`C c = {a, b, c, ...}`|same as `C c{a, b, c, ...}`|
|`C c(b,e)`|c is a copy of the elements in the range denoted by iterators `b` and `e`(left-inclusive). type of the elements must be compatible with the element type of C. **Not valid for `std::array`**|
||**Constructors that take a size are valid for `sequential container` (not including `std::array`) only**|
|`C seq(n)`|`seq` has `n` value-initialized elements; this constructor is `explicit`. **Not valid for `std::string`**|
|`C seq(n, t)`|`seq` has `n` elements with value `t`|

### Assignment and swap

||Container Assignment Operations|
|:---:|:---|
|`c1 = c2`|replace the elements in `c1` with **copies** of the elements in `c2`. `c1` and `c2` must be the same or compatible type to each other|
|`c = (a, b, c...}`|replace the elements in `c1` with copies of the elements in the initializer list. **not valid for `std::array`**|
|`swap(c1, c2)`|exchanges elements in `c1` with those in `c2`. `c1` and `c2` must be the same type. `swap` is usually much faster than copying elements from `c2` to `c1`|
|`c1.swap(c2)`|equivalent to `swap(c1, c2)`|
||**assign operations not valid for associative containers or `std::array`**|
|`seq.assign(b, e)`|replaces elements in `seq` with those in the range denoted by iterators `b` and `e`. The iterators `b` and `e` must not refer to elements in `seq`|
|`seq.assign(il)`|replaces the elements in `seq` with those in the initializer list `i1`|
|`seq.assign(n, t)`|replaces the elements in `seq` with `n` elements with value `t`|

- note that assignment related operations **invalidate** iterators, references, and pointers into the left-hand container
    * aside from string they remain valid after a swap, and (excepting arrays) the containers to which they refer are swapped.
- the `=(assignment operator)` replaces the entire range of elements in the left-hand containers with **copies** of the elements from the right-hand operand
    * after the assignment, the left- and right-hand containers are **equal**
        + if the containers had been of **unequal size**
        + after the assignment, left-hand container would have the **size of the right-hand** container 
    * assignment operation can happen with a braced list
        + in the textbook, it said it's not possible to use a braced list with `std::array` for assignment operation
        + however, thanks to the update of the new standard, now it's possible to do it
        ```c++
        std::array<int, 3> arr = {0};
        arr = {1, 2};       // ok
        ```
- the `.assign()` methods are available from only the **sequential** containers except `std::array`
    * it does the assignment operation with the object created by the given parameters
- the `swap()` opeartion **doesn't copy, delete, or insert** any elements and is guaranteed to be executed at constant time
    * the elements themselves are not swapped; internal data strucrues are swapped
            + however, `std::array` does exchange the elements, hence, swapping two `std::array`s requires time proportinal to the number of elements in the `std::array`
    * which means, it's usually **much faster** than copying(assigning) elements from `c2` to `c1` 
- as a matter of habit, it's best to use the **nonmember** version of `std::swap()`


## Sequential Container Operations
There are operations specific to the **sequential** containers

### Adding Elements

||Operations that add elements to a sequential container|
|:---:|:---|
||**These operations change the size of the container; they are not supported by `std::array`. `std::forward_list` has special versions of insert and emplace**|
||**push_back and emplace_back not valid for `std::forward_list`. push_front and emplace_front not valid for `std::vector` or `std::string`**|
|`c.push_back(t)`|Creates an element with value `t` or constructed from `args` at the|
|`c.emplace_back(args)`|end of `c`. returns `void`.|
|`c.push_front(t)`|Creates an element with value `t` or constructed from `args` on the|
|`c.emplace_front(args)`|front of `c`. returns `void`.|
|`c.insert(p,t)`|Creates an element with value `t` or constructed from `args` before|
|`c.emplace(p, args)`|the element denoted by iterator `p`. returns an iterator referring to the element that was added.|
|`c.insert (p,n, t)`|Inserts `n` elements with value `t` before the element denoted by iterator `p`. returns an iterator to the first element inserted; if `n` is zero, returns `p`.|
|`c.insert(p, b, e)`|Inserts the elements from the range denoted by iterators `b` and `e` before the element denoted by iterator `p`. `b` and `e` may not refer to elements in `c`. returns an iterator to the first element inserted; if the range is empty, returns `p`.|
|`c.insert(p, il)`|`il` is a braced list of element values. inserts the given values before the element denoted by the iterator `p`. returns an iterator to the first inserted element; if the list is empty returns `p`.|

- note that adding elements to a `std::vector`, `std::string`, or `std::deque` potentially **invalidates** all existing iterators, references, and pointers into the container
- these operations change the size of the container; they are not supported by `std::array`
- `std::forward_list` has special versions of `.insert()` and `.emplace()`
- the difference between `.push` and `.emplace` is that
    * `.push` methods add the element with the **copied** object
    * `.emplace` methods add the element with the **constructed** object

### Accessing Elements
||Operations that access elements in a sequential container|
|:---:|:---|
|`c.back()`|returns a **reference** to the **last** element in `c`. **undefined** if `c` is empty. **Not valid for `std::forward_list`**|
|`c.front()`|returns a **reference** to the **first** element in `c`. **undefined** if `c` is empty.|
|`c[n]`|returns a **reference** to the element indexed by the unsigned integral value `n`. **undefined** if `n >= c.size()`. **Not valid for `std::forward_list` and `std::list`**|
|`c.at(n)`|returns a **reference** to the element indexed by the unsigned integral value `n`. if the index is out of range, **throws** an `out_of_range` exception. **Not valid for `std::forward_list` and `std::list`**|
- if you want to ensure that the index is valid, try to use `.at()` method instead

### Erasing Elements

||Operations that remove elements from a sequential container|
|:---:|:---|
||**These operations change the size of the container and so are not supported by `std::array`**|
||**`std::forward_list` has a special version of erase; pop_back not valid for `std::forward_list`; pop_front not valid for `std::vector` and `std::string`**|
|`c.pop_back()`|removes last element in `c`. undefined if `c` is empty. returns `void`|
|`c.pop_front()`|removes first element in `c`. undefined if `c` is empty. returns `void`|
|`c.erase(p)`|removes the element denoted by the iterator `p` and returns an iterator to the element after the one deleted or the off-the-end iterator if `p` denotes the last element. undefined if `p` is the off-the-end iterator|
|`c.erase(b, e)`|removes the range of elements denoted by the iterators `b` and `e`. returns an iterator to the element after the last one that was deleted, or an off-the-end iterator if `e` is itself an off-the-end iterator|
|`c.clear()`|removes all the elements in `c`. returns `void`|

- these operations change the size of the container; they are not supported by `std::array`
- `std::forward_list` has special versions of `.erase()`
- removing elements which are not the beginning or end of a `std::deque` **invalidates** all iterators, references, and pointers
- iterators, references, and pointers to elements after the erasure point in a `std::vector` or `std::string` are **invalidated**
- the methods that erase elements do not check their arguements; you must ensure that element(s) exist before removing them

### Specialized forward_list Operations
The operations to add or remove elements in a `std::forward_list` operate by chaning the element **after** the given element because there's no easy way to get to an element's predecessor in a singly linked list

||Operations to insert or remove elements in a `std::forward_list`|
|:---:|:---|
|`flst.before_begin()`|returns a iterator denotes the nonexistent element **just before** the beginning of `flst`. this iterator may not be dereferenced|
|`flst.cbefore_begin()`|returns the `constant_iterator` version of `.before_begin()`|
|`flst.insert_after(p,t)`|Inserts element(s) after the one denoted by iterator `p`. `t` is an|
|`flst.insert_after(p,n,t)`|object, `n` is a count, `b` and `e` are iterators denoting a range|
|`flst.insert_after(p,b,e)`|(`b` and `e` must not refer to `flst`), and `il` is a braced list. returns|
|`flst.insert_after(p,il)`|an iterator to the last inserted element. if the range is empty, returns `p`. undefined if `p` is the off-the-end iterator.|
|`emplace_after(p, args)`|Uses `args` to construct an element after the one denoted by iterator `p`. returns an iterator to the new element. undefined if `p` is the off-the-end iterator.|
|`flst.erase_after(p)`|Removes the element after the one denoted by iterator `p` or|
|`flst.erase_after(b,e)`|the range of elements from the one after the iterator `b` up to but not including the one denoted by `e`. returns an iterator to the element after the one deleted, or the off-the-end iterator if there is no such element. undefined if `p` denotes the last element in `flst` or is the off-the-end iterator.|

### Resizing a sequential container

||Sequential Container Size Operations|
|:---:|:---|
|`seq.resize(n)`|resize `seq` so that it has `n` elements. if `n < seq()`, the excess elements are **discarded**. if new elements must be added, they are value-initialized|
|`seq.resize(n, t)`|same as `seq.resize(n)`, but new elements have value `t`|

- `.resize()` is not valid for `std::array`
- note that resizing the sequential container **invalidates** the iterators, references, and pointers to the deleted elements and possibly all of them would be **invalidated**
    * if `std::vector` or `std::string` was **reallocated**, all iterators, references, and pointers are invalid
- therefore, you need to ensure that the iterator is **repositioned**, as appropriate, **after each operation** that changes the container
- the iterator returned from `.end()` is highly likely to be invalid
    * hence, it's usually a bad idea to store it as an object
    * partly for this reason, C++ standard libraries defines `.end()` method as a very fast operation

### How a vector Grows
`std::vector` and `std::string` sometimes **reallocate** capacity **more** than what is immediately needed if there's no room for new element in current capacity while maintaining the contiguity
```c++
    std::vector<int> a;
    while (a.size() == a.capacity())
        a.push_back(1);
    a.reserve(1);                   // this call is ignored because 1 must be less than a.capacity() at this point
    a.reserve(a.capacity() + 2);    // reallocate to add two extra rooms   
    a.shrink_to_fit();              // this may be ignored
```
- `a.capcity()` returns the **maximum** number of elements `a` can have before **reallocation** is necessary
    * note that `.capacity()` is different from `.size()`
    * `.size()` and `.resize()` are related to the number of the **actual** elements of the container
- `a.reserve()` reallocates space for **at least** `n` elements 
    * when you pass the number which is less than `.capacity()` to `.reserve()`, the call is **ignored**
- if you think the extra space is not necessary, you can **request** to return the unneeded memory by calling `.shrink_to_fit()` method
    * note that this call is to **request**, which means it can be **ignored**
    * if the request is accepted, `.capacity()` is equal to `.size()`
- `.capacity()` and `.reserve()` is valid only for `std::vector` and `std::string`
- `.shrink_to_fit()` is valid only for `std::vector`, `std::string`, and `std::deque`

## Additional string Operations

### Additional Ways to Construct strings

||`n`, `len2` and `pos2` are all `unsigned` values|
|:---:|:---|
|`string s(cp, n);`|`s` is a copy of the first `n` characters in the array to which `cp` points. that array must have at least `n` characters.|
|`string s(s2, pos2);`|`s` is a copy of the characters in the string `s2` starting at the index `pos2`. undefined if `pos2` > `s2.size()`|
|`string s(s2, pos2, len2);`|`s` is a copy of `len2` characters from `s2` starting at the index `pos2`. undefined if `pos2` > `s2.size()`. regardless of the value of `len2`, copies at most `s2.size() - pos2` characters|

### subtr Operation

||`substr` Operation|
|:---:|:---|
|`s.substr(pos, n)`|return a `std::string` containing `n` characters from `s` starting at `pos`. `pos` defaults to 0. `n` defaults to a value that causes the library to copy all the characters in `s` starting from `pos`|

### Other Ways to Change a string

||Operations to Modify `std::string`s|
|:---:|:---|
|`s.`||
|`s.`||
|`s.`||
|`s.`||
|`s.`||

### string Search Opeartions

||Operations to Modify `std::string`s|
|:---:|:---|
||**Search operations return the index of the desired character or npos if not found**|
|`s.find(args)`|find the first occurrence of `args` in `s`|
|`s.rfind(args)`|find the last occurrence of `args` in `s`|
|`s.find_first_of(args)`|find the first occurrence of any character from `args` in `s`|
|`s.find_last_of(args)`|find the last occurrence of any character from `args` in `s`|
|`s.find_first_not_of(args)`|find the first character in `s` that is not in `args`|
|`s.find_last_not_of(args)`|find the last character in `s` that is not in `args`|
||`args` **must be one of**|
|`c, pos`|look for the character `c` starting at position pos in `s`. `pos` defaults to `0`|
|`s2, pos`|look for the string `s2` starting at position pos in `s`. `pos` defaults to `0`|
|`cp, pos`|look for the C-style null-terminated string pointed to by the pointer `cp`. start looking at position `pos` in `s`. `pos` defaults to `0`|
|`cp, pos, n`|look for the first `n` characters in the array pointed to by the pointer `cp`. start looking at position `pos` in `s`. no default for `pos` or `n`|

- the search methods returns an `unsigned` type, hence, it's a bad idea to use an `int` or other `signed` types to hold it

### string comparison

||Possible Argument to `s.compare()`|
|:---:|:---|
|`s2`compare `s` to `s2`|
|`pos1, n1, s2`|compares `n1` characters starting at `pos1` from `s` to `s2`|
|`pos1, n1, s2, pos2, n2`|compares `n1` characters starting at `pos1` from `s` to the `n2` characters starting at `pos2` in `s2`|
|`ср`|compares `s` to the null-terminated array pointed to by `cp`|
|`pos1, n1, cp`|compares `n1` characters starting at `pos1` from `s` to `cp`|
|`pos1, n1, cp, n2`|compares `n1` characters starting at `pos1` from `s` to `n2` characters starting from the pointer `cp`|

### Numeric Conversion

||Conversions between `std::string`s and Numbers|
|:---:|:---|
|`to_string(val);`|overloaded functions returning the string representation of `val`. `val` can be any arithmetic type. there are versions of `to_string` for each floating-point type and integral type that is `int` or larger. small integral types are promoted as usual|
|`stoi(s, p, b)`|Return the initial substring of `s` that has numeric content as an `int`,|
|`stol(s, p, b)`|`long`, `unsigned long`, `long long`, `unsigned long long`, respectively.|
|`stoul(s, p, b)`|`b` indicates the numeric base to use for the conversion; `b` defaults|
|`stoll(s, p, b)`|to 10. `p` is a pointer to a size `t` in which to put the index of the first|
|`stoull(s, p, b)`|nonnumeric character in `s`; `p` defaults to `0`, in which case the function does not store the index.|
|`stof(s, p)`|Return the initial numeric substring in `s` as a `float`, `double`, or|
|`stod(s, p)`|`long double`, respectively. `p` has the same behavior as described|
|`stold(s, p)`|for the integer conversions|

- if the `std::string` can't be converted to a number, these functions throw an `invalid_argument` **exception**
- if the conversion generates a value that can't be represented, they throw `out_of range`

## Adaptors
There are 3 types of adaptors in C++
- Container Adaptor
- Iterator Adaptor
- Function Adaptor
- Essentially, an adaptor is a mechanism for making one thing act like another

### Container Adaptors
A container adaptor takes an existing container type and makes it act like a different type
- the following table shows the common operations and types of container adaptor

||Operations and Types Common to the Container Adaptor|
|:---:|:---|
|`size_type`|type large enough to hold the size of the largest object of this type.|
|`value type`|element type.|
|`container type`|type of the underlying container on which the adaptor is implemented.|
|`A a;`|create a new empty adaptor named `a`.|
|`A a (c) ;`|create a new adaptor named `a` with a copy of the container `c`.|
|*relational operators*|each adaptor supports all the relational operators: `==, !=, <, <=, ›, >=`. these operators return the result of comparing the underlying containers.|
|`a.empty()`|`false` if `a` has any elements, `true` otherwise.|
|`a.size()`|number of elements in `a`.|
|`swap(a, b)`|swaps the contents of `a` and `b`; `a` and `b` must have the same type,|
|`a.swap(b)`|including the type of the container on which they are implemented.|

### Sequential Container Adaptors
The library defines 3 **sequential container adaptors**
- the following are the ones
    * `std::stack`
        + defined in the `<stack>` header
        + implemented in terms of `std::deque` by default
        + can be implemented on a `std::list` or `std::vector` as well
    * `std::queue`
        + defined in the `<queue>` header
        + implemented in terms of `std::deque` by default
        + can be implemented on a `std::list` or `std::vector` as well
    * `std::priority_queue`
        + defined in the `<queue>` header
        + implemented in terms of `std::vector` by default
        + can be implemented on a `std::deque` as well
- we can override the default container type by naming a seqeuntial container as a **second type arguement** when we create the adaptor
```c++
std::stack<std::string, std::vector<std::string>> str_stk;
```

### Stack Adaptor
The following table shows how `std::stack` works

||Stack Operations|
|:---:|:---|
||**Uses `std::deque` by default; can be implemented on a `std::list` or `std::vector` as well**|
|`s.pop()`|Removes, but does not return, the top element from the `std::stack`.|
|`s.push(item)`|Creates a new top element on the `std::stack` by copying or moving `item`,|
|`s.emplace(args)`|or by constructing the element from `args`.|
|`s.top()`|Returns, but does not remove, the top element on the `std::stack`.|

- although it's implemented based on the `std::deque`, there's no direct access to the `std::deque` operations

### The Queue Adaptors
The following table shows how `std::queue` and `std::priority_queue` work

||`std::queue` and `std::priority_queue` Operations|
|:---:|:---|
|`q.push(item)`|create an element with value `item` at the end|
|`q.emplace(args)`|create an element with value constructed from `args` at the end|
|`q.pop()`|removes, but does not return, the **front** element or **highest-priority** element from the `std::queue` or `std::priority_queue`, respectively|
|`q.front()`|returns, but does not remove, the front element of `q`. **Valid only for std:queue`**|
|`q.back()`|returns, but does not remove, the back element of `q`. **Valid only for std:queue`**|
|`pq.top()`|returns, but does not remove, the highest-priority element of `pq`. **Valid only for std:priority_queue`**|


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}