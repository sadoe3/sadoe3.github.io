---
title: "Chapter 6"

categories:
    - cpp

tags:
    - [C++, Programming Language, Function]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-2
---

# Functions

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Prerequisites regarding functions
- this post assumes that you've already studied about functions through learning C
- hence, this post covers only about how the C++ features work with the existing concepts of functions

### C++ features
- passed by value and passed by refernece - p208
- reference to array (p114) - p 217
- varing parameters - p 220
- return list-intialzation - p226
- trailing return type and decltype as return type - p229
- overloaed functions - p230
- default argument - p236
- inline and constexpr - p238
- function matching - p242


## Argument Passing
- Passed by value and Passed by reference
- Varing Parameters

### Passed by value and Passed by reference
C and C++ have difference concepts regarding passing an argument as passed by value or passed by reference
- In **C**, passing a pointer is the sort of **passed by reference** because you **can change its value** through dereference it
    * From the perspective of C++, there's no way in C to pass an argument as **passed by reference** because there's no reference type in C
- In **C++**, however, passing a pointer is the sort of **passed by value** because it's not a reference so that **it's copied**
    * In C++, the only way to pass an argument as **passed by reference** is to make the parameter as a reference
    * In this way, the initializer is **not copied** because the parameter is a reference
- If you want to use a parameter as a reference in order not to copy the initializer and don't want to change its value
    * try to make the parameter as **reference to const**
- reference argument can be used as additional return values
    ```c++
    int factorial(int &countCalled, int number) {
        countCalled++;
        if (number == 1)
            return 1;
        return number * factorial(countCalled, number - 1);
    }
    ```
- you can set the parameter as a refence to an array
    ```c++
    int func(int (&rArr)[10]) {
        std::cout << rArr[2] << std::endl;
    }
    ```

### Varing Parameters
You can implement a function which takes **varing number** of arguments in 2 ways
- C style
    * using **ellipsis**
    * same rules applied in C++ as in C
    * use this feature only if you need to interface to C code otherwise, try C++ style features
- C++ style
    * varing number of argument of the **same** type : `initializer_list<type>` template
    * varing number of argument of the **different** type : variadic template
        + this concept would be covered in the later chapter

### initializer_list<type>
