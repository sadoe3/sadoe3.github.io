---
title: "Coroutine"

categories:
    - unity

tags:
    - [Game Engine, Unity, Coroutine, Self-Study]

toc: true
toc_label: "목차"
toc_sticky: true

date: 2021-10-27
---

## About coroutine
- Unity에서 코루틴은 특정시점에서 작동을 멈출수 있는 함수를 말합니다.
- 멈추고 다시 동작을 재개할 때까지 걸리는 시간은 다양하게 설정할 수 있습니다.
    - ex: 다음 프레임, 특정 초 이후, 특정 조건이 만족할때

## How to use coroutine
- 사용법 자체는 간단합니다.
- 우선 System.Collections namespace를 using 합니다.
- 이후, 기존에 있던 함수의 return type을 IEnumerator로 바꾸고, 멈추고 싶은 시점에 yield statement를 사용하여 해당 함수를 코루틴 함수로 바꾼 뒤, StartCoroutine method를 통해 해당 코루틴 함수를 호출하시면 됩니다.
``` c#
// example of using coroutine
using System.Collections;
... // some codes
IEnumerator functionName() {
    for (int i = 0; i < 10; i++) {
        textObject.text = i;
        yield return null;
    }
}
... // some codes
void Awake() {
    ... // some codes
    StartCoroutine("functionName");
}
```

## Yield statements
- 다양한 yield statement를 통해 언제 재개할지 설정할 수 있습니다.
- yield return null;
    - 다음 프레임까지 기다림
- yield return new WaitForSeconds(1f);
    - 게임 시간으로 1초 기다림(time scale에 영향받음)
- yield return new WaitForSecondsRealtime(1f);
    - 실제 시간으로 1초 기다림(time scale에 영향받지 않음)
- yield return new WaitForFixedUpdate();
    - 다음 FixedUpdate 끝날 때까지 기다림
- yield return new WaitForEndOfFrame();
    - 다음 프레임의 Update와 모든 렌더링이 끝날 때까지 기다림
- yield break;
    - 현재 처리 중인 코루틴 함수를 나감
- yield return new WaitUntil (System.Func<Bool> predicate);
    - 주어진 predicate이 true가 될때까지 기다림
- yield statement를 쓸때, new를 쓰게 되는데 -> 당연히 new를 쓸때마다 새로운 object가 생성되게 된다.
    - 즉, 위에 있는 yield statement를 쓰게 되면, yield statement가 call이 될때마다 새로운 object가 생성된다고 생각하면 됨
    - 그래서 보통 계속해서 반복적으로 동일한 yield statement를 사용할것이면, 미리 awake같은데에서 해당 object를 만들어두고, 만들어진 object 하나를 계속해서 쓰는게 훨씬 좋다.

## How to pass arguments
- 코루틴 함수에게 argument를 보내는 방법은 크게 3가지가 있습니다.
- Argument가 없는 경우
    - 이런 경우에는 위에 예제에서 사용했던것 처럼, string value안에 함수의 이름을 적어서, StartCoroutine()에 보내시면 됩니다.
    - ex: StartCoroutine(“functionName”);
- Argument가 1개인 경우
    - Argument가 없는 경우의 사용법과 동일하며, StartCoroutine()의 두번째 argument로 코루틴 함수의 argument를 전달하시면 됩니다.
    - ex: StartCoroutine(“functionName”, argA);
- Argument가 여러 개인 경우
    - 함수의 이름을 string value로 전달하는 것이 아니라, 코루틴 함수를 여러 개의 argument들로 호출한 후, 해당 함수의 return value를 StartCoroutine()의 argument로 전달하시면 됩니다.
    - ex: StartCoroutine(functionName(argA, argB, argC));

## Coroutine을 사용할 때 주의할 점
- 코루틴을 실행시키는 오브젝트가 disable 되면, 이미 실행된 coroutine은 멈추게된다.
    - 근데 언제 멈추는지 정해져있지 않아서, 그냥 코루틴이 망가지게 된다고 생각하면 됨
- 그래서 코루틴을 사용할때 주의할 점은, 코루틴을 실행시키는 object는 반드시 disable되지 않아야한다
    - 그래서 보통 coroutine을 담당하는 manager를 만들거나, 아니면 절대로 disable안되는 manager같은 곳에서 해당 coroutine을 실행시키는 식으로 구현한다.
- ex: dialogue popup에 coroutine을 부여하고 싶은 경우, dialogue popup에서 coroutine을 실행시키지말고, 다른 manager에서 coroutine을 시켜야한다는 뜻이다
    - 왜냐면 dialogue popup은 특정상황에서 coroutine이 실행되는 도중에 disable 될 수도 있기 때문이다.

## When to use coroutines
- 다양한 상황에서 사용할 수 있지만, 다음은 코루틴 함수가 사용되는 대표적인 상황들입니다.
- 특정한 주기를 기반으로 반복적으로 실행되는 상황
- 특정 조건이 만족되어야 실행되는 상황
- 그래서 보통 코루틴은 반복문으로 만들고, Awake나 Start method에서 call을 한다

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}