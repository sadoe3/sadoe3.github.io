---
title: "Unity 강의 - Day 2"

categories:
    - unity-lecture

tags:
    - [Game Engine, Unity]

toc: true
toc_label: "목차"
toc_sticky: true

date: 2021-10-06
---

전주정보문화산업진흥원에서 진행하는 **게임콘텐츠(Unity3D) 제작 실무자 양성과정** 강의를 듣고 정리한 필기입니다.
{: .notice--warning}


## Layout 설정
- Unity의 layout은 개발자가 원하는대로 변경할 수 있으며, 이러한 변경사항은 custom layout으로 저장 할 수 있다.
- 만약 사용 중인 layout에 있던 특정 window를 닫았다가 다시 사용하고 싶은 경우 -> window -> general 에서 다시 불러올 수 있다.

## Project 폴더
- Project 폴더를 빠르게 찾는 방법
    1. Assets or Packages 폴더에 있는 아무 파일을 클릭 
    2. 우클릭 후, show in explorer 선택
- 사실 Project 폴더에는 다양한 sub folder들이 있지만, Unity에서는 setting과 관련된 폴더들은 숨김쳐리 되어, Assets과 Packages 폴더만 보인다.
- Project 폴더 안에 있는 파일만 프로젝트에 사용할 수 있다.

## Assets 폴더
- 유니티에서 사용하는 모든 asset 파일들은 종류에 맞는 폴더들을 만들어서 관리하는 것이 좋다.

## 외부 파일을 프로젝트에 import시키는 방법
- 해당 파일을 Assets 폴더에 Drag & Drop 하면 된다. 이때, 해당 파일은 복사됨.
- 이후 해당 파일을 원하는 오브젝트에 Drag & Drop 하면 적용시킬 수도 있다. (3D texture는 2D texture와는 다르게 약간 특이하게 생김)
- 파일 뿐만 아니라, 폴더 자체를 import 시키는 것도 가능하며, 이때에도 동일한 방법을 사용한다.

## Prefab
- Prefab이란 특정 컴포넌트들이 적용된 여러 오브젝트들을 하나의 asset의 형태로 만든 것이다.
- 즉, 하나의 asset이기 때문에, 원할때마다, template 처럼, 처음에 정한 그 설정 그대로 계속 사용할 수 있다
- 만드는 방법
    1. empty object를 만든다.
    2. 여러 오브젝트들의 components들을 알맞게 설정한다.
    3. 해당 오브젝트들을 알맞을 hierarchy로 설정한 뒤, empty object에 넣는다.
    4. empty object를 Assets 폴더에 있는 Prefabs 폴더에 drag & drop한다. (해당 폴더가 없다면 만들면 된다.)
- 파란색 글씨로 나오는 오브젝트가 prefab으로 만든 오브젝트이고, 검정색 글씨로 나오는 오브젝트가 일반 오브젝트이다.
- 편집하는 방법
    1. Prefabs 폴더에서 특정 prefab 파일을 선택
    2. 더블클릭 or 우클릭 후 open 선택
    3. 편집화면이 나오게되는데, 그곳에서 알맞게 편집하고 저장하면, 이전에 적용된 모든 prefab 오브젝트들이 동일하게 변경됨
    4. 이후, scene window 왼쪽 상단에 Scenes 버튼을 누르면, 원래 Scene 화면으로 돌아오게 됨

## Unity Manual & Scripting Reference
- 스크립팅을 하다가 혹은 유니티를 전반적으로 사용하다가, 잘 모르는 부분이 생기면, [여기](https://docs.unity3d.com/ScriptReference/)에서 자세한 사용법을 알 수 있다.

## Scene 파일
- Scene 파일에는 특정 맵에 필요한 모든 오브젝트들이 들어가게 된다.
- 이때 주의할 점은 Scene 파일은 해당 오브젝트들의 위치값만 가지고 있을 뿐이기 때문에, Scene파일을 옮기고 싶으면 Scene 파일에 들어간 모든 오브젝트들도 같이 옮겨줘야 한다.
- 대규모 게임일 경우, Scene 파일 하나에 몇 천개의 오브젝트가 사용되기도 한다.

## 최적화
- 게임에 사용되지 않는데, project에 존재하는 파일들이 많을 수록, 게임의 용량이 증가된다.
- 이러한 파일들을 줄이는 작업들도 최적화의 일부라고 볼 수 있다.

## 화면이 환해지는 현상
- Light 오브젝트가 여러개 있으면, 화면이 밝게 보이는 현상이 발생한다.
- 이를 해결하기 위해선, 불필요한 Light 오브젝트들을 제거하면 된다.

## Console window
- 게임이 플레이 되는 동안 log를 확인 할 수 있음
- Scripting 할때 많이 사용하게 됨

## Pivot or Center
- Center는 오브젝트의 실제 중앙점을 기준으로 rotation을 진행함
- Pivot은 오브젝트의 가상의 중앙점을 기준으로 rotation을 진행함(이때, 가상의 중앙점의 위치는 변경 가능하다)

## 좌표계
- Global 좌표계는 모든 오브젝트가 동일한 원점(0,0,0)을 사용한다고 약속하고, 오브젝트를 움직임
- Local 좌표계는 선택된 특정 오브젝트의 중앙점을 원점(0,0,0)으로 사용한다고 약속하고, 오브젝트를 움직임

## Git 혹은 다른 형상관리도구의 장점
 - 여러명의 개발자가 동시에 병렬로 작업하는 것이 가능하게 됨
 - 버전별로 파일들을 관리하기 때문에, 현재 파일들 중 일부가 사라져도 다시 복구할 수 있음

## Texture, Material and Shader
- Texture는 화면에 실질적으로 보이는 비트맵 이미지임
- Shader는 조명 입력과 material 설정에 따라 렌더링된 각 픽셀의 컬러를 계산하는 수학 계산식과 알고리즘을 포함하는 작은 스크립트임
- Material은 사용되는 texture에 대한 레퍼런스, 타일링 정보, 컬러 틴트 등을 포함하여 표면을 렌더링하는 방법을 정의함
    - 강사님은 material을 texture + shader의 개념으로 이해하면 된다고 하셨음

## Sound 파일을 적용하는 방법
- 일반적인 외부파일을 적용시키는 것과 동일함
- 즉, Drag & Drop을 이용하여, assets 폴더로, 특정 오브젝트로 적용시키고, 알맞게 property 설정을 해주면 됨

## Inheritance
- 일반적인 상속을 구현하는 과정인 base class를 구현하고, 이를 바탕으로 derived class 구현하는 방법을 정반대로 하여, derived class들을 만들고, 이들이 공통되는 부분들로 base class를 만들 수 도 있다.
- 이는 기존에 있는 class들 중 공통이 되는 부분을 새로운 base class로 만들어, 가존에 작성된 코드를 좀더 발전시키는 refactoring의 일부라고 할 수 있다.

## Component Pattern
- Empty object에서 미리 만들어진 component들을 조합하여 게임 오브젝트를 만드는 방식
- Unity의 component들은 서로 독립적으로 작동함 (이는 곧 서로에 대한 의존도가 낮다고 볼 수 있음)
- 하지만 서로 독립적으로 작동하기에, 특정 상황에서 debug를 하기 어려운 경우도 생김

## Broadcasting
- Broadcasting이란, Unity가 특정 메소드를 실행시키라는 메시지를 모든 컴포넌트들에게 보내는 것이다.
- 이때, 해당 메소드를 갖고 있는 컴포넌트들만 반응하고, 나머지는 이 메시지를 무시하게된다.

## MonoBehaviour
- Unity의 모든 component들은 MonoBehaviour라는 클래스로부터 상속하게 된다.
- 이러한 특징을 이용하여, Unity는 MonoBehaviour 클래스에 있는 명령을 broadcasting 함으로써, 모든 components들을 관리할 수 있게된다.

## Script Tool 설정 방법
- Edit -> Preferences -> External Tools -> 알맞은 editor를 선택하면 된다.
- 만약 VS Code를 선택했다면, extension으로 Unity Code Snippets 라는 것을 사용하면 자동완성기능을 이용할 수 있다. (완벽하진 않지만 충분히 도움이 된다.)

## Script file name
- Script file의 이름은 자유롭게 설정해도 되지만, 보통 ObjectNameController 라는 느낌으로 설정해준다.

## Script를 만드는 방법
- 첫번째 방법
    1. 특정 오브젝트를 선택
    2. Add Component를 선택
    3. 원하는 스크립트의 이름을 적고 enter를 누름
    4. 그러면 editor가 켜지게 되고, scripting을 진행하면 됨
- 두번째 방법
    1. Assets 폴더로 가서 Scripts 폴더를 만든다.
    2. Scripts 폴더의 빈공간에 우클릭을 누르고, Create -> C# Script를 선택
    3. 이후 이름을 알맞게 설정하고, 해당 파일을 더블클릭하여, editor를 켜고 scripting을 진행하면 됨

## Scripting 자동완성
- 위에서 설명한 것 처럼, Unity Code Snippets라는 extension을 설치하면, VS Code에서 Unity Scripting을 할 때 자동완성 기능을 사용 할 수 있다.
- 다만, 이러한 자동완성기능을 계속해서 사용하기 위해선, 해야할 행동들이 있다.
    1. Unity에서 수정하고 싶은 Script 더블 클릭
    2. VS Code 창이 뜨면, 바로 scripting하러 가지 말고, 우선 VS Code 상단에 어떤 Project에 해당 script를 적용시킬지를 물어보는 리스트가 뜬다.
    3. 이때 sln파일을 선택하고 script를 저장하면, 이때 부터 자동완성 기능을 사용할 수 있게 된다.
- 이러한 번거러운 행동은 시스템을 처음 시작할 때마다 해야하는 것 같다.
    - 즉, 시스템을 부팅 후, script에 대한 project를 한번 설정해 놓으면, 시스템을 재시작할 때까지는 동일한 project의 scripting을 진행할 때, project 선택 리스트가 뜨지 않는다는 의미이다.

## Scripting과 관련된 정보들
- Script를 작성하면, 이를 특정 오브젝트에 컴포넌트의 형식으로 적용시킨다.
- 즉, Script를 작성한다는 것은 Custom Component를 만드는 것과 같다는 의미이다.
- Script에서 로그를 남기는 방법
    - Debug.Log("This is log")
    - Debug.Log("string" + variable_name) 의 형태로 서로 다른 자료형의 데이터들도 출력 가능하다 (즉, variable_name이 string type이 아니여도 출력 가능하다는 의미이다)
    - 이는 테스트 할 때, 많이 사용됨
    - Update() method에 두게되면, 여러번 찍히게되는 log를 unity가 하나만 보여주는 경우가 있다. 이런 경우 Collapse를 누르면, 모든 log를 확인할 수 있다.
- C#에서 using directive는 using 뒤에 나오는 namespace를 접근하겠다라는 기능을 수행한다.

## Default access modifier
- Unity에서 script를 만든 후, 해당 script가 자동적으로 만든 class 의 default access modifier는 private 이다.
- 즉, access modifier를 입력하지 않은 경우, 모든 property와 method는 private의 access modifier를 갖게 된다.

## Naming convention
- Unity script의 naming convention은 다음과 같다.
- Class, Method: camelBack Case
    - ex) ThisIsClass, GetValue
- Property: Pascal Case
    - ex) ex)variableName

## MonoBehaviour methods
- Monobehaviour를 상속한 일반적인 script내의 class에서 특정 상황에 call이 되는 대표적인 method들은 다음과 같다
    - 
    ```c# 
    void Start() { ; } // Start is called on the frame when a script is enabled just before any of the Update methods are called the first time
    void Update() { ; } // Update is called every frame, if the MonoBehaviour is enabled
    void OnDestroy() { ; } // OnDestroy occurs when a Scene or game ends
    ```

## C#에서 generic class에 대한 type을 적는 방법
```c#
Method<TypeName>(); // 1st method
Method() as TypeName; // 2nd method
```

## Execution order of Unity event functions
- Awake(), Start() 같이 Unity에서 특정 상황에 호출 되는 함수를 Unity event function이라고 한다.
- [이곳](https://docs.unity3d.com/Manual/ExecutionOrder.html)을 참고하면, 이 함수들의 실행 순서를 확인할 수 있다.
- 알면 좋은 내용들
    - Awake()가 Start()보다 먼저 실행되기 때문에, initialization을 진행할 때, 이를 기반으로 코드를 작성해주면 좋다.
    - 여러 script의 Awake()들은 어떤 순서로 실행되는지 일반적인 경우 알 수 없다.
    - 이를 해결하기 위해선, 특정 Awake()의 내용을 Start()에 넣는식으로 실행순서를 정하거나, 아니면 script들의 실행순서를 임의로 정해주면 된다.
        - 정하는 방법은 다음과 같다: project setting -> script execution order -> 알맞게 순서를 설정하면 됨

## Difference between this and gameObject
- 보통 script를 Unity에서 사용할 때에는 특정 object에 해당 script를 component로 추가하여 사용하게 된다.
- 해당 오브젝트를 ObjectA라고 하고, script 파일의 이름을 ScriptA라고 하자.
- 이때, Script에서 Destroy(this)를 하게 되면, ObjectA에 있는 ScriptA Component가 없어진다.
- 또한, Destroy(gameObject)를 하게 되면, ObjectA가 없어진다.
- 즉, this는 해당 script가 오브젝트에 적용될때의 component를 가르키는 것이고, gameObject는 해당 script가 오브젝트에 적용될 때의 해당 object를 가르키는 것이다.

## 특정 object의 이름을 script에서 확인하는 방법
- objectName.transform.name을 통해 확인 할 수 있다. 

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}