---
title: "Project 1: Threads"

categories:
    - pintos

tags:
    - [Operating Systems, PintOS, Linux, thread, alarm clock, priority, scheduling, sleep]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2025-04-03
---

# Enhancing PintOS with Alarm Clock and Priority Scheduling
- The first project contains key enhancements to the PintOS operating system.
    1. Optimizing the alarm clock mechanism.
    2. Implementing priority-based scheduling with preemption and priority donation.
- Below, I detail the objectives, problems, solutions, and implementations for each part.


## Part 1: Alarm Clock
- Enhancing `timer_sleep()`

### Objective
- The goal is to optimize `timer_sleep()` in PintOS by replacing **busy waiting** with a **sleep/wakeup** mechanism,
    * using the `THREAD_BLOCKED` state and a new `sleep_list` to manage sleeping threads efficiently.

### Current Problem
- The original `timer_sleep()` system call pauses a process for a specified number of `ticks` using **busy waiting**


<details>
<summary>Click to see the original code</summary>

```c
void
timer_sleep (int64_t ticks) 
{
  int64_t start = timer_ticks ();

  ASSERT (intr_get_level () == INTR_ON);
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
}
```
</details>

* It repeatedly checks the time in a loop.
* If the wake-up time hasn’t arrived, it calls `thread_yield()`, setting the thread to `THREAD_READY`.
* If no other threads are in `ready_list`, the same thread is rescheduled as `THREAD_RUNNING`.
    * This cycle wastes CPU resources.


### Solution

I reimplemented `timer_sleep()` to:

- Use `THREAD_BLOCKED` to suspend threads.
- Introduce a `sleep_list` to track sleeping threads.
- On `timer_sleep()` call:
  - Add the thread to `sleep_list` via `thread_sleep()`.
  - Periodically check the time.
  - Move the thread to `ready_list` via `thread_wakeup()` when the time is up.

### Implementation Details

#### Files and Functions Modified/Added

- **`timer.c`**
  - **`timer_sleep()`**
    - Replaced `thread_yield()` with `thread_sleep()`.
    - *Code placeholder: [Insert your `timer_sleep()` code here]*
  - **`timer_interrupt()`**
    - Added a call to `thread_wakeup()` with `timer_ticks()` value.
    - *Code placeholder: [Insert your `timer_interrupt()` code here]*

- **`thread.c`**
  - **`thread_init()`**
    - Initialized `sleep_list`.
    - *Code placeholder: [Insert your `thread_init()` code here]*
  - **`thread_wakeup()`**
    - Moves threads from `sleep_list` to `ready_list` when their time arrives.
    - *Code placeholder: [Insert your `thread_wakeup()` code here]*
  - **`thread_sleep()`**
    - Sets the thread to `THREAD_BLOCKED` and adds it to `sleep_list`.
    - *Code placeholder: [Insert your `thread_sleep()` code here]*
  - **`static struct list sleep_list`**
    - New list for sleeping threads.
    - *Code placeholder: [Insert your `sleep_list` declaration here]*

- **`thread.h`**
  - **`struct thread`**
    - Added `int64_t tick_wakeup` for wake-up time.
    - *Code placeholder: [Insert your `struct thread` modification here]*

### Conclusion

This modification eliminates busy waiting, improving CPU efficiency in Pintos.

## Part 2: Priority - Implementing Priority Scheduling and Preemption

### Objective

The aim is to replace Pintos’ FIFO scheduling with a priority-based system and add preemption to prioritize high-priority threads effectively.

### Current Problem

- **FIFO Scheduling**: Threads are added to `ready_list` in arrival order, ignoring priority.
- **No Preemption**: High-priority threads wait for manual `thread_yield()` calls, delaying execution.

### Priority Basics

- **Range**: `PRI_MIN (0)` to `PRI_MAX (63)`, default `PRI_DEFAULT (31)`.
- **Functions**:
  - `thread_set_priority(int new_priority)`: Sets priority.
  - `thread_get_priority(void)`: Gets priority.

#### Priority Inversion

Example:
1. **Thread A** (high) waits for a lock held by **Thread B** (low).
2. **Thread C** (medium) preempts **Thread B**.
3. **Thread A** is delayed by **Thread C**.

##### Priority Donation

- **Thread B** inherits **Thread A**’s priority, preventing **Thread C** from preempting it.
- **Nested Donation**: Priority propagates through lock chains.
- **Multiple Donation**: Retains the highest priority among multiple waiters.

### Solution

#### Main Logic

- **Creation/Unblocking**:
  - Compare priorities; call `thread_yield()` if the new/unblocked thread has higher priority.
  - Insert into `ready_list` in priority order otherwise.
- **Abstraction**:
  - `thread_unblock()` only inserts into `ready_list`.
  - Higher-level functions (e.g., `thread_create()`) handle `thread_yield()`.
- **Timer Preemption**:
  - Use `intr_yield_on_return()` during interrupts.

#### Priority Donation

- Added `donors` and `wait_on_lock` to `struct thread`.

### Implementation Details

#### Files and Functions Modified/Added

- **`thread.c`**
  - **`thread_sleep()`**
    - Prioritizes threads in `sleep_list`.
    - *Code placeholder: [Insert your `thread_sleep()` code here]*
  - **`thread_wakeup()`**
    - Wakes threads based on priority and ticks.
    - *Code placeholder: [Insert your `thread_wakeup()` code here]*
  - **`thread_yield()`**
    - Inserts into `ready_list` by priority.
    - *Code placeholder: [Insert your `thread_yield()` code here]*
  - **`thread_set_priority()`**
    - Manages donation and original priority.
    - *Code placeholder: [Insert your `thread_set_priority()` code here]*
  - **`init_thread()`**
    - Initializes `donors`, `wait_on_lock`, `original_priority`.
    - *Code placeholder: [Insert your `init_thread()` code here]*
  - **`thread_unblock()`**
    - Inserts into `ready_list` by priority.
    - *Code placeholder: [Insert your `thread_unblock()` code here]*
  - **`thread_create()`**
    - Triggers preemption if needed.
    - *Code placeholder: [Insert your `thread_create()` code here]*

- **`thread.h`**
  - **`struct thread`**
    - Added `tick_wakeup`, `lock_to_wait`, `original_priority`, `donors`, `donelem`.
    - *Code placeholder: [Insert your `struct thread` modifications here]*

- **`synch.c`**
  - **`sema_down()`**
    - Inserts into waiters list by priority.
    - *Code placeholder: [Insert your `sema_down()` code here]*
  - **`sema_up()`**
    - Sorts waiters and checks preemption.
    - *Code placeholder: [Insert your `sema_up()` code here]*
  - **`semaphore_elem`**
    - Added priority field.
    - *Code placeholder: [Insert your `semaphore_elem` modification here]*
  - **`cond_wait()`**
    - Orders waiters by priority.
    - *Code placeholder: [Insert your `cond_wait()` code here]*
  - **`lock_acquire()`**
    - Handles donation and lock tracking.
    - *Code placeholder: [Insert your `lock_acquire()` code here]*
  - **`lock_release()`**
    - Manages donor removal and priority restoration.
    - *Code placeholder: [Insert your `lock_release()` code here]*

### Conclusion

This enhancement introduces priority scheduling, preemption, and priority donation, making Pintos more responsive and efficient.

## Final Thoughts

Together, these improvements transform Pintos into a more robust OS, optimizing resource use and thread management.


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}