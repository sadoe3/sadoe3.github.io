---
title: "Unreal Engine 5 : How to Implement a Matchmaking System"

categories:
    - ue5

tags:
    - [Game Engine, Unreal Engine 5, Multiplayer, Matchmaking]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2025-01-08
---

# Unreal Engine 5 : Chapter 4


## Implement a Matchmaking System

### Step 1 : Create a Queue Class
Create a C++ class to manage the player queue

1. **Create the Class:**
   - In the `Unreal Editor`, go to `Tools` -> `New C++ Class`
   - Select `None` as the **parent class**
   - Name it `APlayerQueueManager`

2. **Define the Class:**
   ```cpp
   #pragma once

   #include "CoreMinimal.h"
   #include "PlayerQueueManager.generated.h"

   UCLASS()
   class YOURGAME_API APlayerQueueManager : public AActor {
       GENERATED_BODY()
   public:
       APlayerQueueManager();

       void addPlayerToQueue(APlayerController*);
       void removePlayerFromQueue(APlayerController*);
       // Match players and start the game
       void matchPlayers();

   private:
       constexpr int32 MIN_PLAYERS_TO_START = 2;
       // Queue of player controllers
       TArray<APlayerController*> playerQueue;
   };
   ```

3. **Implement the Class:**
   ```cpp
   #include "PlayerQueueManager.h"
   #include "GameFramework/PlayerController.h"

   APlayerQueueManager::APlayerQueueManager() {}

   void APlayerQueueManager::addPlayerToQueue(APlayerController* playerController) {
       if (playerController && !playerQueue.Contains(playerController)) {
           playerQueue.Add(playerController);
           // make a log for test purpose
           UE_LOG(LogTemp, Log, TEXT("Player added to queue. Current queue size: %d"), playerQueue.Num());

           if (playerQueue.Num() >= MinPlayersToStart)
               MatchPlayers();
       }
   }

   void APlayerQueueManager::removePlayerFromQueue(APlayerController* playerController) {
       if (playerController) {
           playerQueue.Remove(playerController);
           UE_LOG(LogTemp, Log, TEXT("Player removed from queue. Current queue size: %d"), playerQueue.Num());
       }
   }

   void APlayerQueueManager::matchPlayers() {
       if (playerQueue.Num() >= MinPlayersToStart) {
           UE_LOG(LogTemp, Log, TEXT("Match starting with %d players!"), playerQueue.Num());

           // Logic to start the match, such as opening a new level
           for (APlayerController* currentPlayer : playerQueue) {
               if (currentPlayer)
                   currentPlayer->ClientTravel("/Game/Maps/YourMatchMap", ETravelType::TRAVEL_Absolute);
           }

           // Clear the queue after starting the match
           playerQueue.Empty();
       }
   }
   ```

### Step 2: Integrate the Queue into Your GameMode
Implement the custom `GameModeBase` class to use the queue system

1. **Create the UI Widget Blueprint**
- First, we'll create a `UI Widget Blueprint` to handle the display of the queue status and wait time
    - **Create a new Widget Blueprint**
        * Right-click in the `Content Browser` and go to `User Interface` -> `Widget Blueprint`
        * Name it something like `BP_QueueStatusWidget`
    - **Design the Widget**
        * Open the newly created widget (`BP_QueueStatusWidget`)
        * In the designer, drag two `Text` blocks into the canvas
            + One will display the **queue status**
            + One will display the **estimated wait time**
    - **Bind the Text**:
        * For both text blocks, you can bind the text dynamically using `Blueprint` or `C++`
        * For now, let's focus on binding them via C++ so we can update them as part of the queue logic

2. **Create a C++ Class to Manage the Queue UI**
Now, we'll modify the `GameMode` or a custom HUD class to manage and display the queue status and wait time on the UI
1. **Add a Reference to the Widget in Your Game Mode**:

   In your `GameModeBase` (or another class, like `PlayerController`), you need to reference the `QueueStatusWidget` to display it.

   Update the `AYourGameModeBase` to include this reference:

   ```cpp
   #include "Blueprint/UserWidget.h"
   #include "BP_QueueStatusWidget.h"

   class YOURGAME_API AYourGameModeBase : public AGameModeBase {
       GENERATED_BODY()
   public:
       virtual void postLogin(APlayerController* newPlayer) override;

       // Update queue status in UI
       void UpdateQueueUI();

   private:
       APlayerQueueManager* queueManager;
       TSubclassOf<UUserWidget> QueueStatusWidgetClass; // Reference to widget class
       UUserWidget* QueueStatusWidget; // Instance of the widget

       int32 QueuePosition;
       float EstimatedWaitTime; // In minutes or seconds
   };
   ```

2. **Spawn and Display the Widget in `postLogin`**:

   In the `postLogin` function, we'll spawn and display the widget when a player joins the game.

   ```cpp
   void AYourGameModeBase::postLogin(APlayerController* newPlayer) {
       Super::postLogin(newPlayer);

       if (!queueManager)
           queueManager = GetWorld()->SpawnActor<APlayerQueueManager>();

       if (queueManager)
           queueManager->AddPlayerToQueue(newPlayer);

       // Check if Queue Status Widget is already created
       if (!QueueStatusWidget) {
           if (QueueStatusWidgetClass) {
               QueueStatusWidget = CreateWidget<UUserWidget>(newPlayer, QueueStatusWidgetClass);
               if (QueueStatusWidget) {
                   QueueStatusWidget->AddToViewport();
               }
           }
       }
   }
   ```

3. **Update the Queue UI Dynamically**:

   Implement the logic to update the `QueueStatusWidget` based on changes in the queue system. For example, as players are added or removed from the queue, the position and wait time need to be updated.

   ```cpp
   void AYourGameModeBase::UpdateQueueUI() {
       if (QueueStatusWidget) {
           // Assuming you have access to the QueueManager, get position and wait time
           QueuePosition = queueManager->GetPlayerQueuePosition(); // Assuming you implement this
           EstimatedWaitTime = queueManager->GetEstimatedWaitTime(); // Implement this too

           // Assuming the widget has methods to update text, use bindings or set text directly
           // Example of direct text setting, though binding is preferred:
           UTextBlock* QueueStatusText = Cast<UTextBlock>(QueueStatusWidget->GetWidgetFromName("QueueStatusText"));
           UTextBlock* WaitTimeText = Cast<UTextBlock>(QueueStatusWidget->GetWidgetFromName("WaitTimeText"));

           if (QueueStatusText) {
               QueueStatusText->SetText(FText::Format(FText::FromString("Position: {0}"), QueuePosition));
           }
           if (WaitTimeText) {
               WaitTimeText->SetText(FText::Format(FText::FromString("Estimated wait: {0} minutes"), FText::AsNumber(EstimatedWaitTime)));
           }
       }
   }
   ```



### 4. **Update Queue Position and Wait Time in Real-Time**

To make sure the UI updates in real-time as the queue progresses, you should periodically call `UpdateQueueUI()` whenever there's a change in the queue.

This could be done when a player joins or leaves the queue, or you could implement a timer to periodically update the status while the player remains in the queue.

### Step 3 : Test the Queue System
1. Run the game in multiplayer mode
2. Add players to the game and observe how they are queued
3. Verify that the game starts automatically when the required number of players join




## Extra Details

### How to implement a text box for IP address only
1. **Create a Custom Widget Class**
    - Create a new class derived from `UUserWidget` for your widget
    - You can create it through `Tools` -> `New C++ Class...` -> select `UserWidget` as parent class
        ```cpp
        // header file
        UCLASS()
        class YOURPROJECT_API UCustomIPInputWidget : public UUserWidget {
            GENERATED_BODY()

        public:
            UPROPERTY(meta = (BindWidget))
            class UEditableTextBox* IPAddressInputBox;

            virtual void NativeConstruct() override;
        private:
            UFUNCTION()
            void OnIPAddressTextChanged(const FText& Text);
        };
        ```

2. **Implement Input Validation**
    - In the `.cpp` file
        ```cpp
        // cpp file
        void UCustomIPInputWidget::NativeConstruct() {
            Super::NativeConstruct();
            if (IPAddressInputBox)
                IPAddressInputBox->OnTextChanged.AddDynamic(this, &UCustomIPInputWidget::OnIPAddressTextChanged);
        }

        void UCustomIPInputWidget::OnIPAddressTextChanged(const FText& Text) {
            FString Input = Text.ToString();
            FString ValidInput;

            // Allow only digits and '.' in the input
            for (TCHAR Character : Input) {
                if (FChar::IsDigit(Character) || Character == '.')
                    ValidInput.AppendChar(Character);
            }

            // Replace the text in the box with valid input
            if (Input != ValidInput && IPAddressInputBox)
                IPAddressInputBox->SetText(FText::FromString(ValidInput));
        }
        ```

3. **Compile and Attach**
    - Select the `TextBox` on the `Canvas`
    - Check the `Is Variable` checkbox
    - Go to `Graph`
    - Click `Class Settings` located on the Main Toolbar
    - Set its parent class as `UCustomIPInputWidget`
        * This makes the `UI blueprint` inherit the logic from this custom C++ class
    - Add it to the viewport in your game



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}