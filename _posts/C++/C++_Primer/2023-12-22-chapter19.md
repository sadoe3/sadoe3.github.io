---
title: "Chapter 19"

categories:
    - cpp

tags:
    - [C++, Programming Language, memory allocation, RTTI, enum, pointer to class member, nested class, union, local class, bit-field, volatile]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-22
---

# Specialized Tools and Techniques

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Controlling Memory Allocation

### temp
temp
- temp


## Run-Time Type Identification

### temp
temp
- temp


## Enumerations
**Enumerations** let us group together sets of **integral** constants
- like classes, each enumeration defines a new type
    * and they are **literal** types

### Scoped and Unscoped Enumerations
C++ has 2 kinds of enumerations
- **scoped** enumerations
    ```c++
    // example of scoped enumerations
    enum class Color { RED, GREEN, BLUE };
    Color a = RED;              // error;
    Color a = Color::RED;       // ok;
    ```
    * the `class` keyword can be changed to `struct`
    * **enumerator** is the value defined inside the enumeration body
- **unscoped** enumerations
    ```c++
    // example of unscoped enumerations
    enum Color { RED = 6, GREEN, BLUE };    // GREEN = 7, BLUE = 8
    Color a = BLUE;              // ok;
    Color a = Color::BLUE;       // ok;
    ```
    * the **unscoped** enumerations may have the **empty** name
- by default, enumerator values start at 0 and each enumerator has a value 1 greater than the preceding one 
- enumerators are `const`
    * and, if they are initialized, their initializers must be **constant expressions**
    * consequently, each enumerator is itself a **constant expression**
- note that you **cannot redefine** the enumerators in the same scope
    ```c++
    enum Color { RED, GREEN, BLUE = 3 };
    enum RGB { RED, GREEN, BLUE = 3 };              // error; redefine enumerators
    enum class ScopedRGB { RED, GREEN, BLUE = 3 };  // ok; enumerators are hidden

    constexpr Color eyes = BLUE;                      // ok;
    constexpr Color eyes = 3;                         // error; wrong type; int is used
    constexpr ScopedRGB eyes = BLUE;                  // error; wrong type; Color::BLUE is used
    constexpr ScopedRGB eyes = ScopedRGB::BLUE;       // ok;
    ```
    * also note that although two different enumerations have enumerator which contains the same name, the two enumerators are different because the two enumerations are different types
        + same rule is applied to the built-in types (espeically for `int`) as well
        + although the enumerator has the same value as the `int` literal, they are different
- although each `enum` defines a unique type, it is represented by one of the built-in integral types
    * and, we may specify that type by following the `enum` name with a colon and the name of the type we want to use
    ```c++
    enum IntValues : unsigned long long { charType = 255, shortType = 65535 };
    ```
    * if we do not specify the underlying type, then by default the **scope** `enum`s have `int` as the underlying type
    * there is **no default** for **unscoped** `enum`s
        + we just know that the underlying type is large enough to hold the enumerator values
    * it's an error for an enumerator to have a value that is too large to fit in that type when the underlying type is specified (including implicitly specified for a scoped `enum`)
    * with this feature, we can be confident that our program compiled under one implementation will generate the same code when we compile it on another
- we can **forward declare** an `enum`
    ```c++
    enum IntValues : unsigned long long;
    enum struct ScopedRGB;      // uses int by default
    ```
    * an `enum` forward declaration must specify (implicitly or explicitly) the underlying size of `enum`
    * the size of the `enum` must be the same across all declarations and the `enum` definition
    * moreover, we **cannot** declare a name as an unscoped `enum` in one context and **redeclare** it as a scoped `enum` later

## Pointer to Class Member

### temp
temp
- temp


## Nested Classes
A class can b defined within another class
- such a class is a **nested class**, also referred to as a **nested type**

### Enclosing Class and Nested Class
The enclosing class and the nested class are **independent** and **unrelated** to each other
- the object of the enclosing type doesn't have the member of the nested type, and vice versa

### Visibility of the Nested Class
The name of the nested class is visible **only within** its enclosing class scope but **not outside** the class scope
- hence, the main purpose of the nested class is mostly related to the implementation of the enclosing class
- the enclosing type can specify the **access level** to the nested type
    * a nested class defined in the `public` part
        + may be used anywhere
    * a nested class defined in the `protected` part
        + is accessible only by the enclosing class, its friends, and its derived classes
    * a nested class defined in the `private` part
        + is accessible only to the members and friends of the enclosing class

### Declaring Inside and Defining Outside
Like other members, it's possible for the enclosing class to declare the nested class inside and define it outside
```c++
class Enclosing {
public:
    class Nested;       // declares the nested class
    // other members
};
class Enclosing::Nested {       // defines the nested class outside the enclosing class definition
    static int static_member;       // static member
    // other members
}
int Enclosing::Nested::static_member = 1;   // defines the static member
```
- note that until the actual definition of a nested class that is defined outside the class body is seen,
    * that calss is an **incomplete** type


## Local Classes
A class can be defined a function body
- such a class is called a **local class**
- the concept is similar to the **nested class**
    * but it's more **restricted**

### Restrictions of Local Classes
- all the members of the local class must be **completely** defined inside the class body
- the local classes **cannot** have `static` members
- they **cannot** access to the local objects in the same function scope
    * however, it's possible for them to access to the global objects or `static` local objects 

### Other Features
- it's possible to define **local enumerations**
- also, it's possible to define the **nested local classes**


## union: A Space-Saving Class

### temp
temp
- temp


## Inherently Nonportable Features

### Bit-Fields
A class can define a (non`static`) dat amember as a **bit-field**
- the **bit-field** member holds a specified number of **bits**
- note that the memory layout of a **bit-field** is machine dependent

### Defining Bit-Fields
```c++
class ClassName {
public:
    unsigned a: 3;
    unsigned b: 1;
};
```
- the type of the bit-field members must be integral or enumeration type
    * ordinary, `unsigned` types are the best options
- you can specify the number of bits by placing `:` after the member followed by the number of bits
- the bit-field members aree accessed in the same way as the other members of a class
    * moreover, they supports the built-in bit-wise operations for sure


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}