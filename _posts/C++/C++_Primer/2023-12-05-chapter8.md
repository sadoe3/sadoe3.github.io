---
title: "C++ Primer : Chapter 8"

categories:
    - cpp

tags:
    - [C++, Programming Language, IO, Library]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-5
---

# The IO Library

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## The IO Types

### IO Library Types and Headers
- There are 3 streams which handles the IO
    * standard(plain) stream
        + it handles the IO regarding a **console window**
        + it's defined in `<iostream>` header
        + `cin` is an `istream` object that reads the input from the standard stream
        + `cout` is an `ostream` object that writes the output to the standard stream
        + `cerr` is an `ostream` object that writes the output, typically error messages, to the standard stream
    * file stream
        + it handles the IO regarding the **named file** 
        + it's defined in `<fstream>` header
    * string stream
        + it handles the IO regarding the **std::string object**
        + it's defined in `<sstream>` header
- the following shows the types defined in those headers
    |Header|Type|
    |:---:|:---|
    |`iostream`|`istream`, `wistream` reads from the standard stream|
    ||`ostream`, `wostream` writes to the standard stream|
    ||`iostream`, `wiostream` reads and writes to the standard stream|
    |`fstream`|`ifstream`, `wifstream` reads the file stream|
    ||`ofstream`, `wofstream` writes to the file stream|
    ||`fstream`, `wfstream` reads and writes to the file stream|
    |`sstream`|`istringstream`, `wistringstream` reads the string stream|
    ||`ostringstream`, `wostringstream` writes to the string stream|
    ||`stringstream`, `wstringstream` reads and writes to the string stream|
- by default, they manipulate `char` data
    * to support languages that use wide characters, the library defines a set of types and objects that manipulate `wchar_t` data
    * same concepts are applied to both of `char` verion and `wchar_t` version
- we cannot copy or assign objects of the IO types

### IO Operations
The types `ifstream` and `istringstream` **inherit** from `istream`, same thing happens for `ostream` as well
- therefore, we can ignore the differences among these different kinds of streams
- for all streams, we use `>>(input operators)` for input streams, and `<<(output operators)` for input streams, and `getline()` to read a line

### Condition States
You check whether the stream is **valid** or not by using the stream object as a **condition**

||I/O Library Condition State|
|:---:|:---|
|`stream::iostate`|`stream` is one of the IO types. `iostate` is a machine-dependent integral type that represents the condition state of a stream|
|`stream::badbit`|`stream::iostate` value used to indicate that a stream is corrupted|
|`stream::badbit`|`stream::iostate` value used to indicate that an IO operation failed|
|`stream::badbit`|`stream::iostate` value used to indicate that a stream hit end-of-file|
|`stream::badbit`|`stream::iostate` value used to indicate that a stream is not in an error state. this value is guaranteed to be zero|
|`s.eof()`|returns true if `eofbit` in the stream s is set|
|`s.fail()`|returns true if `failbit` in the stream s is set|
|`s.bad()`|returns true if `badbit` in the stream s is set|
|`s.good()`|returns true if the stream s is in a valid state|
|`s.clear()`|reset all condition values in the stream s to valid state. returns `void`|
|`s.clear(flags)`|reset the condition of s to `flags`. type of `flags` is `stream::iostream`. returns `void`|
|`s.setstate(flags)`|turn on the given condition. type of `flags` is `stream::iostate`. returns `void`|
|`s.rdstate()`|returns current condition of s as a `stream::iostate` value|

- but this checks only whether it's valid or not
- if you want to know more detailed information regarding the stream, you need to know the **condition states** of the stream
    * `badbit` indicates a system-level failure, such as an **unrecoverable** read or write error
        + once `badbit` is set, you can't no longer use the stream
    * `failbit` is set after a **recoverable** error, such as reading a character when numeric data was expected
    * reaching end-of-file sets `eofbit` 
        + if end-of-file doesn't follow the valid input, `failbit` is also set
    * `goodbit`, which is guaranteed to have the value 0, indicates no failures on the stream

### Flushing the Output Buffer
When we print the string to the standard stream, the string might be printed immediately, or the operating system might store the data in a **buffer** to be printed later for better performance
- there are several conditions that cuase the **buffer** to be flushed
    * the program completes normally. all output buffers are flushed as part of the `return` from `main`
    * at some indeterminate time, the buffer can become full, in which case it will be flushed before writing the next value
    * we can flush the buffer explicitly by using a flushing **manipulator**
        + there are 3 types of it
        + `flush` : flushes the buffer only; doesn't add any character
        + `endl` : adds the new line character and flushes the buffer 
        + `ends` : adds the null character and flushes the buffer 
    * we can use the `unitbuf` **manipulator** to set the stream's internal state to empty the buffer after each output operation.
        + By default, `unitbuf` is set for `cerr` so that writes to `cerr` are flushed immediately
        ```c++
        std::cout << std::unitbuf;          // all writes will be flushed immediately
        std::cout << std::nounitbuf;        // returns to normal buffering
        ```
    * an output stream might be tied to another stream
        + in this case, the output stream is flushed whenever the tied stream is read or written
        + by default, `cin` and `cerr` are both tied to `cout`
        + you can tie input or output stream to another output stream by calling `.tie()` method with the pointer to the output stream as an arugment
            - if you pass `nullptr`, you can untie them
            - calling `tie()` with empty parameter returns a pointer the output stream which is currently tied
- note that buffers are **not flushed** if the program **crashes**


## File I/O
File I/O is done by using types defined in `<fstream>` header

### Specific Operations of fstream
`fstream` has the operations of `iostream`, such as `>>(output operator)`, but also has its specific operations

||`fstream`-Specific Operations|
|:---:|:---|
|`fstream strmName;`|creates an **unbound** file stream. `fstream` is one of the types defined in the `<fstream>` header.|
|`fstream stmName(s);`|creates an `fstream` and opens the file named `s`. `s` can have type `std::string` or can be a pointer to a C-style character string. these constructors are `explicit`. the default file mode depends on the type of `fstream`.|
|`fstream strmName(s, mode);`|like the previous constructor, but opens `s` in the given `mode`|
|`fstrm.open(s)`|opens the file named by the `s` and binds that file to `fstrm`. `s` can be a `std::string` or a pointer to a C-style character string. the default file `mode` depends on the type of `fstream`. returns `void`.|
|`fstrm.open(s, mode)`|like the previous method, but opens `s` in the given `mode`|
|`fstrm.close()`|closes the file to which `fstrm` is bound. returns `void`|
|`fstrm.is_open()`|returns a `bool` indicating whether the file associated with `fstrm` was successfully opened and has not been closed|

- if a call to `open()` is fails, `failbit` is set
    * because it might fail, it's usually a good idea to verify the `open()` succeeded before using the stream
- if you call `open` on a file stream which is already open, the call will fail and set `failbit`
    * to associate a file stream with a different file, you must first close the existing file by calling `close()` method
- when an `fstream` object is destroyed, `close()` method is called **automatically** thanks to the destructor

### File Modes
Each stream has an associated **file mode** that represents how the file may be used

||File Modes|
|:---:|:---|
|`in`|open for input|
|`out`|open for output|
|`app`|seek to the end before every write|
|`ate`|seek to the end immediately after the open|
|`trunc`|truncate the file|
|`binary`|do IO operations in binary mode|

- the modes that we can specify have the following restrictions
    * `out` may be set **only** for an `ofstream` of `fstream` object
    * `in` may be set **only** for an `ifstream` of `fstream` object 
    * `trunc` my be set **only** when `out` is also specified
    * `app` mode may be specified 
    * by default, 
        + we can specify multiple file modes by using `|(bitwise OR operator)`
        + `ofstream app("fileName", ofstream::out | ofstream::app);`
    * `ate` and `binary` modes
- each file stream type defines their own **default file mode**
    * `ifstream` : `in`
    * `ofstream` : `out`
    * `fstream` : `in` and `out`
- file mode is determined each time `open()` method is called


## string Streams
We can perform IO operations on `std::string` objects by using the types defined in `<sstream>` header 
```c++
std::string data;
std::getline(std::cin, data);
std::istringstream eachWord(data);
std::ostringstream result;
while (eachWord) {
    std::string word;
    eachWord >> word;
    result << word;
}
std::cout << result.str() << std::endl;
// if you enter "This is my program"
// the result would be "Thisismyprogram"
```

### Specific Operations of stringstream

||`stringstream`-Specific Operations|
|:---:|:---|
|`sstream strmName;`|strmName is an **unbound** `stringstream`. `sstream` is one of the types defined in the `sstream` header|
|`sstream strmName(s);`|strmName is an `sstream` that holds a copy of the `std::string`s. this constructor is `explicit`|
|`strm.str()`|returns a copy of the `std::string` that strm holds|
|`strm.str(s)`|copies the `std::string` s into strm. returns `void`|

- like `fstream`, there are operations specific to `stringstream`
- you can reset the stream by calling `.str("")` method and `.clear()` method

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}