---
title: "Chapter 4"

categories:
    - cpp

tags:
    - [C++, Programming Language, lvalue, rvalue]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-11-29
---

# Expressions

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Fundamentals

### Prerequisites regarding expressions and operations
- this post assumes that you've already studied about expressions and operations through learning C
- hence, this post covers only about how the C++ features work with the existing concepts of epxressions and operations 

### Overloaded Operators
- you can redefine the existing operators by defining **overloaded operators**
- but overloaded operators would be covered in the later chapter becuase it's related to classes

### Lvalues and Rvalues
Every expressions in C++ is either an **rvalue** or an **lvalue**
- The conventional difference between them is
    * lavlues could stand on the left-side of an assignment
    * whereas rvalues could not
- But in C++, the distiction is less simple
    * some lvalues, such as const objects, may not be the left-hand operand of an assignment operation
    * roughly speaking, when we use an object as an **lvalue**, we use the object's identity(its location in **memory**)
    * when we use an object as an **rvalue**, we use the objects' value (its **contents**)
- Operators may work in a different way based on which value given (lvaleus or rvalues)
- the important point is that
    * when lvalue is expected, you can use **only** lvalues
    * but when rvalue is expected, you can use **both** of lvalues and rvalues
        + because rvalues are just contents of lvalues
        * let's take this example: `int a = 3;`
        * a is an lvalue, but 3 is an rvalue

## Type Conversions
There are two types of type conversions in C++
- Implicit Type Conversion
- Explicit Type Conversion

### Implicit Type Conversion
If you place Type A at the position where Type B is expected, compiler **automatically** converts the type A to type B by using **implicit** type conversion, if there is a **conversion** between two types and it's one of the certain **circumstances** for using implicit type conversion
- the same rules of C applied to C++ when it comes to the implicit type conversions
    * integral promotion
    * nonboolean to boolean
    * initialization
    * assignment
    * arithmetic and relational expressions with mixed types
        + converted to the type which have the higher precision
    * during function call
```c++
int a = 3.15 + 3;       
// 3 is converted to doulbe to calculate (3.15+3)
// 6.15 is converted to int(6) to initialize a
// fractional portion is discarded 
```

### Explicit Type Conversion
If you want to **forcely** convert an object to another type, you can use the **explicit** type conversion
- you can use explicition type conversion regardless of whether the implicit type conversion is available or not
- there are 2 ways to execute explicit type conversions in C++
    * C style
        - same concepts applied
        ```c++
        type (expr);     // function-style cast notation
        (type) expr;     // C-language-style cast notation
        ```
    * C++ style
        - a **named cast** is the method to convert explicitly in a C++ style way
        - a named has the following form: <br>
        `cast-name<type> (expression)`
        - cast-name can be
            + static_cast
            ```c++
            // use static_cast for most cases requiring type conversions
            int a = 30;
            int b = 4;

            double slope = a / b;                           // fractional portion is discarded
            double slope = static_cast<double>(a) / b;      // fractional portion is remained
            ```
            + dynamic_cast <br>
            dynamic_cast would be covered in later chapter
            + const_cast
            ```c++
            // cosnt_cast changes only a low-level const in its operand
            char ncc = 'a';
            const char cc = 'b';

            const char *pnc = &ncc;
            const char *pcc = &cc;
            char *pc = const_cast<char*>(pnc);      // ok
            char *pc = const_cast<char*>(pcc);      // ok; but writing to cc (constant object) is undefined

            const char * np = const_cast<const char *>(pc);     // ok
            ```
            + reinterpret_cast
            ```c++
            // reinterpret_cast generally performs a low-level reinterpretation of the bit pattern of its operands

            int *ip;
            char *pc = reinterpret_cast<char*>(ip);
            // however, safely using this cast requires completely understanding the types involved as well as the details of how the compiler implements the cast
            ```
        - type is the target type of conversion
        - expression is the value to be cast

### Avoid Casts
- generally, it's better way to avoid casting when it's possible<br>
  because casting is error-prone compared to the non-casting case
- if the cast is unavoidable, limiting the scope in which the cast value is used and documenting all assumptions about the types involved is recommended

## Operator Precedence Table
Although this post doesn't cover regarding operators, operator precedence table is here just for a reference
|Associativity|Operator|Function|Use|Page|
|:---:|:---|:---|:---|:---|
|L|`::`|global scope|::name|286|
|L|`::`|class scope|class::name|88|
|L|`::`|namespace scope|namespace::name|82|
||||||
|L|`.`|member selectors|object.member|23|
|L|`->`|member selectors|pointer->member|110|
|L|`[]`|subscript|expr [ expr ]|116|
|L|`()`|function call|name (expr_list)|23|
|L|`()`|type construction|type (expr_list)|164|
||||||
|R|`++`|postfix increment|lvalue++|147|
|R|`--`|postifx decrement|lvalue--|147|
|R|`typeid`|type ID|typeid(type)|826|
|R|`typeid`|run-time type ID|typeid(expr)|826|
|R|`explicit cast`|type conversion|case_name<type>(expr)|162|
||||||
|R|`++`|prefix increment|++lvalue|147|
|R|`--`|prefix decrement|--lvalue|147|
|R|`~`|bitwise NOT|~expr|152|
|R|`!`|logical NOT|!expr|141|
|R|`-`|unary minus|-expr|140|
|R|`+`|unary plus|+expr|140|
|R|`*`|dereference|*expr|53|
|R|`&`|address-of|&lvalue|52|
|R|`()`|type conversion|(type)expr|164|
|R|`sizeof`|size of object|sizeof expr|156|
|R|`sizeof`|size of type|sizeof(type)|156|
|R|`sizeof...`|size of parameter pack|sizeof...(name)|700|
|R|`new`|allocate object|new type|458|
|R|`new[]`|allocate array|new type[size]|458|
|R|`delete`|deallocate object|delete expr|460|
|R|`delete[]`|deallocate array|delete[] expr|460|
|R|`noexecpt`|can expr throw|noexcept( expr )|780|
||||||
|L|`->*`|ptr to member select|ptr->*ptr_to_member|837|
|L|`.*`|ptr to member select|obj.*ptr_to_member|837|
||||||
|L|`*`|multiply|expr * expr|139|
|L|`/`|divide|expr / expr|139|
|L|`%`|modulo(remainder)|expr % expr|139|
||||||
|L|`+`|add|expr + expr|139|
|L|`-`|subtract|expr - expr|139|
||||||
|L|`<<`|bitwise shift left|expr << expr|152|
|L|`>>`|bitwise shift right|expr >> expr|152|
||||||
|L|`<`|less than|expr < expr|141|
|L|`<=`|less than or equal to|expr <= expr|141|
|L|`>`|greater than|expr > expr|141|
|L|`>=`|greater than or euqal to|expr >= expr|141|
||||||
|L|`==`|equality|expr == expr|141|
|L|`!=`|ineqaulity|expr != expr|141|
||||||
|L|`&`|bitwise AND|expr & expr|152|
|L|`^`|bitwise XOR|expr ^ expr|152|
|L|`\|`|bitwise OR|expr \| expr|152|
||||||
|L|`&&`|logical AND|expr && expr|141|
|L|`\|\|`|logical OR|expr \|\| expr|141|
||||||
|R|`? :`|conditional|expr ? expr : expr|151|
||||||
|R|`=`|assginment|lvalue = expr|144|
|R|`*=, /=, %=`|compound assignment|lvalue += expr, etc|144|
|R|`+=, -=`|||144|
|R|`<<=, >=`|||144|
|R|`&=, \|=, ^=`|||144|
||||||
|R|`throw`|thrwo exception|throw expr|193|
||||||
|L|`,`|comma|expr, expr|157|


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}