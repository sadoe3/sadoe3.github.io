---
title: "Chapter 6"

categories:
    - cpp

tags:
    - [C++, Programming Language, Function]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-2
---

# Functions

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Prerequisites regarding functions
- this post assumes that you've already studied about functions through learning C
- hence, this post covers only about how the C++ features work with the existing concepts of functions

### C++ features
- passed by value and passed by refernece - p208
- reference to array (p114) - p 217
- varing parameters - p 220
- return list-intialzation - p226
- trailing return type and decltype as return type - p229
- overloaed functions - p230
- default argument - p236
- inline and constexpr - p238
- function matching - p242


## Argument Passing
- Passed by value and Passed by reference
- Varing Parameters

### Passed by value and Passed by reference
C and C++ have difference concepts regarding passing an argument as passed by value or passed by reference
- In **C**, passing a pointer is the sort of **passed by reference** because you **can change its value** through dereference it
    * From the perspective of C++, there's no way in C to pass an argument as **passed by reference** because there's no reference type in C
- In **C++**, however, passing a pointer is the sort of **passed by value** because it's not a reference so that **it's copied**
    * In C++, the only way to pass an argument as **passed by reference** is to make the parameter as a reference
    * In this way, the initializer is **not copied** because the parameter is a reference
- If you want to use a parameter as a reference in order not to copy the initializer and don't want to change its value
    * try to make the parameter as **reference to const**
- reference argument can be used as additional return values
    ```c++
    int factorial(int &countCalled, int number) {
        countCalled++;
        if (number == 1)
            return 1;
        return number * factorial(countCalled, number - 1);
    }
    ```
- you can set the parameter as a refence to an array
    ```c++
    int func(int (&rArr)[10]) {
        std::cout << rArr[2] << std::endl;
    }
    ```

### Varing Parameters
You can implement a function which takes **varing number** of arguments in 2 ways
- C style
    * using **ellipsis**
    * same rules applied in C++ as in C
    * use this feature only if you need to interface to C code otherwise, try C++ style features
- C++ style
    * varing number of argument of the **same** type : `initializer_list<type>` template
    * varing number of argument of the **different** type : variadic template
        + this concept would be covered in the later chapter

### initializer_list\<type>
```c++
#include <initializer_list>

int function(double a, std::initializer_list<int> b) {
    std::cout << b.size() << std::endl;

    std::initializer_list<int> c = b;       // doesn't copy, c and b share the element
    for(auto cur = b.begin(), end = b.end(); cur != end; cur++) {
        std::cout << *cur << " " << std::endl;
    }
}

... // some codes
function(3.14, {1, 2, 3, 4, 5});        // list-intialization
```
- you must include `<initializer_list>` to use `initializer_list<type>` template
- there are 2 ways to intialize it
    * default-initialization
    * list-initialization
- when `intializer_list<type>` object is copied or assigned to another object, it's not acutally copied
    * they just share the elements
- there are only a few operations available in `intializer_list<type`
    * `.size()`
    * `.begin()` and `.end()`
- you can put other parameters on the same function which takes `initializer_list<type>` parameter but you need to put the `initializer_list<type>` at the last part of the parameter list like ellipsis


## Return Types
You can set the deduced type as a return type of a function

### Trailing Return Type
```c++
auto functionName(int a) -> int(*)[10] {    // returns a pointer to an array of 10 int elements
    ... // some codes
}
```
- when you set auto as a return type, you can specify the actual return type by using trailing return type
- this is useful when the return type is complicated like above codes

### decltype as a return type
```c++
int odds[3] = {1,3,5};

decltype(odd) * arrPtr(int i) {     // returns a pointer to an array of 3 int elements
    return &odd;
}
```
- like auto, `decltype` can be used as a return type


## Function Overloading
We can implement **funciton overloading** in a different way from C in C++
- functions which have the **same name** and **scope** but **different parameters** are **overloaded**
    * functions which have the same names but differnt scopes are not overloaded
    ```c++
    int func(int);
    int main() {
        int func(char *);

        func(3);        // error because func(int) is hidden due to the local function
    }
    ```
    * in C++, name lookup happens before type checking
- we can make the function of a certain name work differently by passing different arguments
    * this is the core concept of the **function overloading**
    * but if the functions work in completely different ways, then just using different names might be a better solution
- like compiler 
