---
title: "Computer Graphics: Textures"

categories:
    - graphics

tags:
    - [Computer Graphics, Graphics, Ray Tracing, Texture Mapping, UV Mapping, Procedural Texture, Perlin Noise, Deterministic Random, Hermitian Smoothing, Shadow Mapping, Shadow Acne]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-05-28
---

[English](https://sadoe3.github.io/graphics/post5/){: .btn .btn--primary }{: .align-center}

# 텍스처 (Textures)
- 컴퓨터 그래픽스에서 **텍스처 매핑(Texture Mapping)**은 기하학적 형태(Geometry)에 재질 효과를 적용하는 과정으로, 3D 객체의 **사실감**을 향상시키는 핵심 기술입니다.
- 이 섹션에서는 기본 텍스처 매핑 방법부터 절차적 텍스처 생성 기술인 **펄린 노이즈(Perlin Noise)**, 그리고 깊이와 사실감을 제공하는 **섀도우 매핑(Shadow Mapping)**까지 포괄적으로 다룹니다.

## 텍스처 매핑 (Texture Mapping)
텍스처 매핑은 좌표계 의존성에 따라 크게 세 가지 방법으로 분류됩니다.

### 매핑 유형 (Types of Mapping)
* **상수 텍스처 (Constant Texture):**
    * **개념:** 표면 위치나 객체 움직임에 관계없이 모든 지점에 대해 **단일하고 균일한 색상 값**을 반환합니다.
    * **특징:** 공간 좌표나 기하학적 정보에 독립적인 가장 단순한 형태입니다. (예: 단색의 빨간색 구)
* **공간/월드 공간 텍스처 (Spatial/World Space Texture):**
    * **개념:** 텍스처가 객체의 표면이 아닌 **3D 월드 공간의 좌표**를 기반으로 정의됩니다.
    * **특징:** 텍스처가 공간의 절대 위치에 고정되어 있으므로, 객체가 움직이거나 회전하면 텍스처가 객체와 함께 움직이는 대신 표면 위에서 **미끄러지거나 왜곡**됩니다. 이는 벽이 움직여도 투영된 이미지가 벽에 고정되어 있는 것과 유사합니다.
* **UV-매핑 텍스처 (UV-Mapped Texture):**
    * **개념:** 가장 일반적인 3D 텍스처링 방법입니다. **2D 좌표계 ($U, V$)**를 사용하여 객체의 기하학적 표면과 텍스처 이미지를 명시적으로 연결합니다.
    * **특징:** 각 정점에 고유한 $(u, v)$ 좌표가 할당되어 텍스처가 표면에 "붙어" 이동하거나 회전할 때 객체와 함께 움직이며 고유한 모양을 유지하도록 보장합니다. (예: 티셔츠 위의 로고)

   <img src="/assets/images/raytracing/post5/mapping_types.png" alt="mapping_types" style="width: 70%; display: block; margin: 0 auto;">


## 절차적 텍스처 (Procedural Texture)
이 방법은 이미지 파일 없이 **수학적 알고리즘**만을 사용하여 텍스처를 생성합니다. 메모리 효율성과 해상도 제약이 없다는 장점을 제공합니다.

### 체커보드 텍스처 (Checkerboard Texture)
* **핵심 원리:** 광선이 맞은 지점의 $x, y, z$ 좌표를 활용합니다. 각 좌표의 내림값(floor)의 합에 대해 정수 연산(**Modulo 2**)을 수행하여 색상을 교대로 변경합니다.
* **구현 공식:** 각 좌표를 특정 상수($scale$)로 나누어 격자의 크기를 제어할 수 있습니다.
    
    $$\text{Pattern} = \left( \left\lfloor \frac{p_x}{scale} \right\rfloor + \left\lfloor \frac{p_y}{scale} \right\rfloor + \left\lfloor \frac{p_z}{scale} \right\rfloor \right) \bmod 2$$

   <img src="/assets/images/raytracing/post5/checker.png" alt="checker" style="width: 70%; display: block; margin: 0 auto;">

### 펄린 노이즈 상세 분석 (Detailed Analysis of Perlin Noise)
- **펄린 노이즈 (Perlin Noise)**는 **결정론적 무작위 값(Deterministic Random Values)**을 생성하는 절차적 텍스처 알고리즘으로, 무작위성을 보이는 부드럽고 연속적인 패턴을 만듭니다.
- 주로 구름, 불, 지형과 같은 자연 현상의 유기적인 불규칙성을 시뮬레이션하는 데 사용됩니다.

#### 핵심 개념 및 특징 (Core Concepts and Features)
* **정의:** 결정론적 무작위 값을 생성하여 동일한 입력 좌표($x, y, z$)에 대해 동일한 출력을 보장합니다.
* **특성:** 입력 위치가 변경됨에 따라 출력 값이 매우 **부드럽고 유기적으로** 변화합니다.
* **패턴 크기:** 사용자가 정의한 **순열 테이블(Permutation Table, P-Table)**의 크기가 노이즈 패턴의 반복 주기를 결정합니다. 예를 들어, 테이블 크기가 $2^8$이면 $0 \sim 255$ 범위에서만 고유한 무작위 값이 생성되고, 그 후에는 패턴이 반복됩니다.
* **효율성:** 기본 노이즈 패턴을 포함하는 핵심 테이블은 처음에 한 번만 생성되므로, 복잡한 난수 계산을 매 프레임 수행할 필요가 없어 계산 부하가 줄어듭니다.

#### 기본 작동 원리 (다중 무작위 적용) (Basic Operating Principle (Multiple Random Application))
펄린 노이즈는 여러 단계를 거쳐 '무작위성'을 적용하고 결합하여 예측 가능하면서도 복잡한 패턴을 생성합니다.
1. **순열 테이블 생성:** 정수 값 시퀀스(예: $0 \sim 255$)를 배열하고 요소의 순서를 무작위로 섞어 **순열 테이블(P-Table)**을 만듭니다. 이 테이블은 고정된 패턴을 제공합니다.
2. **좌표 해싱 (절단):** 입력 위치 값(예: $x$ 좌표)은 테이블 크기(예: 255)와 **AND 연산 ($\& 255$)**을 수행하여 유효한 테이블 인덱스로 변환(절단)됩니다.
3. **무작위 값 추출 및 결합:** 인덱스는 P-Table에서 무작위 값을 검색하는 데 사용됩니다. 이 과정은 각 축($x, y, z$)에 대해 수행되며, 결과로 생성된 여러 무작위 값은 결합(예: XOR 연산 사용)되어 최종 무작위 값을 얻습니다.

#### 상세 구현 단계 (격자점 및 보간) (Detailed Implementation Steps (Grid Points and Interpolation))
펄린 노이즈의 핵심은 격자점 정보 준비와 부드러운 보간이라는 두 단계로 나뉩니다.

##### 격자점 정보 준비 (순열 테이블 및 그래디언트) (Grid Point Information Preparation (Permutation Table & Gradient))
* **순열 테이블 (P-Table) 및 그래디언트 벡터 할당:**
    * **P-Table 역할:** 기본 노이즈 패턴을 결정하는 핵심 구조로, 일반적으로 $2^n$(예: 256) 크기의 배열을 섞어 생성됩니다.
    * **그래디언트 벡터 ($G$):** 입력 위치 $P$를 둘러싼 단위 정육면체의 8개 모서리(격자점) 각각에는 P-Table을 통해 무작위로 방향이 지정된 **단위 벡터**가 할당됩니다. 이 벡터가 **그래디언트 벡터**입니다.
* **영향 계산 (내적):**
    * **거리 벡터 ($D$):** 각 격자점에서 입력 위치 $P$까지의 상대 거리 벡터가 계산됩니다.
    * **내적 (Dot Product):** 그래디언트 벡터 ($G$)와 거리 벡터 ($D$) 사이의 **내적 ($G \cdot D$)**이 계산됩니다.
    * **의미:** 이 내적은 해당 격자점으로부터의 예측된 그래디언트 또는 영향을 나타냅니다. 점 $P$가 특정 격자점에 가까워질수록 내적은 0에 가까워지며, 이는 보간을 위한 입력 값으로 사용됩니다.

##### 부드러운 보간 (보간 및 평활화) (Smooth Interpolation (Interpolation & Smoothing))
* **평활화 함수 (Smoothing Function):**
    * **목적:** 단순 선형 보간을 사용하면 노이즈 그래디언트가 격자 경계에서 갑자기 변하여 **부자연스러운 이음새**나 **블록 모양**을 유발합니다.
    * **해결책:** 입력 위치 $P$의 소수 부분($t$, 즉 $u, v, w$)에 3차 평활화 함수가 적용됩니다. 가장 일반적인 공식은 다음과 같습니다:
        $$f(t) = 3t^2 - 2t^3$$
    * **특징:** 이 함수는 $t=0$과 $t=1$에서 도함수(기울기)가 0이 되도록 보장하여, 노이즈 패턴이 격자점에서 **부드럽게** 연결되도록 합니다.
* **삼선형 보간 (Trilinear Interpolation):** 8개의 내적 값(영향)은 평활화된 가중치($u', v', w'$)를 사용하여 $X \rightarrow Y \rightarrow Z$ 순서로 **보간(합산)**되어 최종 노이즈 값을 얻습니다. 모든 가중치의 합이 1이므로 최종 값은 가중 평균의 형태를 취합니다.

   <img src="/assets/images/raytracing/post5/interpolation.png" alt="interpolation" style="width: 70%; display: block; margin: 0 auto;">

#### 에르미트 평활화의 수학적 배경 (Mathematical Background of Hermite Smoothing)
펄린 노이즈에 사용되는 3차 평활화 함수 $f(t) = 3t^2 - 2t^3$는 **3차 에르미트 스플라인(Cubic Hermite Spline)**의 특수한 형태입니다.
* **에르미트 스플라인 정의:** 양 끝점에서 **위치 ($P_0, P_1$)**와 **도함수/기울기 ($M_0, M_1$)**를 지정하여 제어되는 스플라인입니다.
* **평활화 함수 유도:** 노이즈 평활화 함수는 일반 에르미트 스플라인 공식에 다음 조건을 설정하여 유도됩니다:
    * 시작 위치 $P_0 = 0$, 끝 위치 $P_1 = 1$.
    * 시작 접선 $M_0 = 0$, 끝 접선 $M_1 = 0$ (경계에서 기울기는 0으로 설정됩니다).
    * 이 설정을 일반 공식에 대입하면 단순한 3차 함수 $p(t) = -2t^3 + 3t^2$ (또는 $3t^2 - 2t^3$)가 도출됩니다.
* **의미:** 이 함수는 $t=0$과 $t=1$ 근처에서 변화율이 0인 **이지 인/이지 아웃(Ease-in/Ease-out)** 효과를 생성하여 변화의 시작과 끝을 부드럽게 만들어 자연스러운 노이즈 보간을 초래합니다.


## 구형 좌표 변환 (Spherical Coordinate Transformation)
구형 좌표 변환은 3D 공간 좌표를 텍스처 이미지의 2D 좌표로 매핑하는 데 사용되는 UV 매핑의 핵심 기술입니다. **구(Sphere)**와 같은 회전 대칭 객체에 환경 맵 또는 일반 텍스처를 적용하는 데 필수적입니다.

### 기본 개념 (Basic Concept)
* **목표:** 광선이 맞은 3D 위치 ($P = (x, y, z)$)를 2D 텍스처 이미지 좌표 ($U, V$)로 변환합니다.
* **원리:** **직교 좌표계 ($x, y, z$)**와 **구형 좌표계 ($r, \theta, \phi$)** 간의 변환을 기반으로 합니다. (여기서는 객체가 단위 구 위에 있다고 가정하고 $r=1$을 사용합니다.)
* **적용:** 레이 트레이싱에서 광선이 객체를 맞출 때, 맞은 지점의 ($x, y, z$) 값이 **각도 정보 ($\theta, \phi$)**로 변환되어 텍스처 이미지에서 해당 색상 값을 가져옵니다.

### 좌표계 정의 및 유도 (Coordinate System Definition and Derivation)
변환 공식을 유도하기 전에, 사용되는 좌표계를 명확하게 정의하는 것이 중요하며, 이 정의가 최종 공식의 부호를 결정합니다.

* **축 정의:**
    * $x$ (왼쪽/오른쪽): 오른쪽
    * $y$ (위/아래): 위 (천정 방향)
    * $z$ (앞/뒤): 앞
* **각도 정의:**
    * $\theta$ (수직 각도): $+y$ 축(위)에서 내려오는 각도 (극각, 위도)
    * $\phi$ (수평 각도): $+x$ 축(오른쪽)에서 $+z$ 축(앞)을 향해 회전하는 각도 (방위각, 경도)

   <img src="/assets/images/raytracing/post5/definition.png" alt="definition" style="width: 70%; display: block; margin: 0 auto;">

#### $x, y, z$ $\rightarrow$ $\theta, \phi$ 유도 (Derivation)
변환 공식은 일반적으로 구형 좌표($(\phi, \theta) \rightarrow (x, y, z)$)에서 직교 좌표를 얻는 과정을 역으로 하여 유도됩니다. (빗변 $r=1$ 가정)

* **$\mathbf{y}$ 좌표에서 $\mathbf{\theta}$ 유도 (수직 성분):**
    * $y$ 값은 빗변(반지름)과 수직 각도 $\theta$를 사용하여 쉽게 찾을 수 있습니다.
    
    $$y = \cos\theta$$
    
    * 따라서 $\theta$는 $\arccos$ 함수를 통해 얻어집니다.
    
    $$\theta = \arccos(y)$$
* **$\mathbf{x, z}$ 좌표 유도 (수평 성분):**
    점 $P$가 $xz$ 평면에 투영될 때, 원점과 투영된 점 사이의 거리는 $\sin\theta$입니다. 이 거리는 $x$와 $z$를 유도하는 빗변으로 사용됩니다.
    * **$\mathbf{x}$ 유도:**

        $$\cos\phi = \frac{x}{\sin\theta} \implies x = \sin\theta \cos\phi$$

    * **$\mathbf{z}$ 유도:**

        $$\sin\phi = \frac{z}{\sin\theta} \implies z = \sin\theta \sin\phi$$

    * $\phi$ 각도는 $x$와 $z$ 사이의 $\tan$ 관계를 사용하여 유도됩니다.

        $$\tan\phi = \frac{\sin\phi}{\cos\phi} = \frac{z/r}{x/r} = \frac{z}{x}$$

    * 따라서 $\phi$는 $\operatorname{atan2}$ 함수를 사용하여 얻어집니다. $\operatorname{atan2}$는 두 변수($y, x$)를 취하고 사분면을 고려하여 올바른 각도를 반환합니다.
        
        $$\phi = \operatorname{atan2}(z, -x)$$

#### 최종 변환 공식 (Final Transformation Formulas)
- 맞은 위치 $P(x, y, z)$가 주어지면 텍스처 좌표에 해당하는 각도 $\theta$와 $\phi$는 다음과 같습니다:

$$\theta = \arccos(y) \quad (\text{corresponds to Vertical coordinate, } V)$$

$$\phi = \operatorname{atan2}(z, -x) \quad (\text{corresponds to Horizontal coordinate, } U)$$

- 이 각도 값들은 $V$ (수직) 및 $U$ (수평) 좌표의 범위(예: $[0, 1]$ 또는 $[0, \text{텍셀 수}]$)로 정규화되어 2D 이미지 텍스처를 샘플링하는 데 사용됩니다.

   <img src="/assets/images/raytracing/post5/transformation.png" alt="transformation" style="width: 70%; display: block; margin: 0 auto;">

#### 구현 고려 사항 (Implementation Considerations)
* **좌표계 일관성:** 위 공식은 **$+y$를 위(Up)**로 정의하는 것을 기반으로 합니다. 렌더링 시스템이 $+z$를 위로 정의하거나 다른 축을 사용하는 경우, $\arccos$에 사용되는 변수와 $\operatorname{atan2}$의 변수 및 부호(예: $-x$)는 해당 관례와 일치하도록 적절하게 변경되어야 합니다.
* **UV 좌표 원점:** 대부분의 이미지 형식은 왼쪽 상단 모서리를 $(0, 0)$으로 정의하지만, 원점의 위치(예: 왼쪽 하단)는 특정 텍스처 또는 환경 맵의 정의에 따라 달라질 수 있습니다. 최종 텍스처 좌표를 적용하기 전에 이 원점을 확인해야 합니다.


## 섀도우 매핑 (Shadow Mapping)
섀도우 매핑은 광원의 시점에서 **깊이 정보**를 활용하여 한 객체가 다른 객체를 가리는지 여부를 판단함으로써 그림자를 드리우는 기술입니다.

### 섀도우 매핑의 핵심 원리 (Core Principle of Shadow Mapping)
섀도우 매핑 프로세스는 두 가지 주요 단계로 구성됩니다. 핵심 개념은 **깊이**가 특정 **방향**을 기준으로 정의된다는 것입니다.

#### 단계 1: 섀도우 맵 생성 (깊이 기록) (Stage 1: Shadow Map Generation (Depth Recording))
* **광원 시점 렌더링:** 장면은 광원의 위치와 시점에서 렌더링됩니다. 이는 광원에서 모든 방향으로 섀도우 광선을 발사하는 것과 개념적으로 유사하게 작동합니다.
* **깊이 저장:** 렌더링된 각 픽셀에 대해 광원에서 첫 번째 **충돌(hit)**까지의 가장 짧은 거리가 측정됩니다. 이 거리가 **깊이(Depth)**이며, 이 값들은 **섀도우 맵(Shadow Map)**이라는 2D 텍스처에 저장됩니다.
    * **방향 정의:** 섀도우 맵의 각 텍셀에 저장된 깊이 값은 광원에서 볼 때 해당 텍셀 위치에 해당하는 특정 방향에서 가장 가까운 객체까지의 거리를 나타냅니다.

#### 단계 2: 그림자 결정 (깊이 비교) (Stage 2: Shadow Determination (Depth Comparison))
카메라 시점에서 장면을 렌더링할 때, 각 지점 $P$가 그림자 속에 있는지 여부는 다음과 같이 결정됩니다:

* **광원 공간으로 변환 (Transformation to Light Space):**
    * 렌더링 대상 지점 $P$의 월드 좌표는 광원의 뷰 및 투영 행렬을 사용하여 **광원 공간(Light Space)** 좌표로 변환됩니다.
    * **개념적 의미:** 이 공간 변환은 마치 광원에서 보는 것처럼 지점 $P$를 섀도우 맵의 동일한 텍셀 위치로 매핑합니다. 즉, 광원에서 발산하는 동일한 방향을 따라 놓인 모든 지점은 섀도우 맵에서 동일한 텍셀을 샘플링합니다.
    * **조회:** 변환된 광원 공간 좌표를 사용하여 섀도우 맵에서 저장된 깊이 값 ($d_{map}$)이 조회됩니다.
* **거리 비교 (Distance Comparison):**
    * **현재 깊이 계산:** 지점 $P$에서 광원까지의 실제 거리 ($d_{current}$)가 계산되거나, 광원 공간 변환 결과에서 깊이 성분($z$ 값)이 추출됩니다.
    * **판단:**
        * $\mathbf{d_{current} > d_{map}}$: 이는 현재 지점 $P$에서 광원까지의 거리가 섀도우 맵에 저장된 최소 깊이보다 크다는 것을 의미합니다. 이는 $P$와 광원 사이에 다른 객체(**장애물**)가 있고, 광선이 가려져서 **그림자**가 드리워졌음을 시사합니다.
        * $\mathbf{d_{current} \approx d_{map}}$: 거리가 거의 같으면, 지점 $P$가 광원에서 가장 가까운 객체의 표면에 있음을 의미하므로 그림자가 드리워지지 않습니다.

   <img src="/assets/images/raytracing/post5/shadow_mapping.png" alt="shadow_mapping" style="width: 70%; display: block; margin: 0 auto;">

### 섀도우 여드름 및 해결책 (Shadow Acne and Solution)
**섀도우 여드름(Shadow Acne)**은 부동 소수점 숫자로 섀도우 매핑을 구현할 때 발생하는 피할 수 없는 문제입니다.

* **문제 원인:** 부동 소수점 산술의 정밀도 한계로 인해, 2단계에서 저장된 깊이 ($d_{map}$)와 계산된 현재 깊이 ($d_{current}$)가 정확히 일치하지 않는 약간의 불일치 오류가 발생합니다. 이 오류는 조명이 비춰져야 할 표면이 자체 가려짐으로 잘못 판단되게 하여 표면에 어두운 얼룩(여드름)이 생기게 합니다.
* **해결책 (바이어스):** 이 오류를 수정하기 위해 섀도우 맵과 비교할 때 $d_{current}$에 매우 작은 양수 값인 **엡실론 ($\epsilon$)**을 더합니다 ($\mathbf{d_{current} + \epsilon}$). 이 오프셋은 광선의 시작점을 표면에서 약간 이동시켜 **자체 교차(Self-Intersection)**의 오판을 방지합니다.

   <img src="/assets/images/raytracing/post5/shadow_acne.png" alt="shadow_acne" style="width: 70%; display: block; margin: 0 auto;">

[Top](#){: .btn .btn--primary }{: .align-right}