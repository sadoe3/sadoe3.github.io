---
title: "Qt6 : Event Handling"

categories:
    - qt6

tags:
    - [Qt6, GUI, Event Handling, Event, C++]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-11-16
---

# Event Handling
This post covers things related to **event handling** of `Qt Wdiget` Applications


## Core Architecture
There 3 **classes** you can choose to develop a certain type of Qt Widget applications

### QCoreApplication
`QCoreApplication` is the base class for **non-GUI** applications
- it handles the **basic functionality** needed for `any Qt application` that does **not involve** a graphical user interface (**GUI**)
    * this class manages the event loop and application settings, but it does not provide any GUI functionality
- Use Case
    * if you’re writing a **command-line** application or a non-GUI-based application
        + e.g., a server, a daemon, or a background process
    * you would use `QCoreApplication`

### QGuiApplication
`QGuiApplication` is a **subclass** of `QCoreApplication`
- it adds **GUI-specific functionality** for applications
    * that do **not** use the **full Qt Widgets** system but still require some basic GUI features, such as handling windowing systems, events, and interactions
- Use Case
    * if you are building an application that involves **low-level GUI elements**
        + such as handling `OpenGL` windows, QML-based UIs, or custom widgets without relying on the full Qt Widgets system
    * `QGuiApplication` is appropriate

### QApplication
`QApplication` is the **most commonly used class** in Qt applications when you need both event handling and GUI elements from the Qt Widgets module
- it provides all the necessary event handling and GUI features for creating and managing widgets
- Use Case
    * if you're building a traditional desktop application with a standard set of **Qt Widgets**
        + like buttons, text fields, labels
    * you should use `QApplication` 


## QObject
`QObject` is the **base class** for `most Qt object types`
- it provides **core functionality** for all Qt objects
    + such as object memory management
    + properties
    + event handling
    + signal-slot connections
- it's **not directly** related to **GUI components**, but rather to object model and event management in Qt
- `QObject` is based on **parent-child** relationship
    ```c++
    // constructor of QObject
    QObject(QObject *parent = nullptr);
    // Parent adds the object to its list of children
    ```
    * the **parent-child** relationship in Qt is a memory management model for automatic deletion of objects
        + it's worth noting that it is **not related to inheritance**
        + which means that if class `B` is a child of class `A`, this doesn't mean that `B` is the derived class of class `A`
    * if object has children and is being destroyed, **its children** would be **deleted first**
- `QObject` can be constructed on `heap` area with `new` expression, or on `stack` area as a local object
    * **Most** of `QObject`s need to be **dynamcially allocated** with `new`
    * but some may not
        + `QApplication`
            * local to `main()`
        + top level `QWidget`
            * like `QMainWindow`
        + `QFile`
            * usually local to a certain function
        + value types
            * such as `QString`, `QColor` because it's cheap to copy

### QWidget
`QWidget` is a **subclass** of `QObject` and is the **base class** for **all** user interface **objects** in Qt that appear on the **screen** (such as windows, buttons, labels, etc.)
- it adds **graphical** and **interactive** features to `QObject`
    * it's worth noting that `QObject` **doesn't provide** any **visual representation** functionality
        + which means that if you want to **paint** (drawing widgets on the screen) a certain object, you need to make that object **inherit** from `QWidget`
    * the additional features that `QWidget` provides are **mouse** and **keyboard** events, **focus** management, and widget **positioning**
- if a certain `QWidget` object **doesn't have** a **parent**, then a **new window** is created
    * if you want that widget to be used for **user interaction**
        + such as input collection or displaying messages
    * it may be called a `dialog` 
        + but only if it's **inherited** from a `QDialog`, `QMessageBox`, or similar
- the widget position of a **child** uses its **parent's** coordinate system
    * if the child widget **crossed the boundary** of its parent, it would be **clipped** on the screen
- **children** follow the `state` or `enable-ness` of their **parent**
- you should **never include** `<QWidget>`
    * you need to include **specific widget** like `<QPushButton>`
    * class hierarchy of `QPushButton`
        + `QObject` -> `QWidget` -> `QPushButton`

### Multiple File Handling for a Custom Widget
When you create a **custom widget**, try to follow this convention
- **Header File**
    ```c++
    // MyQtWidget.h
    #ifndef MYQTWIDGETS_H
    #define MYQTWIDGETS_H

    #include <QWidget>

    class SimpleWindow : public QWidget {
        Q_OBJECT
    public:
        SimpleWindow(QWidget* parent = nullptr);
    };

    #endif
    ```
    * it's worth noting that you always need to put `Q_OBJECT` **macro** when you want to **inherit** from the `QObject` class
- **Source Files**
    ```c++
    // MyQtWidget.cpp
    #include "MyQtWidgets.h"

    SimpleWindow::SimpleWindow(QWidget* parent) : QWidget(parent) {
        // some codes
    }
    ```
    ```c++
    // Main.cpp
    #include "MyQtWidgets.h"
    #include <QtWidgets/QApplication>

    int main(int argc, char *argv[])
    {
        QApplication a(argc, argv);

        SimpleWindow* window = new SimpleWindow();
        window->show();
        delete window;

        return a.exec();		    // this code is needed to enter the main event loop
    }
    ```
    * note that this convention follows the way how the standard widgets are utilized
        + include the header file -> use it
    * if you want to learn more regarding specific standard widgets, check the documentation


## Basic Event Handling
There are two main ways to handle events or interactions with widgets:
- using **Event Handlers** (`Virtual` Methods)
    * this approach is recommended when you need to **directly respond** to events generated by the system or user
        + such as mouse clicks, key presses, or window resizing
    * **single** object handles the event
- using **Signals** and **Slots**
    * Use this way for **object communication** in your application, especially when objects need to be notified of changes or actions
        * such as button clicking to change values in other objects
    * **multiple** objects handle the event

### Events
`QWidget` has various types of widget events
- events can be **accepted** or **ignored** 
    * default is **accepted**
- event can be **propagated** to `parent` widget if the event is **ignored**
- events on **non-QWidgets** are **never automatically propagated**
- `QEvent` is the **base class** for all event classes

### How Event Handlers work
When an **event** occurs to a `QWidget` object, the event trigger calls the **event handler**, then **event handler** decides whether to `accept` or `ignore` the event
- if it calls `accept()`, then that handler should handle the event because `accept()` **stops further propagation**
- otherwise
    + calling `ignore()`
    + no call to `accept()` or `ignore()`
- the event will **propagate** up to **parent** widget until it reaches
    + the widget which calls `accept()`
    + or **top-level** widget which may perform **default** action for the event type

### How to Create a Custom Event Handler
You can implement the **custom event handler** so that the widget will perform what you want when a certain event occurs
```c++
// basic syntax
void eventName(EventType *event) override {
    // do something
}
```
```c++
// actual example
#include <QWidget> 
#include <QKeyEvent>        // need to be included

class MyWidget : public QWidget
{
    Q_OBJECT

public:
    MyWidget(QWidget *parent = nullptr) : QWidget(parent) {}

protected:
    // Key event handler
    void keyPressEvent(QKeyEvent *event) override {
        if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            // some code
            event->accept();
        }
    }
};
```
- it's worth noting that you need to **include** the `header file` for the specific event that you want to handle
    * then specify the type as the `type` of the **parameter** of the handler
- also note the event handlers reside in `protected` section

### Event Filtering
You can also install an **event filter** on a widget to intercept events before they reach the widget:
```c++
QWidget *widget = new QWidget;
widget->installEventFilter(this);
```
- in this case, you would implement the `eventFilter()` method in the object that installed the filter, which allows you to process or **modify** events before they are delivered to the widget
- also it’s possible to **cast** the `event` to `virtual event`
    * such as `QMouseEvent` -> `QEvent::MouseMove`

### Signals and Slots
In Qt's signals and slots mechanism:
- **Signals** represent `events` or notifications **emitted** by objects to indicate that something has happened or a state has changed
- **Slots** are `methods` (or functions) that are connected to the signals, and they are **called automatically** to handle the event (signal) when the corresponding signal is emitted
- a **single signal** can be connected to **multiple slots**
    * each **slot** connected to a signal is **executed** in the **order** it was **connected** when the signal is emitted
    * the opposite case works for sure
- it's possible to connect `signal` to another `signal`

### `QObject::connect()`
You can make the connection between signals and slots by calling `QObject::connect()`
```c++
QObject::connect(sender, signal, receiver, slot);
```
```c++
// example use
QPushButton *button = new QPushButton("Click Me!!");
QObject::connect(button, &QPushButton::clicked, this, &MyWidget::onButtonClicked);
```
- `sender`
    * the object that emits the signal
    * it must be a `pointer` to a `QObject`
- `signal`
    * the signal emitted by the sender
    * in the form of a `member function pointer`
- `receiver`
    * the object that will receive the signal and call the slot
    * it must be a `pointer` to a `QObject`
- `slot`
    * the slot (or function) that will handle the signal
    * this can be a `pointer` to `member function`, a `functor` (such as `lambda`), or even a `global function`
- if you want to use a `global function` or `functor` as the slot, you can **replace** the rest **2 parameters** with a **single** parameter
    ```c++
    void standAloneFunction() {
	// do something
    }
    struct LogString {
    public:
        explicit LogString(const QString &prefix) : prefix(prefix) {}
        void operator() (const QString &string) {
        // do something
        }
    private:
        QString prefix;
    };

    QObject::connect(slider, &QSlider::valueChanged, 
            standAloneFunction);
    QObject::connect(slider, &QSlider::valueChanged, 
            LogString(“Log: “));
    QObject::connect(slider, &QSlider::valueChanged, 
            [] { /* do something*/ } );
    ```
- it's possible to **add arguments** to signals and slots, but there’s a **rule** to follow
    ```c++
    // examples 
    signal(int, int) -> slot(int, int)      = good
    signal(int, int) -> slot(int)           = good
    signal(int)      -> slot(int, int)      = bad
    signal(QString)  -> slot(int)           = bad
    signal()         -> slot(int)           = bad
    ```
    * slot **can** use or ignore arguments from signal, but it **cannot** create or alter the argument

### How to disconnect
It's possible to **disconnect** the connection
```c++
// default
QObject::disconnect(sender, &Sender::valueChanged, 
		receiver, &Receiver::setValue);

// for lambda
QMetaObject::Connection myConnection = QObject::connect(slider, &QSlider::valueChanged, 
		   [] { /* do something */ } );
QObject::disconnect(myConnection);
```

### How to Create Custom Signals and Slots 
You can create custom signals and slots
```c++
#include <QObject>
class NumberGenerator : public QObject {
    Q_OBJECT
public:
    NumberGenerator(QObject *parent = nullptr) : QObject(parent), m_number(0) {}

    // Public method to change the number and emit the signal
    void setNumber(int number) {
        if (m_number != number) {
            m_number = number;
            emit numberChanged(m_number);           // Emit the custom signal
        }
    }
    // Custom signal
signals:
    void numberChanged(int newNumber);              // Signal that will be emitted when number changes
private:
    int m_number;
};
```
```c++
#include <QObject>
class NumberHandler : public QObject {
    Q_OBJECT

    // Custom slot
public slots:
    void onNumberChanged(int newNumber) {
        m_number = newNumber;
    }

public:
    NumberHandler(QObject *parent = nullptr) : QObject(parent), m_number(0) {}
private:
    int m_number;
};
``` 
```c++
NumberGenerator generator;
NumberHandler handler;
QObject::connect(&generator, &NumberGenerator::numberChanged, &handler, &NumberHandler::onNumberChanged);
```
- it's worth noting that you need to type `emit` **keyword** to emit the signals with certain parameters
- the **signals** from the `sender` should be **declared** inside `signals` section
- the **slots** from the `receiver` should be **defined** insdie `slots` section
    * you can provide the access level to the `slots` section
- you must call `connect()` to make the connection

### How to Setup Event Handling using Signals and Slots through Qt Designer
You can setup the signals and slots connection through `Qt Designer` by following the steps below
- double click `ui file` to open `Qt Designer` -> press `F4` to edit signals and slots
- click the proper widget as the `signal` -> drag it to the proper one that you want to make as the `slot`
- then the `setup wizard` would appear -> select the proper options -> it's done
    * click the `Show signals and slots inherited from QWidgets` check box to see more signals and slots
    * in order to setup the signals and slots in Qt designer, you need to **enable** the editor view
        + View(V) -> check Signals & Slots Editor
- if you want to setup the **close button**, you can do so by following these steps
    * select the close button -> drag it to the empty part of the dialog -> select click() to close()


## Extra Details

### How to Pass the Text to the Console
```c++
#include <QDebug>

qDebug() << “text”;
```

### How to Use `QMessageBox`
```c++
#include <QMessageBox>

QMessageBox box("입력 완료", "입력을 완료했습니다.", QMessageBox::Information, QMessageBox::Button::Ok, QMessageBox::Button::NoButton, QMessageBox::Button::NoButton, this);
box.exec();

// other use
bool isYes() {
    QMessageBox::StandardButton answer = QMessageBox::question(
		this,
		tr("Close Window"),			            // this one is title
		tr("Really close the window?"),	        // this one is description
		QMessageBox::Yes | QMessageBox::No
	);

	return answer == QMessageBox::Yes;		    // you can check the result
}
```

### What is `tr()`
The tr() function is useful for multi-languages support when you want to use simple string

### How to Convert Digit to `QString`
```c++
int objectName = 3;
QString s = QString::number(objectName);
```

### How to Start Application as Maximized Size 
```c++
// main.cpp
Mainwindow w;
w.setWindowState(Qt::WindowMaxmized);
w.show();
```

### How to Get the Last Day of Each Month
```c++
QDate objectName;
auto lastDay = objectName.daysInMonth();
```

### QComboBox
It's possible to add multiple items to `QComboxBox` at once by using this code
```c++
myCmb->addItems({ "one", "two", "three", "four" });
```

### LineEdit with Thousands Separator
```c++
void MainWindow::on_lineEditValue_textChanged(const QString &arg1) {
    QLocale converter;
    QString tempString = arg1;
    tempString.remove(",");

    ui->lineEditValue->setText(converter.toString(tempString.toULong()));
}
```

### QValidator
If you want `QLineEdit` to allow **digits only**, you can use `QValidator`
1. create the **event handler** for `textChanged` signal of the `QLineEdit` widget
2. create validator inside the **constructor** of the main window
3. then set it as the validator for a certain `QLineEdit` widget
    ```c++
    // constructor of mian window
    QValidator *validator = new QintValidator(0, 100, this);
    Ui->lineEdit->setValidator(validator);
    ```

### InputMask
If you want to restrict and guide user input to follow a specific pattern or format for `QLineEdit`, try using `inputmask`
```c++
// allow 3 digits only
ui->lineEdit->setInputMask(“000”); 
```
- for more [**information**](https://doc.qt.io/qt-6/qlineedit.html#inputMask-prop)


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}