---
title: "Project 4: File Systems"

categories:
    - pintos

tags:
    - [Operating Systems, PintOS, Linux, ]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-04-07
---


# File Systems
- The final project fills the last part to complete the ultimate PintOS.
- The last part includes:
  1. Implementing a buffer cache.
  2. Having the files become extensible
  3. Introducing subdirectories.
- Below, I outline the objectives, challenges, solutions, and implementations for each component.

## Part 1: Buffer Cache

### Objective
- The goal is to implement a **buffer cache** so that
  - The disk I/O is not performed directly to disk but to memory, increasing performance

### Current Problem
- The current PintOS doesn't have a buffer cache.
  * The original `block_read()` and `block_write()` always try to access to the disk whenever they are called

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  void
  block_read (struct block *block, block_sector_t sector, void *buffer)
  {
    check_sector (block, sector);
    block->ops->read (block->aux, sector, buffer);
    block->read_cnt++;
  }

  void
  block_write (struct block *block, block_sector_t sector, const void *buffer)
  {
    check_sector (block, sector);
    ASSERT (block->type != BLOCK_FOREIGN);
    block->ops->write (block->aux, sector, buffer);
    block->write_cnt++;
  }
  ```
  </details>

### Original Grade
<img src="data:image/png;base64,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" alt="Description of image">

### Solution
- I created `block_read_buffer_cache()` and `block_write_buffer_cache()`
  * They are called when the file system needs to read from or write to the buffer cache.
- If the file system needs to access to actual disk,
  * Then, I kept using the existing `block_read()` and `block_write()`
- Whenever `block_write_buffer_cache()` is called, it tries to write to buffer cache
  * If cache miss happens, then it loads the block from the disk to the buffer cache, then preceeds.
- Whenever `block_read()` is called, it checks whether that block in buffer cache is modified or not
  * If it's not modified yet, then it directly reads from the buffer cache
    + if cache miss happens, then it loads the block from the disk as well
  * If it's modified, it flushes the block first, then preceeds.
- The flush of buffer cache happens when:
  * the block is evicted
  * when the dedicated thread which wakes up periodically finds the dirty block
  * the file system is terminated
- In order to accomplish this:
  * I create an array of `struct buffer_entry` to store the information required to manage the blocks loaded in buffer cache
  * I reimplemented `inode_read_at()` and `inode_write_at()`

### Implementation Details
- **`block.h`**
  - **`struct buffer_entry`**
    - New structure that is utilized as an entry for each block in buffer cache.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Entry for each block in a buffer cache */
      struct buffer_entry {
          struct block *target_block_device; /* target block device */
          block_sector_t sector_index;       /* physical address of this block in the disk */ 
          void *cached_block;                /* pointer to the actual address in memory for the cached block */
          bool is_dirty;                     /* flag to check whether this block is modified or not */
          bool is_accessed;                  /* flag for choosing a victim for the eviction */
      };
      ```
      </details>
  - **`cached_mapping_table`**
    - The global array of `buffer_entry`
    - This array will be initialized in `filesys_init()`
    - Moreover, the entries are flushed when it's needed such as `filesys_done()` is called, or `block_read()` is called
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Buffer Cache */
      #define BUFFER_CACHE_MAX_COUNT 64
      struct buffer_entry cached_mapping_table[BUFFER_CACHE_MAX_COUNT];
      ```
      </details>
  - **`buffer_cache_lock`**
    - The global lock for `cached_mapping_table`
    - This lock will be initialized in `filesys_init()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Buffer Cache */
      struct lock buffer_cache_lock;
      ```
      </details>
  - **`declaration for new functions`**
    - Declares `block_read_buffer_cache()` and `block_write_buffer_cache()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void block_read_buffer_cache(struct block *block, block_sector_t sector, void *buffer,
                                    int32_t buffer_offset, int chunk_size, int cache_offset);
      void block_write_buffer_cache(struct block *block, block_sector_t sector, const void *buffer,
                                    int32_t buffer_offset, int chunk_size, int cache_offset);
      ```
      </details> 
  - **`new header files`**
    - Includes three header files in `block.h` for `filesys.c`, `block.c`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #include "threads/synch.h"
      #include "threads/vaddr.h"
      #include "threads/palloc.h"
      ```
      </details> 
- **`filesys.h`**
  - **`new header files`**
    - Includes `block.h` for `filesys.c`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #include "devices/block.h"
      ```
      </details>
- **`filesys.c`**
  - **`flush_buffer_cache()`**
    - This function will be called on a separate thread to flush the buffer cache periodically
      * That thread will be created in `filesys_init()`
      * In order to use this function, I included `timer.h`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #include "devices/timer.h"
      // other codes
      
      /* Periodically checks whether there's a dirty block.
        If there is, flush it */
      void *flush_buffer_cache(void *arg)
      {
        while (is_terminated == false) {
            timer_sleep(TIMER_FREQ * 5);     // waiting for 5 seconds

            lock_acquire(&buffer_cache_lock);
            for (int current_block_index = 0; current_block_index < BUFFER_CACHE_MAX_COUNT; ++current_block_index) {
                if (cached_mapping_table[current_block_index].target_block_device != NULL && cached_mapping_table[current_block_index].is_dirty) {
                    // Flush!
                    block_write(cached_mapping_table[current_block_index].target_block_device,
                                cached_mapping_table[current_block_index].sector_index,
                                cached_mapping_table[current_block_index].cached_block);
                    cached_mapping_table[current_block_index].is_dirty = false;
                }
            }
            lock_release(&buffer_cache_lock);
        }
        return NULL;
      }
      ```
      </details>
  - **`filesys_init()`**
    - Adds a part to initialize the buffer cache
    - Launches the dedicated thread for flushing the buffer cache periodically
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      filesys_init (bool format)
      {
        // Initialize buffer cache
        lock_init(&buffer_cache_lock);
        char *buffer_cache_page = palloc_get_page(PAL_USER | PAL_ZERO);
        for(  int current_entry_index = 0, end_page_count = PGSIZE/BLOCK_SECTOR_SIZE, current_page_count = 0
            ; current_entry_index < BUFFER_CACHE_MAX_COUNT
            ; ++current_entry_index, ++current_page_count) {

          if(current_page_count == end_page_count) {
            current_page_count = 0;
            buffer_cache_page = palloc_get_page(PAL_USER | PAL_ZERO);
          }
          
          cached_mapping_table[current_entry_index].target_block_device = NULL;
          cached_mapping_table[current_entry_index].cached_block = buffer_cache_page;

          buffer_cache_page += BLOCK_SECTOR_SIZE;
        }

        fs_device = block_get_role (BLOCK_FILESYS);
        // other codes
         dir_add (root_dir, ".", ROOT_DIR_SECTOR);
        // Execute dedicated thread for flushing the buffer cache periodically
        thread_create("bc_flusher", PRI_DEFAULT, flush_buffer_cache, NULL);
      }
      ```
      </details>
  - **`filesys_done()`**
    - Adds a part to flush the buffer cache
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      filesys_done (void)
      {
        free_map_close ();

        /* buffer cache */
        void *buffer_cache_page = cached_mapping_table[0].cached_block;
        for(  int current_entry_index = 0, end_page_count = PGSIZE/BLOCK_SECTOR_SIZE, current_page_count = 0
          ; current_entry_index < BUFFER_CACHE_MAX_COUNT
          ; ++current_entry_index, ++current_page_count) {

          if(current_page_count == end_page_count) {
            current_page_count = 0;
            palloc_free_page (buffer_cache_page);
            buffer_cache_page = cached_mapping_table[current_entry_index].cached_block;
          }
          
          // flush modified block
          if(cached_mapping_table[current_entry_index].is_dirty)
            block_write (cached_mapping_table[current_entry_index].target_block_device
                       , cached_mapping_table[current_entry_index].sector_index
                       , cached_mapping_table[current_entry_index].cached_block);
        }
      }
      ```
      </details>
- **`block.c`**
  - **`block_read_buffer_cache()`**
    - New function which reads the block from buffer cache
    - If the buffer cache is full, then it calls `evict_buffer_cache_entry()` to handle the issue
    - This function takes six parameters
      * the first three parameters are same as `block_read()`
      * the next three parameters are needed to handle the case where bounce buffer is needed
    - Adds codes to synchronize by using `buffer_cache_lock`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Reads from buffer cache */
      void
      block_read_buffer_cache (struct block *block, block_sector_t sector, void *buffer,
                              int32_t buffer_offset, int chunk_size, int cache_offset)
      {
        lock_acquire(&buffer_cache_lock);

        int current_entry_index = 0, temp_available_index = -1;
        for(; current_entry_index < BUFFER_CACHE_MAX_COUNT; ++current_entry_index) {
          if(temp_available_index == -1 && cached_mapping_table[current_entry_index].target_block_device == NULL)
            temp_available_index = current_entry_index;
          if(cached_mapping_table[current_entry_index].target_block_device != NULL && cached_mapping_table[current_entry_index].sector_index == sector) {
              break;
          }
        }
        if(current_entry_index == BUFFER_CACHE_MAX_COUNT) {
          // cache miss!
          // find free block
          if(temp_available_index == -1) {
            // if buffer cache is full, evict just like paging
            current_entry_index = evict_buffer_cache_entry();
          }
          else
            current_entry_index = temp_available_index;

          // read block from disk
          block->ops->read (block->aux, sector, cached_mapping_table[current_entry_index].cached_block);

          // update entry
          cached_mapping_table[current_entry_index].target_block_device = block;
          cached_mapping_table[current_entry_index].sector_index = sector;
          cached_mapping_table[current_entry_index].is_dirty = false;
        }
        // cache hit!
        memcpy(buffer + buffer_offset, cached_mapping_table[current_entry_index].cached_block + cache_offset, chunk_size);   
        cached_mapping_table[current_entry_index].is_accessed = true;

        lock_release(&buffer_cache_lock);
      }
      ```
      </details>
  - **`evict_buffer_cache_entry()`**
    - New function to evict the proper entry to evict by using clock algorithm
    - Flushes that entry if it's modified
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Evicts the least recently used block in buffer cache by using the clock algorithm
         Returns the index of it. */
      int
      evict_buffer_cache_entry()
      {
        static int current_clock_index = 0;

        bool is_full_cycle = false;
        int target_entry_index = current_clock_index;
        while(true) {
          if(current_clock_index == BUFFER_CACHE_MAX_COUNT) {
            current_clock_index = 0;
            if(is_full_cycle) {
              // Completed a full cycle; force selection of first loaded block
              // flush it if it's modified
              if(cached_mapping_table[current_clock_index].is_dirty) {
                block_write(cached_mapping_table[current_clock_index].target_block_device,
                  cached_mapping_table[current_clock_index].sector_index,
                  cached_mapping_table[current_clock_index].cached_block);
              }
              target_entry_index = current_clock_index;
              break;
            }
            else
              is_full_cycle = true;
          }

          if(cached_mapping_table[current_clock_index].is_accessed == false) {
            // flush it if it's modified
            if(cached_mapping_table[current_clock_index].is_dirty) {
              block_write(cached_mapping_table[current_clock_index].target_block_device,
                cached_mapping_table[current_clock_index].sector_index,
                cached_mapping_table[current_clock_index].cached_block);
            }
            target_entry_index = current_clock_index;
            break;
          }
          else
            cached_mapping_table[current_clock_index].is_accessed = false;
          ++current_clock_index;
        }

        ++current_clock_index;
        if(current_clock_index == BUFFER_CACHE_MAX_COUNT)
          current_clock_index = 0;
        return target_entry_index;
      }
      ```
      </details>
  - **`block_write_buffer_cache()`**
    - New function which write the block to buffer cache
    - If the buffer cache is full, then it calls `evict_buffer_cache_entry()` to handle the issue
    - This function takes six parameters
      * the first three parameters are same as `block_write()`
      * the next three parameters are needed to handle the case where bounce buffer is needed
    - Adds codes to synchronize by using `buffer_cache_lock`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Writes sector to buffer cache */
      void
      block_write_buffer_cache(struct block *block, block_sector_t sector, const void *buffer,
                              int32_t buffer_offset, int chunk_size, int cache_offset)
      {
        lock_acquire(&buffer_cache_lock);

        int current_entry_index = 0, temp_available_index = -1;
        for(; current_entry_index < BUFFER_CACHE_MAX_COUNT; ++current_entry_index) {
          if(temp_available_index == -1 && cached_mapping_table[current_entry_index].target_block_device == NULL)
            temp_available_index = current_entry_index;
          if(cached_mapping_table[current_entry_index].target_block_device != NULL && cached_mapping_table[current_entry_index].sector_index == sector) {
              break;
          }
        }
        if(current_entry_index == BUFFER_CACHE_MAX_COUNT) {
          // cache miss!
          // find free block
          if(temp_available_index == -1) {
            // if buffer cache is full, evict just like paging
            current_entry_index = evict_buffer_cache_entry();
          }
          else
            current_entry_index = temp_available_index;

          // read from the disk
          block->ops->read (block->aux, sector, cached_mapping_table[current_entry_index].cached_block);

          // update entry
          cached_mapping_table[current_entry_index].target_block_device = block;
          cached_mapping_table[current_entry_index].sector_index = sector;
        }
        // update entry
        memcpy(cached_mapping_table[current_entry_index].cached_block + cache_offset, buffer + buffer_offset, chunk_size);
        cached_mapping_table[current_entry_index].is_dirty = true;
        cached_mapping_table[current_entry_index].is_accessed = true;

        lock_release(&buffer_cache_lock);
      }
      ```
      </details>
- **`inode.c`**
  - **`struct inode`**
    - Adds new lock `inode_lock` for synchronization
      * It will be initialized in `inode_open()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* In-memory inode. */
      struct inode
      {
        struct list_elem elem;              /* Element in inode list. */
        block_sector_t sector;              /* Sector number of disk location. */
        int open_cnt;                       /* Number of openers. */
        bool removed;                       /* True if deleted, false otherwise. */
        int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
        struct inode_disk data;             /* Inode content. */

        struct lock inode_lock;             /* Lock for synchronization */
      };
      ```
      </details>
  - **`inode_read_at()`**
    - Modifies the call to read the block from `block_read()` to `block_read_buffer_cache()`
    - Adds codes to synchronize by using `inode_lock`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      off_t
      inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset)
      {
        uint8_t *buffer = buffer_;
        off_t bytes_read = 0;

        lock_acquire(&inode->inode_lock);

        while (size > 0)
        {
          /* Disk sector to read, starting byte offset within sector. */
          block_sector_t sector_idx = byte_to_sector (inode, offset);
          lock_release(&inode->inode_lock);
          int sector_ofs = offset % BLOCK_SECTOR_SIZE;

          /* Bytes left in inode, bytes left in sector, lesser of the two. */
          off_t inode_left = inode_length (inode) - offset;
          int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
          int min_left = inode_left < sector_left ? inode_left : sector_left;

          /* Number of bytes to actually copy out of this sector. */
          int chunk_size = size < min_left ? size : min_left;
          if (chunk_size <= 0) {
            lock_acquire(&inode->inode_lock);
            break;
          }

          // read from buffer cache
          block_read_buffer_cache (fs_device, sector_idx, buffer, bytes_read, chunk_size, sector_ofs);
          
          /* Advance. */
          size -= chunk_size;
          offset += chunk_size;
          bytes_read += chunk_size;
          lock_acquire(&inode->inode_lock);
        }

        lock_release(&inode->inode_lock);
        return bytes_read;
      }
      ```
      </details>
  - **`inode_write_at()`**
    - Modifies the call to write the block from `block_write()` to `block_write_buffer_cache()`
    - Adds codes to synchronize by using `inode_lock`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      off_t
      inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                    off_t offset)
      {
        const uint8_t *buffer = buffer_;
        off_t bytes_written = 0;

        if (inode->deny_write_cnt)
          return 0;

        lock_acquire(&inode->inode_lock);
        if(inode->data.length < offset + size) {
          if(!grow_file_length (&inode->data, inode->data.length, offset + size))
            exit(-1);
          block_write_buffer_cache(fs_device, inode->sector, &inode->data, 0, BLOCK_SECTOR_SIZE, 0);
        }
        while (size > 0)
        {
          /* Sector to write, starting byte offset within sector. */
          block_sector_t sector_idx = byte_to_sector (inode, offset);
          lock_release(&inode->inode_lock);
          int sector_ofs = offset % BLOCK_SECTOR_SIZE;
          /* Bytes left in inode, bytes left in sector, lesser of the two. */
          off_t inode_left = inode_length (inode) - offset;
          int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
          int min_left = inode_left < sector_left ? inode_left : sector_left;

          /* Number of bytes to actually write into this sector. */
          int chunk_size = size < min_left ? size : min_left;
          if (chunk_size <= 0) {
            lock_acquire(&inode->inode_lock);
            break;
          }

          // write to buffer cache
          block_write_buffer_cache(fs_device, sector_idx, buffer, bytes_written, chunk_size, sector_ofs);

          /* Advance. */
          size -= chunk_size;
          offset += chunk_size;
          bytes_written += chunk_size;

          lock_acquire(&inode->inode_lock);
        }
        lock_release(&inode->inode_lock);

        return bytes_written;
      }
      ```
      </details>
  - **`inode_open()`**
    - Modifies the call to write the block from `block_read()` to `block_read_buffer_cache()`
    - Initializes `inode_lock` of given inode structure
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct inode *
      inode_open (block_sector_t sector)
      {
        // other codes
        inode->deny_write_cnt = 0;
        inode->removed = false;

        block_read_buffer_cache (fs_device, inode->sector, &inode->data, 0, BLOCK_SECTOR_SIZE, 0);
        return inode;
      }
      ```
      </details>

### Conclusion
- Now PintOS has a buffer cache, increasing the performance of file I/O.
- However, there are two more objectives to achieve to complete the final project



## Part 2: Extensible Files

### Objective
- The goal is to modify the filesystem to change the file size dynamically

### Current Problem
- The current PintOS has only one data block for each inode.
- Although there's no size limit for that single data block,
  * this design is not efficient because it doesn't handle the case where another data block is stored right after the end of the first data block
  * in this case, that first data block is no longer able to be extended due to the lack of other pointers

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  struct inode_disk
  {
    block_sector_t start;               /* First data sector. */
    off_t length;                       /* File size in bytes. */
    unsigned magic;                     /* Magic number. */
    uint32_t unused[125];               /* Not used. */
  };
  ```
  </details>

### Solution
- I reimplemented `struct inode_disk` so that 
  * it contains multiple pointers to data blocks instead of having just starting address and size
- This revised design allows the extensible files of which size can be extended to `8.123 MB`
- In order to make this change be applicable to current file system
  * I replemented `byte_sector()`, `inode_create()`, `inode_close()`
  * Moreover, I created `grow_file_length()` for `inode_create()` and `free_data_blocks()` for `inode_close()`


### Implementation Details
- **`inode.c`**
  - **`struct inode_disk`**
    - Revised structure so that it now contains 124 direct data block pointers, two indirect data block pointers (single, double)
      - each pointer points to a sector index of given data block
      - hence, technially speaking it's not a pointer from the language perspective
      - but sector index logically means the address of the block in disk
    - The number 124 is chosen in order to fill all unused space in the block where the `inode_disk` object is allocated
    - I introduced the concept of indirect data blocks so that this structure can point to far more data blocks
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #define DIRECT_BLOCK_ENTRIES 124
      #define INDIRECT_BLOCK_ENTRIES (BLOCK_SECTOR_SIZE / sizeof (block_sector_t))

      struct inode_disk
      {
        off_t length;                       /* File size in bytes. */
        unsigned magic;                     /* Magic number. */
        block_sector_t direct_data_block_table [DIRECT_BLOCK_ENTRIES];
        block_sector_t single_indirect_data_block_sector_index;
        block_sector_t double_indirect_data_block_sector_index;
      };
      ```
      </details>
  - **`byte_to_sector()`**
    - This function returns the sector index of the block which contains the data based on the given offset
      * because I revised the design of how data blocks are configured, I reimplemented this function as well
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static block_sector_t
      byte_to_sector (const struct inode *inode, off_t pos)
      {
        ASSERT (inode != NULL);
        if (pos >= inode->data.length)
          return -1;

        off_t sector_index = pos / BLOCK_SECTOR_SIZE;
        if(sector_index < DIRECT_BLOCK_ENTRIES)
          return inode->data.direct_data_block_table[sector_index];

        sector_index -= DIRECT_BLOCK_ENTRIES;
        if(sector_index < INDIRECT_BLOCK_ENTRIES) {
          block_sector_t indirect_table[INDIRECT_BLOCK_ENTRIES];
          block_read_buffer_cache(fs_device, inode->data.single_indirect_data_block_sector_index, indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
          return indirect_table[sector_index];
        }

        sector_index -= DIRECT_BLOCK_ENTRIES;
        if(sector_index < INDIRECT_BLOCK_ENTRIES * INDIRECT_BLOCK_ENTRIES) {
          block_sector_t indirect_table[INDIRECT_BLOCK_ENTRIES];
          block_read_buffer_cache(fs_device, inode->data.double_indirect_data_block_sector_index, indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
          int double_table_index = sector_index/INDIRECT_BLOCK_ENTRIES;
          block_read_buffer_cache(fs_device, indirect_table[double_table_index], indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
          return indirect_table[sector_index - double_table_index * INDIRECT_BLOCK_ENTRIES];
        }

        return NULL;
      }
      ```
      </details>
  - **`grow_file_length()`**
    - This is the custom function to handle the extension of the file
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Handles the extension of the file */
      static bool 
      grow_file_length (struct inode_disk *inode_disk, off_t length, off_t new_length)
      {
        static char zeros[BLOCK_SECTOR_SIZE];
        if (length == new_length)
          return true;
        // if the request is to decrease the size, then ignore it
        if (length > new_length)
          return false;

        inode_disk->length = new_length;
        --new_length;   // this is necessary to avoid accessing invalid address; because the valid range is from [length, new_length - 1]

        // align the length as BLOCK_SECTOR_SIZE
        // this is necessary because the operation must be performed in the unit of block
        length = length / BLOCK_SECTOR_SIZE * BLOCK_SECTOR_SIZE;
        new_length = new_length / BLOCK_SECTOR_SIZE * BLOCK_SECTOR_SIZE;

        block_sector_t double_indirect_table[INDIRECT_BLOCK_ENTRIES], single_indirect_table[INDIRECT_BLOCK_ENTRIES];
        for (; length <= new_length; length += BLOCK_SECTOR_SIZE) {
          block_sector_t sector = byte_to_sector (inode_disk, length);
          // check whether the returned sector is valid or not by comparing it with the maximum value of block_sector_t
          // this works because at first, the whole sector is initialized by -1 through memset() in inode_create()
          // if it's valid, then move to the next sector
          if (sector != (block_sector_t) -1)
            continue;

          // if the sector was set to maximum value, then make it point to the valid data block
          if (!free_map_allocate (1, &sector))
            return false;
          // find out which table is used to contain the information for this sector
          off_t sector_index = length / BLOCK_SECTOR_SIZE;
          if(sector_index < DIRECT_BLOCK_ENTRIES)
            inode_disk->direct_data_block_table[sector_index] = sector;
          else {
            sector_index -= DIRECT_BLOCK_ENTRIES;
            if(sector_index < INDIRECT_BLOCK_ENTRIES) {     
              // case for single-indirect
              if (inode_disk->single_indirect_data_block_sector_index == (block_sector_t) -1) {
                // if the indirect table is not allocated, then allocate new one
                if (!free_map_allocate (1, &inode_disk->single_indirect_data_block_sector_index))
                  return false;
                // then, initialize the contents as -1 just like inode_create()
                memset (single_indirect_table, -1, BLOCK_SECTOR_SIZE);
              }
              else {
                // if the indirect table exists, then read from it to load indirect table
                block_read_buffer_cache(fs_device, inode_disk->single_indirect_data_block_sector_index, single_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
              }
            
              single_indirect_table[sector_index] = sector;
              // update the block which contains indirect table
              block_write_buffer_cache(fs_device, inode_disk->single_indirect_data_block_sector_index, single_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
            }
            else {
              // case for double-indirect
              sector_index -= DIRECT_BLOCK_ENTRIES;
            
              if (inode_disk->double_indirect_data_block_sector_index == (block_sector_t) -1) {
                // if the double indirect table is not allocated, then allocate new one
                if (!free_map_allocate (1, &inode_disk->double_indirect_data_block_sector_index))
                  return false;
                // then, initialize the contents as -1 just like inode_create()
                memset (double_indirect_table, -1, BLOCK_SECTOR_SIZE);
              }
              else {
                // if the double indirect table exists, then read from it to load double indirect table
                block_read_buffer_cache(fs_device, inode_disk->double_indirect_data_block_sector_index, double_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
              }

              int double_table_index = sector_index/INDIRECT_BLOCK_ENTRIES;
              if (double_indirect_table[double_table_index] == (block_sector_t) -1) {
                // if the single indirect table is not created after accessing the first pointer, then create it as well
                if (!free_map_allocate (1, &double_indirect_table[double_table_index]))
                  return false;
                memset (single_indirect_table, -1, BLOCK_SECTOR_SIZE);
                // update the block which contains double indirect table
                block_write_buffer_cache(fs_device, inode_disk->double_indirect_data_block_sector_index, double_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
              }
              else {
                // if the indirect table exists, then read from it to load indirect table
                block_read_buffer_cache(fs_device, double_indirect_table[double_table_index], single_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
              }

              single_indirect_table[sector_index - double_table_index*INDIRECT_BLOCK_ENTRIES] = sector;
              // update the block which contains indirect table
              block_write_buffer_cache(fs_device, double_indirect_table[double_table_index], single_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
            }
          }
          // initialize the new sector as 0
          block_write_buffer_cache(fs_device, sector, zeros, 0, BLOCK_SECTOR_SIZE, 0);
        }
        return true;
      }
      ```
      </details>
  - **`inode_create()`**
    - I reimplemented this function to apply `grow_file_length()`
    - Moreover, it writes to buffer cache instead of disk directly
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      inode_create (block_sector_t sector, off_t length)
      {
        struct inode_disk *disk_inode = NULL;
        bool success = false;

        ASSERT (length >= 0);

        /* If this assertion fails, the inode structure is not exactly
          one sector in size, and you should fix that. */
        ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

        disk_inode = calloc (1, sizeof *disk_inode);
        if (disk_inode != NULL) {
          // initialize disk_inode as -1, leading to the maximum number of block_sector_t because it is unsigned type
          memset (disk_inode, -1, BLOCK_SECTOR_SIZE);
          disk_inode->length = 0;
          if (!grow_file_length(disk_inode, disk_inode->length, length)) {
            free(disk_inode);
            return false;
          }
          disk_inode->magic = INODE_MAGIC;
          
          block_write_buffer_cache(fs_device, sector, disk_inode, 0, BLOCK_SECTOR_SIZE, 0);
          free (disk_inode);
          success = true;
        }
        return success;
      }
      ```
      </details>
  - **`inode_write_at()`**
    - I revised this function to support file growth by calling `grow_file_length()` 
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      if (inode->deny_write_cnt)
        return 0;

      lock_acquire(&buffer_cache_lock);
      if(inode->data.length < offset + size) {
        lock_release(&buffer_cache_lock);
        if(!grow_file_length (&inode->data, inode->data.length, offset + size))
          exit(-1);
        lock_acquire(&buffer_cache_lock);
        block_write_buffer_cache(fs_device, inode->sector, &inode->data, 0, BLOCK_SECTOR_SIZE, 0);
      }

      while (size > 0)
      // other codes
      ```
      </details>
  - **`free_data_blocks()`**
    - I created this function to free all sectors related to the given on-disk inode
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void free_data_blocks (struct inode_disk *inode_disk)
      {
        int current_count;
        for (current_count = 0; current_count < DIRECT_BLOCK_ENTRIES; ++current_count) {
          if (inode_disk->direct_data_block_table[current_count] == (block_sector_t) -1)
            break;
          free_map_release(inode_disk->direct_data_block_table[current_count], 1);
        }

        if (inode_disk->single_indirect_data_block_sector_index == (block_sector_t) -1)
          return;
        block_sector_t indirect_table[INDIRECT_BLOCK_ENTRIES];
        block_read_buffer_cache(fs_device, inode_disk->single_indirect_data_block_sector_index, indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
        for (current_count = 0; current_count < INDIRECT_BLOCK_ENTRIES; ++current_count) {
          if (indirect_table[current_count] == (block_sector_t) -1)
            break;
          free_map_release(indirect_table[current_count], 1);
        }
        free_map_release(inode_disk->single_indirect_data_block_sector_index, 1);

        if (inode_disk->double_indirect_data_block_sector_index == (block_sector_t) -1)
          return;
        block_sector_t double_indirect_table[INDIRECT_BLOCK_ENTRIES];
        block_read_buffer_cache(fs_device, inode_disk->double_indirect_data_block_sector_index, double_indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
        for (current_count = 0; current_count < INDIRECT_BLOCK_ENTRIES; ++current_count) {
          if (double_indirect_table[current_count] == (block_sector_t) -1)
            break;
          block_read_buffer_cache(fs_device, double_indirect_table[current_count], indirect_table, 0, BLOCK_SECTOR_SIZE, 0);
          for (current_count = 0; current_count < INDIRECT_BLOCK_ENTRIES; ++current_count) {
            if (indirect_table[current_count] == (block_sector_t) -1)
              break;
            free_map_release(indirect_table[current_count], 1);
          }
          free_map_release(double_indirect_table[current_count], 1);
        }
        free_map_release(inode_disk->double_indirect_data_block_sector_index, 1);
      }
      ```
      </details>
  - **`inode_close()`**
    - I reimplemented this function to apply `free_data_blocks()` when the inode is being closed
      - Moreover, I flushed the inode itself to disk when last inode is closed
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      inode_close (struct inode *inode) 
      {
        /* Ignore null pointer. */
        if (inode == NULL)
          return;

        /* Release resources if this was the last opener. */
        if (--inode->open_cnt == 0)
          {
            // write the inode to buffer cache
            block_write_buffer_cache(fs_device, inode->sector, &inode->data, 0, BLOCK_SECTOR_SIZE, 0);

            /* Remove from inode list and release lock. */
            list_remove (&inode->elem);
      
            /* Deallocate blocks if removed. */
            if (inode->removed)  {
              free_data_blocks(&inode->data);
              free_map_release(inode->sector, 1);
            }    

            free (inode); 
          }
      }
      ```
      </details>


### Conclusion
- Thanks to this improvement, the file can be grown up to 8 MB.
- Now we have only one task remaining: Subdirectories



## Part 3: Subdirectories

### Objective
- The goal is to implement a hierarchical directory structure so that subdirectries can be made

### Current Problem
- The current PintOS doesn't have system calls related to directory

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  static void syscall_handler(struct intr_frame* f)
  {
    int *current_esp = f->esp;
    if(is_valid_address(current_esp) == false)
      return;

    switch (current_esp[0])
    {
      case SYS_HALT: halt(); break;
      case SYS_EXIT: exit(current_esp[1]); break;
      case SYS_EXEC: f->eax = exec(current_esp[1]); break;
      case SYS_WAIT: f->eax = wait(current_esp[1]); break;
      case SYS_CREATE: f->eax = create(current_esp[1], current_esp[2]); break;
      case SYS_REMOVE: f->eax = remove(current_esp[1]); break;
      case SYS_OPEN: f->eax = open(current_esp[1]); break;
      case SYS_FILESIZE: f->eax = filesize(current_esp[1]); break;
      case SYS_READ: f->eax = read(current_esp[1], current_esp[2], current_esp[3]); break;
      case SYS_WRITE: f->eax = write(current_esp[1], current_esp[2], current_esp[3]); break;
      case SYS_SEEK: seek(current_esp[1], current_esp[2]); break;
      case SYS_TELL: f->eax = tell(current_esp[1]); break;
      case SYS_CLOSE: close(current_esp[1]); break;

      case SYS_MMAP: f->eax = mmap(current_esp[1], current_esp[2]); break;
      case SYS_MUNMAP: munmap(current_esp[1]); break;

      case SYS_CHDIR: /* missing! */ break;
      case SYS_MKDIR: /* missing! */ break;
      case SYS_READDIR: /* missing! */ break;
      case SYS_ISDIR: /* missing! */ break;
      case SYS_INUMBER: /* missing! */ break;
    }
  }
  ```
  </details>

### Solution
- I revised the entire file system so that 
  * It becomes possible to distinguish whether current file is directory or not by checking its on-disk inode
  * The `struct thread` contains current directory (`.`)
- In order to implement such system calls
  * I reconstructed `struct inode_disk` so that it now has a flag, `is_directory`, to check whether the file is directory or not
    + Moreover, I reimplemented `inode_create()` to get an addtional parameter for this flag so that the flag can be set when new inode object is created
    + Hence, I also modified all functions which call `inode_create()` to pass the addtional flag
  * I reimplemented `filesys_init()` so that the main thread gets its current directory because every thread now has its own current directory entry
    + Furthermore, I made the child thread inherit the current directory from its parent thread in in `thread_create()` by calling `dir_reopen()`
- Lastly, I created new function `parse_path()` to parse the deep path 

### Implementation Details
- **`thread.h`**
  - **`struct thread`**
    - Adds a new data member, `current_directory`, which is `struct dir *` to current directory for each thread
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      struct dir *current_directory;
      // other codes
      ```
      </details>
- **`inode.c`**
  - **`struct inode_disk`**
    - Now it has `is_directory` which is a flag to check whether current file is directory or not
      * the type of this flag is `block_sector_t` to align the size
      * because one `block_sector_t` is used as the flag, the total count of `DIRECT_BLOCK_ENTRIES` gets decreased by 1
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #define DIRECT_BLOCK_ENTRIES 123

      struct inode_disk
      {
        off_t length;                       /* File size in bytes. */
        unsigned magic;                     /* Magic number. */
        
        block_sector_t is_directory; 
        
        block_sector_t direct_data_block_table [DIRECT_BLOCK_ENTRIES];
        block_sector_t single_indirect_data_block_sector_index;
        block_sector_t double_indirect_data_block_sector_index;
      };
      ```
      </details>
  - **`inode_create()`**
    - It now takes an addtional boolean flag to check whether the file is directory or not
      - due to this change, `filesys_create()`, `dir_create()`, and `free_map_create()` needed to be updated as well
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      inode_create (block_sector_t sector, off_t length, bool is_directory_given)
      {
        // same codes
        disk_inode->magic = INODE_MAGIC;
        disk_inode->is_directory = is_directory_given;   // new code
        
        block_write_buffer_cache(fs_device, sector, disk_inode, 0, BLOCK_SECTOR_SIZE, 0);
        // same codes
      }
      ```
      </details>
  - **`is_inode_valid_directory()`**
    - A new function to check whether current inode is valid as the inode for the directory
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool is_inode_valid_directory(const struct inode *inode)
      {
        return inode->removed == false && inode->data.is_directory == true;
      }
      ```
      </details>
- **`inode.h`**
  - **`The modification of declarations`**
    - The declaration of `inode_create()` also needs to be modified
    - The declaration of `is_inode_valid_directory()` needs to be added as well
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      bool inode_create (block_sector_t, off_t, bool);

      bool is_inode_valid_directory(const struct inode *inode);
      // other codes
      ```
      </details>
- **`filesys.c`**
  - **`filesys_create()`**
    - This function is modified to apply the change of `inode_create()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      filesys_create (const char *path, off_t initial_size) 
      {
        block_sector_t inode_sector = 0;
        char name[PATH_MAX_LENGTH + 1];
        struct dir *dir = parse_path(path, name);

        bool success = (dir != NULL
                        && free_map_allocate (1, &inode_sector)
                        && inode_create (inode_sector, initial_size, false)
                        && dir_add (dir, name, inode_sector));
        if (!success && inode_sector != 0) 
          free_map_release (inode_sector, 1);
        dir_close (dir);

        return success;
      }
      ```
      </details>
  - **`filesys_init()`**
    - Sets the current directory of main thread as root directory
    - In order to call `thread_current()`, I included `thread.h`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #include "threads/thread.h"
      // other codes
      void
      filesys_init (bool format) 
      {  
        // other codes
        free_map_open();

        // Initialize current directory of main thread
        struct dir *root_dir = dir_open_root();
        thread_current()->current_directory = root_dir;
        dir_add (root_dir, ".", ROOT_DIR_SECTOR);
      }
      ```
      </details>
  - **`parse_path()`**
    - A new function to return the directory entry of given `original_path`
    - `PATH_MAX_LENGTH` is defined in `filesys.h`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct dir *parse_path (const char *original_path, char *file_name) {
        struct dir *dir = NULL;
        if (!original_path || !file_name)
          return NULL;
        if (strlen(original_path) == 0)
          return NULL;

        char path[PATH_MAX_LENGTH + 1];
        strlcpy(path, original_path, PATH_MAX_LENGTH);

        if (path[0] == '/')
          dir = dir_open_root ();
        else
          dir = dir_reopen(thread_current()->current_directory);

        if(is_inode_valid_directory(dir_get_inode(dir)) == false)
          return NULL;

        char *token, *next_token, *save_ptr;
        token = strtok_r(path, "/", &save_ptr);
        next_token = strtok_r(NULL, "/", &save_ptr);

        if(token == NULL) {
          strlcpy(file_name, ".", PATH_MAX_LENGTH);
          return dir;
        }

        while(token && next_token) {
          struct inode *inode = NULL;
          if(!dir_lookup (dir, token, &inode)) {
            dir_close(dir);
            return NULL;
          }
          if (is_inode_valid_directory(inode) == false) {
            dir_close(dir);
            return NULL;
          }
          dir_close(dir);
          dir = dir_open(inode);

          token = next_token;
          next_token = strtok_r(NULL, "/", &save_ptr);
        }
        strlcpy(file_name, token, PATH_MAX_LENGTH);
        return dir;
      }
      ```
      </details>
  - **`filesys_create_dir()`**
    - A new function to create a directory when `mkdir()` is called
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Creates a directory */
      bool filesys_create_dir(const char *path) {
        block_sector_t inode_sector = 0;
        char name[PATH_MAX_LENGTH + 1];
        struct dir *dir = parse_path(path, name);

        bool success = (dir != NULL
                        && free_map_allocate (1, &inode_sector)
                        && dir_create (inode_sector, 16)
                        && dir_add (dir, name, inode_sector));
        if(!success && inode_sector != 0)
          free_map_release (inode_sector, 1);

        if(success) {
          struct dir *new_dir = dir_open(inode_open(inode_sector));
          dir_add (new_dir, ".", inode_sector);
          dir_add (new_dir, "..", inode_get_inumber(dir_get_inode(dir)));
          dir_close (new_dir);
        }
        dir_close (dir);
        return success;
      }
      ```
      </details>
  - **`filesys_open()`**
    - This function is modified to apply `parse_path()` 
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct file *
      filesys_open(const char *path)
      {
        char name[PATH_MAX_LENGTH + 1];
        struct dir *dir = parse_path(path, name);
        struct inode *inode = NULL;

        if(dir != NULL)
          dir_lookup(dir, name, &inode);
        dir_close(dir);

        return file_open(inode);
      }
      ```
  - **`filesys_remove()`**
    - This function is modified to apply `parse_path()` 
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      filesys_remove (const char *path)  {
        char name[PATH_MAX_LENGTH + 1];
        struct dir *dir = parse_path(path, name);
        bool success = false;

        if(dir != NULL) {
          struct inode *target_inode = NULL;
          if(dir_lookup(dir, name, &target_inode) == false)
            return false;
          if(is_inode_valid_directory(target_inode) == false) {
            inode_close(target_inode);
            success = dir_remove(dir, name);
          }
          else {
            char temp_name[PATH_MAX_LENGTH + 1];
            struct dir *dir_to_check = dir_open(target_inode);
            char previous_name[PATH_MAX_LENGTH + 1];
            for(int i = 0; i < 3; ++i) {
              dir_readdir(dir_to_check, temp_name);
              if(strcmp(temp_name, "..") == 0 && strcmp(previous_name, temp_name) == 0) {
                success = true;
                break;
              }
              strlcpy(previous_name, temp_name, sizeof(previous_name));
            }
            dir_close(dir_to_check);
            // remove directory only it's empty
            if(success)
              success = dir_remove(dir, name);
          }
        }

        dir_close(dir);
        return success;
      }
      ```
- **`filesys.h`**
  - **`The modification of declarations`**
    - New declaration for `parse_path()` and `filesys_create_dir()` need to be added
    - Sets `PATH_MAX_LENGTH` as 128
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #define PATH_MAX_LENGTH 128
      // other codes
      struct dir *parse_path(const char *original_path, char *file_name);
      bool filesys_create_dir(const char *path);
      ```
      </details>
- **`directory.c`**
  - **`dir_create()`**
    - This function is modified to apply the change of `inode_create()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      dir_create (block_sector_t sector, size_t entry_cnt)
      {
        return inode_create (sector, entry_cnt * sizeof (struct dir_entry), true);
      }
      ```
      </details>
- **`free-map.c`**
  - **``free_map_create()`**
    - This function is modified to apply the change of `inode_create()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      free_map_create (void) 
      {
        /* Create inode. */
        if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))   // modified
          PANIC ("free map creation failed");
        // other codes
      }
      ```
      </details>
- **`thread.c`**
  - **`init_thread()`**
    - Initializes `current_directory` as `NULL`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      t->current_available_map_id = 0;

      t->current_directory = NULL;  // new code

      old_level = intr_disable ();
      // other codes
      ```
      </details>
  - **`thread_create()`**
    - Make the child thread inherit `current_directory` of current thread
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      #ifdef USERPROG
      /* push child process to parent */
      list_push_back(&thread_current()->children, &t->childelem);
      #endif

      /* Make the child thread inherit the current directory from its parent thread */
      if (thread_current()->current_directory)
        t->current_directory = dir_reopen(thread_current()->current_directory);

      /* Add to run queue. */
      thread_unblock(t);
      // other codes
      ```
      </details>
- **`syscall.c`**
  - Now it's time to achieve our last objective
  - **`The inclusion of a header file`**
    - in order to use the current revised design of file system, I included `filesys.h` instead of `vaddr.h`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #include "vm/page.h"
      #include "filesys/filesys.h"
      // other codes
      ```
  - **`chdir()`**
    - changes current working directory (`current_directory`) of the process to `dir`
    - returns `true` if successful, `false` otherwise
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool chdir(const char *path_original) {
        char path[PATH_MAX_LENGTH + 1];
        strlcpy(path, path_original, PATH_MAX_LENGTH);
        strlcat(path, "/0", PATH_MAX_LENGTH);

        char name[PATH_MAX_LENGTH + 1];
        struct dir *dir = parse_path(path, name);
        if(!dir)
          return false;
        dir_close(thread_current()->current_directory);
        thread_current()->current_directory = dir;
        return true;
      }
      ```
      </details>
  - **`mkdir()`**
    - creates the director named `dir`
    - returns `true` if successful, `false` otherwise
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool mkdir(const char *dir) {
        return filesys_create_dir(dir);
      }
      ```
      </details>
  - **`readdir()`**
    - reads a directory entry from file descriptor `fd`, which must represent a directory
    - if successful, stores file name in name and returns `true`
      - returns `false` otherwise
    - `.` and `..` should not be returned by `readdir()`
      - otherwise, this leads to calling itself
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool readdir(int fd, char *name) {
        struct file *target_file = thread_current()->fd_table[fd];
        if(target_file == NULL)
          exit(-1);
        struct inode *target_inode = file_get_inode(target_file); 
        if(target_inode == NULL || is_inode_valid_directory(target_inode) == false)
          return false;
        struct dir *dir = dir_open(target_inode);
        if(dir == NULL)
          return false;

        bool was_parent_previously = false;
        if(strcmp(name, "..") == 0)
          was_parent_previously = true;

        int current_count;
        bool result = true;
        off_t *pos = (off_t *)target_file + 1;
        for(current_count = 0; current_count <= *pos && result; ++current_count)
          result = dir_readdir(dir, name);
        if(current_count <= *pos == false)
          ++(*pos);

        if(was_parent_previously && strcmp(name, "..") == 0)
          return false;

        if(strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
          return readdir(fd, name);

        return result;
      }
      ```
      </details>
  - **`isdir()`**
    - returns `true` if `fd` represents a directory
      - returns `false` otherwise
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool isdir(int fd) {
        struct file *target_file = thread_current()->fd_table[fd];

        if(target_file == NULL)
          exit(-1);
        return is_inode_valid_directory(file_get_inode(target_file));
      }
      ```
      </details>
  - **`inumber()`**
    - returns the inode number of the inode associated with `fd`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      block_sector_t inumber(int fd) {
        struct file *target_file = thread_current()->fd_table[fd];
        if(target_file == NULL)
          exit(-1);
        return inode_get_inumber(file_get_inode(target_file));
      }
      ```
      </details>
  - **`write()`**
    - This function is modified to call `exit(-1)` if current file is directory
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      // other codes
      if(
          fd < 0 
          || fd >= FD_TABLE_MAX_SLOT 
          || thread_current()->fd_table[fd] == NULL 
          || is_inode_valid_directory(file_get_inode(thread_current()->fd_table[fd])))  // new condition
        exit(-1);

      lock_acquire(&filesys_lock);
      // other codes 
      ```
      </details>
  - **`syscall_handler()`**
    - This function is modified to call new system calls regarding directory
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void syscall_handler(struct intr_frame* f) 
      {
        int *current_esp = f->esp;

        if(is_valid_address(current_esp) == false)
          return;

        switch (current_esp[0])
        {
          case SYS_HALT: halt(); break;
          case SYS_EXIT: exit(current_esp[1]); break;
          case SYS_EXEC: f->eax = exec(current_esp[1]); break;
          case SYS_WAIT: f->eax = wait(current_esp[1]); break;
          case SYS_CREATE: f->eax = create(current_esp[1], current_esp[2]); break;
          case SYS_REMOVE: f->eax = remove(current_esp[1]); break;
          case SYS_OPEN: f->eax = open(current_esp[1]); break;
          case SYS_FILESIZE: f->eax = filesize(current_esp[1]); break;
          case SYS_READ: f->eax = read(current_esp[1], current_esp[2], current_esp[3]); break;
          case SYS_WRITE: f->eax = write(current_esp[1], current_esp[2], current_esp[3]); break;
          case SYS_SEEK: seek(current_esp[1], current_esp[2]); break;
          case SYS_TELL: f->eax = tell(current_esp[1]); break;
          case SYS_CLOSE: close(current_esp[1]); break;

          case SYS_MMAP: f->eax = mmap(current_esp[1], current_esp[2]); break;
          case SYS_MUNMAP: munmap(current_esp[1]); break;

          case SYS_CHDIR: f->eax = chdir(current_esp[1]); break;
          case SYS_MKDIR: f->eax = mkdir(current_esp[1]); break;
          case SYS_READDIR: f->eax = readdir(current_esp[1], current_esp[2]); break;
          case SYS_ISDIR: f->eax = isdir(current_esp[1]); break;
          case SYS_INUMBER: f->eax = inumber(current_esp[1]); break;
        }
        }
      ```
      </details>

### Conclusion
- 

### Improved Grade


## Final Thoughts
- Th

[Top](#){: .btn .btn--primary }{: .align-right}