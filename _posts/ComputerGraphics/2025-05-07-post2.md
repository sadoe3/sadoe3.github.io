---
title: "Computer Graphics: Materials"

categories:
    - graphics

tags:
    - [computer graphics, graphics, materials, ray tracing, physics, 3D math, vector, matrix, linear algebra]

toc: true
toc_label: "Table of Contents"
toc_sticky: true
mathjax: true

date: 2025-05-07
---

# Materials
This report explains the fundamental concepts of implementing various materials—diffuse, metallic, and dielectric-in a ray tracing renderer.

## **Ray Tracing**
- Before diving into the materials, it is crucial to understand the core principles of ray tracing at first.

---
### **Forward vs. Backward Path Tracing**
- In the real world, light rays originate from light sources and travel through a scene, bouncing off surfaces until they reach an observer's eye.
    - This process is known as **light tracing** or **forward path tracing**.
- However, directly simulating this is computationally inefficient.
    - Only a minuscule fraction of the light rays emitted from a source will ever reach the camera, resulting in wasted computation.
- While forward path tracing can be effective for specific scenarios like rendering caustics, most modern ray tracers use a different approach.
    - **Backward path tracing** (or simply "path tracing") works in the opposite direction.
    - It casts rays from the camera (or eye) into the scene.
- This approach is significantly more efficient.
    - Because it ensures that every ray calculated contributes to a visible pixel on the screen.
- In this model, a ray is traced from a pixel on the camera's sensor into the scene.
    - If the ray intersects an object, a new ray is scattered from that intersection point.
        - This process continues recursively until the ray either hits a light source, or a maximum bounce limit is reached.
    - If the ray ultimately hits a light source,
        - it carries a contribution of that light's color back to the camera, which is then attenuated by the properties of each surface it interacted with.
    - If the ray never hits a light,
        - it is assigned a default background color (often black).

### **Diffuse Albedo**
- The **diffuse albedo** is a material property that defines the percentage of incoming light that a surface reflects uniformly in all directions.
- For example, a surface with an albedo of $[0.3, 0.7, 1.0]$ will absorb $70\%$ of the red, $30\%$ of the green, and $0\%$ of the blue components of the incoming light.
    - The remaining light, modulated by the albedo, is what gives the object its color.

### **Light Intensity**
- The intensity of light received by a surface depends on the angle between the surface normal and the incoming light ray.
    - The maximum intensity is achieved when the light ray is parallel to the surface normal, and it decreases as the angle increases.
- This relationship is described by **Lambert's Cosine Law**.
    $$
    I_{reflected} = I_{original} * cos\theta
    $$
    - The angle $\theta$ is the angle between the surface normal and the incoming light ray.
    - The intensity is typically constrained to be non-negative by utilizing a function such as $max(0,cos\theta)$.

### **Recursive Calculation**
- To calculate the final color of a pixel, ray tracers use a recursive function.
    - A ray is traced from the camera, and at each bounce, the color is determined by a product of the surface's properties and the color from the subsequent ray.
- The core recursive formula can be generalized as:
    $$
    \text{color}_{\text{reflected}} = \text{intensity}_{\text{light}} \times \text{albedo}_{\text{current}} \times 
    \text{color}_{\text{incoming}}
    $$
- The recursion terminates in one of three cases:
    1. **A ray hits a light source**
        - The recursion ends, and a color of light source (e.g., white) is returned.
    2. **A ray hits nothing**
        - The recursion ends, and a background or skybox color is returned.
    3. **The maximum recursion depth is reached**
        - The ray is assumed to have lost all its energy, and the function returns black.
        - This is a crucial optimization to prevent infinite loops and limit computation.
            - A common maximum depth is between 5 and 10 bounces.

## **Light Absorption and Filtering**
- The color of a ray is not a constant value.
    - It is a cumulative property that is filtered at each surface it interacts with.

---
### **Scenario 1: Ray Annihilation**
- A ray can effectively "die" if it is filtered by a surface that completely absorbs its color components.
- **Initial state**
    - A white ray (RGB = $[1, 1, 1]$)
- **Bounce 1**
    - The ray hits a pure red object (albedo $[1, 0, 0]$).
    - The ray's color becomes red, losing its green and blue components.
- **Bounce 2**
    - The now-red ray hits a pure green object (albedo $[0, 1, 0]$).
    - The object absorbs all red light, and since there are no green or blue components left in the ray, the ray's color becomes black (RGB = $[0, 0, 0]$).
    - The ray effectively dies and no longer contributes to the final image.

### **Scenario 2: Ray Survival**
- If a ray's color and an object's albedo have overlapping color components, the ray can survive multiple bounces, albeit with reduced intensity.
- This is what creates complex and realistic colors.
    - **Initial state**
        - A white ray (RGB = $[1, 1, 1]$).
    - **Bounce 1**
        - Hits a reddish object (albedo $[0.8, 0.2, 0.2]$).
        - The ray becomes a reddish light.
    - **Bounce 2**
        - Hits a greenish object (albedo $[0.3, 0.7, 0.3]$).
        - The ray becomes a dimmer, mixed-color light.
    - **Bounce 3**
        - Hits a bluish object (albedo $[0.4, 0.4, 0.8]$).
        - The ray's final color is a very dim, mixed-color light.
- The final pixel value is the cumulative result of all these color-filtering interactions, which is why a single ray's journey through a scene is what determines the final pixel's color.


## **Material Modeling for Physically-Based Rendering**
The appearance of an object is defined by how its surface interacts with light. In ray tracing, this interaction is modeled by a material's scattering properties. When a ray hits a surface, the material determines if the ray is absorbed, how it is attenuated (its color changed), and in what direction a new scattered ray will travel. This section details the implementation of three fundamental material types: diffuse (Lambertian), specular (metallic), and imperfect specular (fuzzy metal).

---

### **Diffuse Materials (Lambertian Reflection)**

Diffuse surfaces, such as matte paint or chalk, scatter incoming light in many directions. The ideal model for this behavior is **Lambertian reflection**.

#### **Governing Principle: Lambert's Cosine Law**

The apparent brightness of a Lambertian surface depends on its orientation relative to the incoming light. **Lambert's Cosine Law** states that the intensity of reflected light is proportional to the cosine of the angle, $\theta$, between the surface **normal vector** ($N$) and the **light vector** ($L$).

$$I_{\text{reflected}} = I_{\text{incoming}} \cdot \cos(\theta)$$

This relationship is intuitive: a surface appears brightest when it directly faces a light source ($\theta = 0^\circ, \cos\theta = 1$) and its brightness falls off as the angle increases.

In practice, calculating $\cos(\theta)$ directly is computationally expensive. A more efficient method is to use the dot product of the two corresponding unit vectors. If both the surface normal $N$ and the light direction $L$ are normalized, the cosine term is simply their dot product: $\cos(\theta) = N \cdot L$. To prevent negative light intensity from rays originating behind the surface, the result is clamped to zero using `max(0, N·L)`.

#### **Implementation: Hemisphere Sampling**

To simulate this scattering, a new, randomized ray direction must be generated from the hit point, originating within the hemisphere aligned with the surface normal. A common and simple technique for this is **rejection sampling**:

1.  **Generate a Random Point in a Unit Cube**: A random point $(x, y, z)$ is generated where each component is in the range $[-1, 1]$.
2.  **Reject Invalid Samples**: If the generated point lies outside the unit sphere (i.e., its squared length $x^2 + y^2 + z^2 \ge 1$), it is discarded, and the process repeats until a valid point inside the sphere is found.
3.  **Normalize to Find Surface Point**: The valid point inside the sphere is normalized to produce a random unit vector. This vector represents a random point on the surface of the unit sphere.
4.  **Align with Surface Normal**: The final scattered ray must originate from the hemisphere oriented by the surface normal. To ensure this, the dot product between the random vector and the surface normal is checked. If the result is negative, the random vector is facing "into" the surface and must be inverted.

This process generates a uniformly distributed random direction on the hemisphere, providing a simple basis for simulating diffuse reflection.

---

### **Specular and Metallic Materials**

Unlike diffuse surfaces, polished metals exhibit **specular reflection**, where light reflects in a predictable, mirror-like direction rather than scattering.

#### **Calculating the Reflection Vector**

For a perfect mirror, the reflection angle equals the incidence angle. The direction of the reflected ray ($V'$) can be calculated from the incoming ray's direction ($V$) and the surface normal ($N$).



The formula for this calculation is:
$$V' = V - 2(V \cdot N)N$$

Here, $V$ is the direction of the incoming ray, and $N$ is the unit normal of the surface at the hit point. The term $(V \cdot N)N$ represents the projection of $V$ onto the normal vector $N$. Subtracting twice this projection from the original vector $V$ effectively reflects it across the normal. This calculation is implemented directly, as shown in the provided `getReflectedMirror` function.

#### **Imperfect Specular (Fuzzy) Reflection**

Many metallic surfaces are not perfect mirrors but have microscopic imperfections that cause reflections to be blurry or "fuzzy." This effect can be simulated by perturbing the ideal reflection vector.

The implementation builds upon the perfect specular reflection:

1.  The ideal reflection vector $V'$ is calculated as described above.
2.  A random unit vector is generated and scaled by a `fuzz` parameter, which controls the radius of a small "perturbation sphere."
3.  This scaled random vector is added to the endpoint of the ideal reflection vector, creating a new, slightly randomized direction.
4.  A critical edge case must be handled: for high `fuzz` values or reflections at grazing angles, the perturbed ray may scatter *below* the surface. Such rays should be absorbed by the material. This is checked by taking the dot product of the new scattered ray's direction and the surface normal. A positive result confirms the ray is traveling away from the surface.

The `fuzz` parameter allows for a continuous blend from a perfect mirror (`fuzz = 0`) to a very rough, blurry reflective surface (`fuzz = 1`). As seen in the provided `Metal` class, normalizing the ideal reflection vector before adding the perturbation ensures a consistent effect regardless of the incoming ray's geometry.

---

## **Material Implementation: Dielectrics and Refraction**

Transparent materials like water, glass, and diamond are classified as **dielectrics**. Unlike opaque surfaces, when a light ray intersects a dielectric, it splits into two components: a **reflected ray** that bounces off the surface and a **refracted ray** that passes through the material, bending in the process. Accurately simulating this behavior requires modeling both the direction of the refracted ray and the energy distribution between reflection and refraction.

---
### **The Direction of Refraction: Snell's Law**
The bending of light as it enters a new medium is described by **Snell's Law**. This principle relates the angles of incidence and refraction to the **refractive index** ($\eta$) of the respective media.

$$\eta_i \sin\theta_i = \eta_t \sin\theta_t$$

Here, $\theta_i$ and $\theta_t$ are the angles of the incident and transmitted rays with respect to the surface normal, and $\eta_i$ and $\eta_t$ are the refractive indices of the incident and transmitted media. The law dictates how the ray bends:

* If light enters a denser medium ($\eta_t > \eta_i$, e.g., air to glass), it **slows down** and bends **toward** the normal.
* If light enters a less dense medium ($\eta_t < \eta_i$, e.g., glass to air), it **speeds up** and bends **away** from the normal.


#### **Deriving the Refraction Vector**
To implement refraction in a ray tracer, it's necessary to derive the direction vector of the transmitted ray, $\vec{T}$, from the incident vector, $\vec{I}$, and the surface normal, $\vec{N}$. This is done by decomposing the vectors into components parallel and perpendicular to the normal.

The resulting vector form of Snell's Law is:

$$\vec{T} = \left(\frac{\eta_i}{\eta_t}\right) \left( \vec{I} + (\cos\theta_i)\vec{N} \right) - \left(\sqrt{1 - \left(\frac{\eta_i}{\eta_t}\right)^2 (1 - \cos^2\theta_i)}\right)\vec{N}$$

where $\cos\theta_i = -\vec{I} \cdot \vec{N}$.

#### **Total Internal Reflection (TIR)**

A critical phenomenon occurs when light travels from a denser medium to a less dense one (e.g., from inside glass back to air). If the angle of incidence $\theta_i$ is sufficiently large, the term inside the square root of the vector formula becomes negative. This is a physical impossibility, signifying that no refraction can occur. In this case, all light is perfectly reflected back into the denser medium. This effect is known as **Total Internal Reflection** and must be handled by the material's logic; if TIR occurs, only a reflection ray is generated.

---

### **Energy Distribution: The Fresnel Effect**

While Snell's Law determines the *direction* of the two rays, the **Fresnel equations** determine their *intensity*. They describe the amount of light that is reflected versus the amount that is refracted, which varies with the viewing angle. For dielectrics, reflections are faint when viewed head-on but become almost perfectly mirror-like at grazing angles (e.g., looking at a lake from a low angle).

This **reflectance** value depends on the refractive indices of the two media and the angle of incidence. The refractive index, $n$, is a physical property of a material defined by the ratio of the speed of light in a vacuum ($c$) to its speed within the material ($v$): $n = c/v$.

#### **Schlick's Approximation**

The full Fresnel equations are computationally expensive for real-time applications. A widely used and effective alternative is **Schlick's approximation**:

$$R(\theta) = R_0 + (1 - R_0)(1 - \cos\theta)^5$$

This formula approximates the reflectance $R(\theta)$ based on two inputs:

1.  **$R_0$**: The reflectance at normal incidence (viewing angle $\theta = 0^\circ$), which is easily calculated from the refractive indices:
    $$R_0 = \left(\frac{n_1 - n_2}{n_1 + n_2}\right)^2$$
2.  **$\cos\theta$**: The cosine of the angle between the view direction and the surface normal.

This approximation elegantly captures the essence of the Fresnel effect: reflectance starts at $R_0$ and smoothly increases to 1 (100%) as the angle approaches 90 degrees.

#### **Industry Standard Practices**

In production environments like game engines, performance and artistic control are paramount. For this reason:
* Instead of calculating $R_0$ from refractive indices, materials often expose a constant reflectance value directly to artists.
* For common non-metallic dielectrics, this value is often defaulted to approximately **0.04**, which corresponds to a material with a refractive index of around 1.5 (typical for plastic or glass).
* This approach is fast, intuitive for artists, and produces visually convincing results for most common materials.

### Multiple Oil Layers on a Car

A car's paint finish, when treated with multiple layers of a transparent medium such as oil, can exhibit enhanced light reflection. This effect, often termed thin-film interference, occurs as light waves reflect from the different interfaces of these layers. The resulting superposition of these reflected waves creates a unique visual effect, which depends on the thickness of the layers and the wavelength of the light.

***

### Surface Normals

In ray tracing, the accurate calculation of reflection and refraction using formulas such as Snell's Law and the reflection vector formula relies on a fundamental geometric principle: the **normal vector** and the **incident ray vector** must point in opposite directions relative to the surface. This is a crucial assumption for these equations to function correctly.

#### Typical Case

For a ray originating outside a geometric volume (e.g., a sphere), the normal vector is typically calculated by constructing a vector from the object's center of mass to the point of intersection and then normalizing it. This method provides the correct outward-pointing normal. The validity of this setup is confirmed when the dot product of the incident ray vector and the normal vector is negative, indicating that the two vectors are on opposite sides of the surface.

#### Notable Case

A different scenario arises when a ray is refracted and continues its path *inside* the volume. In this case, the new incident ray is now traveling from within the object, and its direction is generally aligned with the original normal vector. This results in a positive dot product between the new incident ray and the outward-pointing normal, violating the core assumption of the reflection and refraction formulas.

To correct this, the normal vector must be flipped to point inward. Since the direction of the incident ray cannot be altered, the normal vector is adjusted to conform to the required geometric relationship. This is commonly implemented in code by checking the sign of the dot product: if the dot product is positive, the ray is inside the volume, and the normal vector is inverted before proceeding with further calculations.

***



[Top](#){: .btn .btn--primary }{: .align-right}
