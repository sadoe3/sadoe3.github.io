---
title: "Qt6 : Event Handling"

categories:
    - qt6

tags:
    - [Qt6, GUI, Event Handling, Event, C++]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2024-11-16
---

# Event Handling
This post covers things related to **event handling** of `Qt Wdiget` Applications


## Core Architecture
There 3 **classes** you can choose to develop a certain type of Qt Widget applications

### QCoreApplication
`QCoreApplication` is the base class for **non-GUI** applications
- it handles the **basic functionality** needed for `any Qt application` that does **not involve** a graphical user interface (**GUI**)
    * this class manages the event loop and application settings, but it does not provide any GUI functionality
- Use Case
    * if you’re writing a **command-line** application or a non-GUI-based application
        + e.g., a server, a daemon, or a background process
    * you would use `QCoreApplication`

### QGuiApplication
`QGuiApplication` is a **subclass** of `QCoreApplication`
- it adds **GUI-specific functionality** for applications
    * that do **not** use the **full Qt Widgets** system but still require some basic GUI features, such as handling windowing systems, events, and interactions
- Use Case
    * if you are building an application that involves **low-level GUI elements**
        + such as handling `OpenGL` windows, QML-based UIs, or custom widgets without relying on the full Qt Widgets system
    * `QGuiApplication` is appropriate

### QApplication
`QApplication` is the **most commonly used class** in Qt applications when you need both event handling and GUI elements from the Qt Widgets module
- it provides all the necessary event handling and GUI features for creating and managing widgets
- Use Case
    * if you're building a traditional desktop application with a standard set of **Qt Widgets**
        + like buttons, text fields, labels
    * you should use `QApplication` 


## QObject
`QObject` is the **base class** for `most Qt object types`
- it provides **core functionality** for all Qt objects
    + such as object memory management
    + properties
    + event handling
    + signal-slot connections
- it's **not directly** related to **GUI components**, but rather to object model and event management in Qt
- `QObject` is based on **parent-child** relationship
    ```c++
    // constructor of QObject
    QObject(QObject *parent = nullptr);
    // Parent adds the object to its list of children
    ```
    * the **parent-child** relationship in Qt is a memory management model for automatic deletion of objects
        + it's worth noting that it is **not related to inheritance**
        + which means that if class `B` is a child of class `A`, this doesn't mean that `B` is the derived class of class `A`
    * if object has children and is being destroyed, **its children** would be **deleted first**
- `QObject` can be constructed on `heap` area with `new` expression, or on `stack` area as a local object
    * **Most** of `QObject`s need to be **dynamcially allocated** with `new`
    * but some may not
        + `QApplication`
            * local to `main()`
        + top level `QWidget`
            * like `QMainWindow`
        + `QFile`
            * usually local to a certain function
        + value types
            * such as `QString`, `QColor` because it's cheap to copy

### QWidget
`QWidget` is a **subclass** of `QObject` and is the **base class** for **all** user interface **objects** in Qt that appear on the **screen** (such as windows, buttons, labels, etc.)
- it adds **graphical** and **interactive** features to `QObject`
    * it's worth noting that `QObject` **doesn't provide** any **visual representation** functionality
        + which means that if you want to **paint** (drawing widgets on the screen) a certain object, you need to make that object **inherit** from `QWidget`
    * the additional features that `QWidget` provides are **mouse** and **keyboard** events, **focus** management, and widget **positioning**
- if a certain `QWidget` object **doesn't have** a **parent**, then a **new window** is created
    * if you want that widget to be used for **user interaction**
        + such as input collection or displaying messages
    * it may be called a `dialog` 
        + but only if it's **inherited** from a `QDialog`, `QMessageBox`, or similar
- the widget position of a **child** uses its **parent's** coordinate system
    * if the child widget **crossed the boundary** of its parent, it would be **clipped** on the screen
- **children** follow the `state` or `enable-ness` of their **parent**
- you should **never include** `<QWidget>`
    * you need to include **specific widget** like `<QPushButton>`
    * class hierarchy of `QPushButton`
        + `QObject` -> `QWidget` -> `QPushButton`

### Multiple File Handling for a Custom Widget
When you create a **custom widget**, try to follow this convention
- **Header File**
    ```c++
    // MyQtWidget.h
    #ifndef MYQTWIDGETS_H
    #define MYQTWIDGETS_H

    #include <QWidget>

    class SimpleWindow : public QWidget {
        Q_OBJECT
    public:
        SimpleWindow(QWidget* parent = nullptr);
    };

    #endif
    ```
    * it's worth noting that you always need to put `Q_OBJECT` **macro** when you want to **inherit** from the `QObject` class
- **Source Files**
    ```c++
    // MyQtWidget.cpp
    #include "MyQtWidgets.h"

    SimpleWindow::SimpleWindow(QWidget* parent) : QWidget(parent) {
        // some codes
    }
    ```
    ```c++
    // Main.cpp
    #include "MyQtWidgets.h"
    #include <QtWidgets/QApplication>

    int main(int argc, char *argv[])
    {
        QApplication a(argc, argv);

        SimpleWindow* window = new SimpleWindow();
        window->show();
        delete window;

        return a.exec();		    // this code is needed to enter the main event loop
    }
    ```
    * note that this convention follows the way how the standard widgets are utilized
        + include the header file -> use it
    * if you want to learn more regarding specific standard widgets, check the documentation


## Basic Event Handling

### Events
`QWidget` has various types of widget events
- events can be **accepted** or **ignored** 
    * default is **accepted**
- event can be **propagated** to `parent` widget if the event is **ignored**
- events on **non-QWidgets** are **never automatically propagated**
- `QEvent` is the **base class** for all event classes

### How to Handle the Event
When an **event** occurs to a `QWidget` object, the event trigger calls the **event handler**, then **event handler** decides whether to `accept` or `ignore` the event
- if it calls `accept()`, then that handler should handle the event because `accept()` **stops further propagation**
- otherwise
    + calling `ignore()`
    + no call to `accept()` or `ignore()`
- the event will **propagate** up to **parent** widget until it reaches
    + the widget which calls `accept()`
    + or **top-level** widget which may perform **default** action for the event type


Basic concept -> event -> 
1.	include the event -> ex: include <QCloseEvent>
2.	Decide inside the handling method -> event->accept();

Also it’s possible to cast the event to virtual event such as QMouseEvent -> QEvent::MouseMove

### How to Create a Custom Event Handler
You can implement the **custom event handler** so that the widget will perform what you want when a certain event occurs
```c++
// basic syntax
void eventName(EventType *event) override {
    // do something
}
```
```c++
// actual example
#include <QWidget> 
#include <QKeyEvent>        // need to be included

class MyWidget : public QWidget
{
    Q_OBJECT

public:
    MyWidget(QWidget *parent = nullptr) : QWidget(parent) {}

protected:
    // Key event handler
    void keyPressEvent(QKeyEvent *event) override {
        if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
            // some code
            event->accept();
        }
    }
};
```
- it's worth noting that you need to **include** the `header file` for the specific event that you want to handle
    * then specify the type as the `type` of the **parameter** of the handler
- also note the event handlers reside in `protected` section

### Event Filtering
You can also install an **event filter** on a widget to intercept events before they reach the widget:
```c++
QWidget *widget = new QWidget;
widget->installEventFilter(this);
```
- in this case, you would implement the `eventFilter()` method in the object that installed the filter, which allows you to process or **modify** events before they are delivered to the widget
- also it’s possible to **cast** the `event` to `virtual event`
    * such as `QMouseEvent` -> `QEvent::MouseMove`

### Signals and Slots



### How to Setup Event Handling through Qt Designer

### How to setup the custom slot through Qt designer


## Extra Details

### How to Pass the Text to the Console

### 



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}