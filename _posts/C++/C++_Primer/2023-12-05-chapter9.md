---
title: "Chapter 9"

categories:
    - cpp

tags:
    - [C++, Programming Language, Sequential Container, string, vector]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-5
---

# Sequential Containers

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Overview of the Sequential Containers
A Container holds a **collection** of objects of a specified type

### Sequential Container Types
The **Sequential Containers** are the containers which support the **sequential access**
||Sequential Container Types|
|:---:|:---|
|`vector`|flexible-size arrary. supports fast random access. inserting or deleting elements other than at the back may be slow|
|`string`||
|`forward_list`||
|`list`||
|`deque`|double-ended queue. supports |
|`array`||
- in order to use the container, you need to **include** the header of which name is the name of the type itself
    * for `std::array`, include `<array>`
- With the exception of `array`, which is a fixed-size container, the containers provide efficient, flexible memory management
- `std::string` and `std::vector` hold their elements in **contiguous** memory
    * therefore, it's fast to comptue the adress of an element from its **index**
    * however, adding or removing elemetns in the middle of one of these containers takes time
        + all the element after the one inserted or removed have to be moved to maintain **contiguity**
        + moreover, adding an element can sometimes require that additional storage be **allocated**, then, every element must be moved into the new storage
- `std::list` and `std::forward_list` containers are designed to make it fast to add or remove an element **anywhere** in the container
    * in exchange, these types do **not** support **random access**
        + we can access the element only through **sequential access**
    * moreover, the memory overhead for these containers is often **substantial**, when compared to `std:::vector`, `std::deque`, and `std::array`
- `std::deque` is similar to `std::string` and `std::vector` with one exception
    * adding or removing elements at either **end** of the `std::deque` is a **fast** operation, comparable to adding an element to a `std::list` or `std::forward_list`
    * other features are simliar to `std::vector`
        * support fast random access
        * adding or removing elements in the middle of a `std::deque` is a (potentially) **expensive** operation
- `std::array` is a safer, easier-to-use, and faster alternative to built-in arrays
    * because it's just C++ sytle array, it doesn't suuport operations to add and remove elements or to resize the container
- it's usually better to use the library containers rather than primitive structures like arrays
 
### Deciding which container to use
There are a few rules of thumb that apply to selecting which container to use
- Unless you have a good reason to use another container, use a `std::vector`
- If your program has lots of small elements and space overhead matters, **don't use** `std::list` and `std::forward_list`
- If the program 
- If the program
- If the program
- If the program must support to insert into the middle and the ramdom access
    * choose one of the following solutions by performing the performance test
        + use `std::list` for inserting phase, then copy the `std::list` into a `std::vector` to support the random access
        * just use `std::vector`

## Container Library Overview

### Operation Hierarchy
- some operations are provided by all containers
- some operations are specific to the **sequential**, the **associative**, or the **unordered** containers
- others are specific to only a smaller subset of the containers

### Container Operations
The Following table shows the common type aliases and operations defined in all containers
||Container Operations|
|:---:|:---|
|**Type Aliases**||
|`iterator`|type of the iterator for this container type|
|``||
|``||
|**Construction**||
|`C c;`|default constructor, empty container|
|``||
- the relational operators uses their element's relational operator
    * which means, it's valid to compare different types only if there's an appropriate conversion operator defined

### Iterators
Basically, iterator is like a pointer which points to the element of the container.
- hence, you can perform pointer operations on the iterators as well
    * however, some containers don't support them
        + `std::forward_list` iterators do not support the `--(decrement operator)`
        + the iterator arithmetic operations apply only to iterators for `std::string`, `std::vector`, `std::deque`, and `std::array`
- an **iterator range** is denoted by a pair of iterators each of which refers to an element, or to **one past the last element** in the same container
    * these two iterators often referred to as `begin` and `end`
    * this range is called a left-inclusive interval
        + \[ begin, end )
    * `end` may be equal to `begin` but must not precede it
        + if they are equal, the range it empty
        + otherwise, there is at least one element in the range, and `begin` refers to the **first** element 
        + we can increment `begin` untile `begin == end`
    * you can get the iterators by calling `.begin()` and `.end()` methods
- the **reverse** iterator is an iterator that goes **backward** through a container
    * for instance, `++` on a reverse iterator yields the previous element
- if write access it not needed, use `const` version of iterators

### Initialization of Containers
||Defining and Initializing Containers|
|:---:|:---|
|`C c`|default constructor. if `C` is `std::array`, then the elements in c are default-initialized, otherwise `c` is empty|
|`C c1(c2)`|`c1` is a copy of `c2`. `c1`and `c2` must have the same or convertible type to each other. for `std::array`, must have the same size as well|
|`C c1 = c2`|same as `C c1(c2)`|
|`C c{a, b, c, ...}`|`c` is a copy of the elements in the initializer list. type of elements in the list must be compatible with the element type of `C`. for `std::array`, any missing element are value-initialized|
|`C c = {a, b, c, ...}`|same as `C c{a, b, c, ...}`|
|`C c(b,e)`|c is a copy of the elements in the range denoted by iterators `b` and `e`(left-inclusive). type of the elements must be compatible with the element type of C. **Not valid for `std::array`**|
||**Constructors that take a size are valid for `sequential container` (not including `std::array`) only**|
|`C seq(n)`|`seq` has `n` value-initialized elements; this constructor is `explicit`. **Not valid for `std::string`**|
|`C seq(n, t)`|`seq` has `n` elements with value `t`|

### Assignment and swap
||Container Assignment Operations|
|:---:|:---|
|`c1 = c2`|replace the elements in `c1` with **copies** of the elements in `c2`. `c1` and `c2` must be the same or compatible type to each other|
|``||
|``||
|``||
- the `=(assignment operator)` replaces the entire range of elements in the left-hand containers with **copies** of the elements from the right-hand operand
    * after the assignment, the left- and right-hand containers are **equal**
        + if the containers had been of **unequal size**
        + after the assignment, left-hand container would have the **size of the right-hand** container 
    * assignment operation can happen with a braced list
        + in the textbook, it said it's not possible to use a braced list with `std::array` for assignment operation
        + however, thanks to the update of the new standard, now it's possible to do it
        ```c++
        std::array<int, 3> arr = {0};
        arr = {1, 2};       // ok
        ```
- the `.assign()` methods are available from only the **sequential** containers except `std::array`
    * it does the assignment operation with the object created by the given parameters
- the `swap()` opeartion **doesn't copy, delete, or insert** any elements and is guaranteed to be executed at constant time
    * the elements themselves are not swapped; internal data strucrues are swapped
            + however, `std::array` does exchange the elements, hence, swapping two `std::array`s requires time proportinal to the number of elements in the `std::array`
    * which means, it's usually **much faster** than copying(assigning) elements from `c2` to `c1` 
- as a matter of habit, it's best to use the **nonmember** version of `std::swap()`


## Sequential Container Operations
There are operations specific to the **sequential** containers

### Adding Elements
||Operations that add elements to a sequential container|
|:---:|:---|
|`c.push_back(t)`|creates an element with value `t` at the **end** of `c`. returns `void`. **Not valid for `std::forward_list`**|
|`c.emplace_back(args)`|creates an element constructed from `args` at the **end** of `c`. returns `void`. **Not valid for `std::forward_list`**|
|`c.push_front(t)`|creates an element with value `t` on the **front** of `c`. returns `void`. **Not valid for `std::vector` or `std::string`**|
|`c.emplace_front(args)`|creates an element constructed from `args` on the **front** of `c`. returns `void`. **Not valid for `std::vector` or `std::string`**|
|`c.`||
|`c.`||
|`c.`||
|`c.`||
- these operations change the size of the container; they are not supported by `std::array`
- `std::forward_list` has special versions of `.insert()` and `.emplace()`
- the difference between `.push` and `.emplace` is that
    * `.push` methods add the element with the **copied** object
    * `.emplace` methods add the element with the **constructed** object

### Accessing Elements
||Operations that access elements in a sequential container|
|:---:|:---|
|`c.back()`|returns a **reference** to the **last** element in `c`. **undefined** if `c` is empty. **Not valid for `std::forward_list`**|
|`c.front()`|returns a **reference** to the **first** element in `c`. **undefined** if `c` is empty.|
|`c[n]`|returns a **reference** to the element indexed by the unsigned integral value `n`. **undefined** if `n >= c.size()`. **Not valid for `std::forward_list` and `std::list`**|
|`c.at(n)`|returns a **reference** to the element indexed by the unsigned integral value `n`. if the index is out of range, **throws** an `out_of_range` exception. **Not valid for `std::forward_list` and `std::list`**|
- if you want to ensure that the index is valid, try to use `.at()` method instead

### Erasing Elements
||Operations that remove elements from a sequential container|
|:---:|:---|
|`c.pop_back()`|removes **last** element in `c`. **undefined** if `c` is empty. returns `void`. **Not valid for `std::forward_list`**|
|`c.pop_front()`|removes **first** element in `c`. **undefined** if `c` is empty. returns `void`.**Not valid for `std::vector` or `std::string`**|
|`c.`||
|`c.`||
|`c.`||
- these operations change the size of the container; they are not supported by `std::array`
- `std::forward_list` has special versions of `.erase()`
- removing elements which are not the beginning or end of a `std::deque` **invalidates** all iterators, references, and pointers
- iterators, references, and pointers to elements after the erasure point in a `std::vector` or `std::string` are **invalidated**
- the methods that erase elements do not check their arguements; you must ensure that element(s) exist before removing them

### Specialized forward_list Operations
The operations to add or remove elements in a `std::forward_list` operate by chaning the element **after** the given element because there's no easy way to get to an element's predecessor in a singly linked list
||Operations to insert or remove elements in a `std::forward_list`|
|:---:|:---|
|`flst.before_begin()`|returns a iterator denotes the nonexistent element **just before** the beginning of `flst`. this iterator may not be dereferenced|
|`flst.cbefore_begin()`|returns the `constant_iterator` version of `.before_begin()`|
|`flst.`||
|`flst.`||
|`flst.`||
|`flst.`||
|`flst.`||
|`flst.`||
|`flst.`||

### Resizing a sequential container
||Sequential Container Size Operations|
|:---:|:---|
|`seq.resize(n)`|resize `seq` so that it has `n` elements. if `n < seq()`, the excess elements are **discarded**. if new elements must be added, they are value-initialized|
|`seq.resize(n, t)`|same as `seq.resize(n)`, but new elements have value `t`|
- `.resize()` is not valid for `std::array`
- note that resizing the sequential container **invalidates** the iterators, references, and pointers to the deleted elements and possibly all of them would be **invalidated**
    * if `std::vector` or `std::string` was **reallocated**, all iterators, references, and pointers are invalid
- therefore, you need to ensure that the iterator is **repositioned**, as appropriate, **after each operation** that changes the container
- the iterator returned from `.end()` is highly likely to be invalid
    * hence, it's usually a bad idea to store it as an object
    * partly for this reason, C++ standard libraries defines `.end()` method as a very fast operation

### How a vector Grows
`std::vector` and `std::string` sometimes **reallocate** capacity **more** than what is immediately needed if there's no room for new element in current capacity while maintaining the contiguity
```c++
    std::vector<int> a;
    while (a.size() == a.capacity())
        a.push_back(1);
    a.reserve(1);                   // this call is ignored because 1 must be less than a.capacity() at this point
    a.reserve(a.capacity() + 2);    // reallocate to add two extra rooms   
    a.shrink_to_fit();              // this may be ignored
```
- `a.capcity()` returns the **maximum** number of elements `a` can have before **reallocation** is necessary
    * note that `.capacity()` is different from `.size()`
    * `.size()` and `.resize()` are related to the number of the **actual** elements of the container
- `a.reserve()` reallocates space for **at least** `n` elements 
    * when you pass the number which is less than `.capacity()` to `.reserve()`, the call is **ignored**
- if you think the extra space is not necessary, you can **request** to return the unneeded memory by calling `.shrink_to_fit()` method
    * note that this call is to **request**, which means it can be **ignored**
    * if the request is accepted, `.capacity()` is equal to `.size()`
- `.capacity()` and `.reserve()` is valid only for `std::vector` and `std::string`
- `.shrink_to_fit()` is valid only for `std::vector`, `std::string`, and `std::deque`

## Additional string Operations

### Additional Ways to Construct strings
||`n`, `len2` and `pos2` are all `unsigned` values|
|:---:|:---|
|`string s()`||
|`string s()`||
|`string s()`||

### subtr Operation
||`substr` Operation|
|:---:|:---|
|`s.substr(pos, n)`|return a `std::string` containing `n` characters from `s` starting at `pos`. `pos` defaults to 0. `n` defaults to a value that causes the library to copy all the characters in `s` starting from `pos`|

### Other Ways to Change a string
||Operations to Modify `std::string`s|
|:---:|:---|
|`s.`||
|`s.`||
|`s.`||
|`s.`||
|`s.`||

### string Search Opeartions
||Operations to Modify `std::string`s|
|:---:|:---|
|`s.`||
|`s.`||
|`s.`||
|`s.`||
- the search methods returns an `unsigned` type, hence, it's a bad idea to use an `int` or other `signed` types to hold it

### string comparison
||Possible Argument to `s.compare()`|
|:---:|:---|
|`s2`||
|``||
|``||
|``||
|``||

### Numeric Conversion
||Conversions between `std::string`s and Numbers|
|:---:|:---|
|`to_string(val);`||
|``||
|``||
- if the `std::string` can't be converted to a number, these functions throw an `invalid_argument` **exception**
- if the conversion generates a value that can't be represented, they throw `out_of range`

## Adaptors
There are 3 types of adaptors in C++
- Container Adaptor
- Iterator Adaptor
- Function Adaptor
- Essentially, an adaptor is a mechanism for making one thing act like another

### Container Adaptors
A container adaptor takes an existing container type and makes it act like a different type
- the following table shows the common operations and types of container adaptor

||Operations and Types Common to the Container Adaptor|
|:---:|:---|
|``||
|``||

### Sequential Container Adaptors
The library defines 3 **sequential container adaptors**
- the following are the ones
    * `std::stack`
        + defined in the `<stack>` header
        + implemented in terms of `std::deque` by default
        + can be implemented on a `std::list` or `std::vector` as well
    * `std::queue`
        + defined in the `<queue>` header
        + implemented in terms of `std::deque` by default
        + can be implemented on a `std::list` or `std::vector` as well
    * `std::priority_queue`
        + defined in the `<queue>` header
        + implemented in terms of `std::vector` by default
        + can be implemented on a `std::deque` as well
- we can override the default container type by naming a seqeuntial container as a **second type arguement** when we create the adaptor
```c++
std::stack<std::string, std::vector<std::string>> str_stk;
```

### Stack Adaptor
The following table shows how `std::stack` works
||Stack Operations|
|:---:|:---|
|``||
|``||
- although it's implemented based on the `std::deque`, there's no direct access to the `std::deque` operations

### The Queue Adaptors
The following table shows how `std::queue` and `std::priority_queue` work
||`std::queue` and `std::priority_queue` Operations|
|:---:|:---|
|`q.push(item)`|create an element with value `item` at the end|
|`q.emplace(args)`|create an element with value constructed from `args` at the end|
|`q.pop()`|removes, but does not return, the **front** element or **highest-priority** element from the `std::queue` or `std::priority_queue`, respectively|
|`q.front()`|returns, but does not remove, the front element of `q`. **Valid only for std:queue`**|
|`q.back()`|returns, but does not remove, the back element of `q`. **Valid only for std:queue`**|
|`pq.top()`|returns, but does not remove, the highest-priority element of `pq`. **Valid only for std:priority_queue`**|


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}