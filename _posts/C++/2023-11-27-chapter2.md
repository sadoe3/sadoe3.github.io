---
title: "Chapter 2"

categories:
    - cpp

tags:
    - [C++, Programming Language, Type]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-11-27
---

# Variables and Basic Types

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Primitive Built-in Types

### Arithmetic Types
C++의 built-in type은 크게 2가지 종류로 구성이 된다.
- Arithmetic Types
<br>
Arithmetic Types은 또한 2가지로 구성이 되는데, 다음과 같다
    * Integral types
    <br>
    bool, char, wchar_t, char16_t, char32_t, short, int, long, long long
    <br>
    int의 크기는 system 마다 다르기 때문에, fixed size라고 생각하고 coding하면 안된다.
    * Floating-point types
    <br>
    float, double, long double
- void type
<br>
다양한 상황에서 void type을 사용하게 되는데, 예를 들면 void pointer를 생각해 볼 수 있다.

### Signed and Unsigned Types
bool, extended character types을 제외한 integral type은 signed인지 unsigned인지를 설정할 수 있다.
- 굳이 signed를 붙이지 않아도 기본적으로 signed이다.
- 그냥 unsigned 라고 쓰면, unsigned int를 의미한다.
- unsigned는 negative part가 postive part에 추가적으로 붙어서, 동일한 크기이지만 postivie part를 좀더 많이 사용할 수 있게 해준다.
- 다만 char는 예외적으로 compiler에 따라서 char가 signed char일 수도 있고, unsigned char일 수도 있다.

### Deciding which type to use
- Negative Value를 받지 않는다는 확신이 서면 unsigned type을 사용하기<br>
- integral type에 관하여, 기본적으로는 int 사용하기. 너무 짧으면 short, 너무 길면 long long 사용하기. 일반적으로 long은 int와 같은 크기이기 때문에 사용할 일이 별로 없음.
- char는 expression에 사용할 때, unsigned인지 signed인지 명시하여 사용하기
- 일반적으로 char는 문자 하나를 저장할때 사용하긴 함
- floating-point type에 관하여, double 사용하기. float는 너무 부정확하고, long double은 너무 정확하기 때문(run-time cost).

### Type Conversions
A type이 예상되는 상황에서 B type이 주어졌으면, B type에서 A type으로 automaic(implicit) type conversion이 이루어진다. (물론 B type에서 type conversion operator가 구현이 되어 있어야 함. 기본적으로 built-in type들은 서로 간의 type conversion이 구현이 되어있음)
- bool type은 0만을 false로 받고, 나머지 값들은 true로 받는다.
- integral type에 floating-point value를 넣어주면, integral part만 받고, 나머지는 truncated 된다. (반올림이 안됨)
- floating-point type에 integral value를 넣어주면, fractional part는 0으로 입력이 된다.
- out-of-range value를 집어넣었을 때, unsigned type 같은 경우에는 넘친 만큼 반대쪽에서 그 만큼 추가된 값이 된다. (ex: unsigned char -> 300 -> 44)
- signed type 같은 경우, 결과는 undefined 이다. (unsigned와 같을 수도 있음)
- signed와 unsigned가 동일한 expression에 있는 경우, signed가 unsigned로 casting 되어 expression이 진행된다. (그 값은 위에서 설명한 방식대로 변경됨)
- 그래서 일반적으로 signed와 unsigned는 동일한 expression에 사용하지 않는것이 좋다.

### Literals
value with name = object <br>
value without name = literal <br>
object which are able to change its value = variable <br>
object which are not able to change its value = constant <br>
일단 이런식으로 정의를 내렸지만, 사실 object의 정의는 사람마다 다르기 때문에, 그냥 data를 저장할수있는 type으로 정의된 공간 정도로 생각하면 된다.
- integral literal
    * decimal = 20
    * octal = 024
    * hexadecimal = 0x14
    * minmum size = int
- floating-point literal
    * decimal point = 3.14159
    * scientific notation = 3.14159E0
    * default type = double -> can be overriden
- string literal
    * character = 'a' <br>
    type = char
    * c-sytle string = "a"
    * c-sytle string literal은 char들로 이루어진 array이고, 맨 마지막에 null character(\0)가 추가되어, "a"는 2의 크기를 갖는다.
    * 또한 string literal 2개가 인접하여 있으면 1개의 string literal로 생각하면 된다. <br>
    "aaa" "bbb" = "aaabbb"
- escape sequence
    * nonprintable characters를 출력할때 사용한다.
    * \\n, \\t, \\a, \\v, \\b, \\", \\\\, \\?, \\', \\r, \\f
- boolean literal
    * true, false가 boolean literals이다.
- pointer literal
    * nullptr는 null pointer를 사용할때 쓰는 pointer literal이다.
- specifying the type of a Literal
    * default한 literal의 type 대신에 내가 원하는 type을 설정하여 literal를 사용할수있다.
    * suffix나 prefix를 추가하면 되는데, 예를 들면 L'a'는 wchar_t를 사용하고, 3.14L은 long double을 사용한다. (long double을 사용할때에는 대문자를 사용하여 1과 혼동되지 않게 하자)

## Variables

### Two types
기본적으로 c++는 2가지의 type을 갖는다.
- built-in type
- class type

### Variables Definitions
아직 class type에 관해서는 다루지 않았기 때문에, built-in type으로 object를 define 하는 방법에 대해 다루어 보겠다.
- 기본적인 Syntax는 다음과 같다
    * (type specifier) (list of one or more variables, comma separated, may have initial value) ;
    * ex: int width, height = 3;

### Initialization
Object가 만들어 질때, initial value를 설정하면 이를 **Initialization**이라고 한다.
- 다만 만들어진 이후에 =(assignment operator)을 사용하면 이는 assignment operation이 된다.
- 4가지 방법으로 초기화(initialize)를 진행할 수 있다.
    * int age = 3;
    * int age = {3};
    * int age{3};
    * int age(3);
- 여기서 { } (curly braces)를 사용한 초기화 방법을 list initialization이라고 하는데, 이때 만약에 초기화 중 data loss가 발생되는 상황에서는 compiler가 초기화를 멈춘다(error를 발생시킴)
    * ex: int age{3.14}; // error

### Default Initialization
만약 Object를 만들때, initial value를 설정하지 않으면, 해당 object는 **default initialized** 되어, 정해진 default value가 initial value로 설정되어 초기화된다.
- default initialization은 해당 object가 어떤 type이고, 어디에서 만들어 졌는지에 따라 default value를 다르게 설정해준다.
- built-in type의 object는 다음 2가지의 경우를 보면 된다.
    * outside function body 
    <br>
    이 경우 0으로 초기화 된다
    * inside function body
    <br>
    이 경우 uninitialized 된다 (즉 어떤 값으로 초기화 되는지는 undefined 이다.)
    <br>
    기본적으로 uninitialized object는 error-prone이기 때문에, 왠만하면 모든 object들은 초기화를 해주는것이 좋다.

### Variable Declaration
multiple files handling하는 경우, 다른 source code에 defined된 object를 사용해야 할때는 extern keyword를 이용해서 해당 object를 사용할 수 있다.
```c++
extern int i; // declares but does not define i
int j;        // declares and defines j

extern double pi = 3.1416 // defintion
```
다만 extern keyword를 사용해도 explicit initializer(=)를 이용하면 이는 곧 defintion이 된다. <br> 
주의할 점은 defintion은 딱 1개의 파일에서만 존재해야하고, declaration은 여러 파일에서 존재해도 상관없다.<br>마지막으로 function body 안에서는 extern keyword를 사용할 수 없다.

### Identifier
Identifier is a name of an object, a function, or a class.
- 기본적으로 C++에서 사용하는 특정 단어들(ex: keywords)을 제외한 단어는 identifier로 사용될 수 있다.
- 다만 보통 naming convention을 따라서 작성하는 것이 좋다.
    * variable = camelCase
    * class = PascalCase
    * function = PascalCase
    * constant = SCREAMING_SNAKE_CASE
- 어떤 naming convention을 사용하든, point는 consistency를 지켜줘야 의미가 있다.

### Scope of a Name
most scopes in C++ are delimited by curly braces
- 특정 code block 안에서 만들어진 object는 해당 code block (scope)을 벗어나면 사라지게 된다.
- 모든 program내에서 accessible 한 object를 만드려면 outside function body에다가 object를 define하면 된다. (global scope를 갖게 됨)  


## Compound Types
Compound types are built from the base type<br>
There are 2 sorts of compound types
- reference
- pointer

### Reference
A reference is not an object, but an alternative name for an existing object<br>
```c++
int i = 3;
int &r = i;
```
- place & before the identifier to define reference
- There's no memory allocated for the reference
- A reference must be intialized when it's created
- reference를 초기화할 때 사용되는 initializer는 일반적으로 literal이나 expression이 아닌 object를 사용한다.
- object가 initalizer로 사용되면, 해당 값이 copy되는게 아니라 해당 object에 reference가 bound 되는 개념이다.
- referece가 특정 object에 bound 되면, 이후에 다른 object로는 rebound 시킬수 없다.
- 2가지 예외를 제외하면, reference의 type은 bound되는 object의 type과 같아야 한다.
    * const (type) & can refer to (type)
    * dynamic binding which will be convered in later chapter
- lvalue, rvalue에 관하여, 기본적으로 default reference는 lvalue라고 생각하고 추가적인 내용은 뒤에 나오는 chapter에서 다루겠다.

### Pointer
A pointer is an object which contains an address of another object as its value<br>
```c++
int i = 3;
int *p = &i;
*p = 2;
```
- place * before identifier to define pointer
- C에서 사용하는 pointer의 사용법은 C++에서도 거의 동일하게 사용된다.
    * & (address-of operator)
    * \* (dereferencing)
    * double pointer
    * void pointer
- pointer는 object이기 때문에, invalid value를 갖고 있을 수 있고, 이때 dereferecing을 하면 error가 발생할 수 있다.
- 그렇기 때문에, pointer를 define할 때에는 최소한 null pointer로 초기화를 시켜줘야한다.
- C++에서는 3가지 방법으로 null pointer를 만들 수 있다.
    * int * p = nullptr;
    * int * p = 0;
    * int * p = NULL;
- 3가지 모두 같은 의미이지만, nullptr를 사용하는 것이 가장 추천되는 방법이다.
- pointer를 refer하는 reference를 만들 수도 있다.
    * int* &r = p;

### Type Modifier
pointer와 reference를 만들때 사용되는 *, & 기호를 type modifier라고 부른다. <br>
- object의 definition은 다음과 같이 정의할 수 있다.
    * `(base type) (list of declarators);`
    * 여기서 declarator는 (type modifier) + (identifier)로 구성되어 있다고 생각하면 된다.
- type modifier를 사용하는 style은 크게 2가지가 있다.
    * int* p = nullptr;
    * int *p1, *p2;
- 어떤 style을 사용하던 consistent하게 사용하자.

### const Qualifier
```c++
const int SIZE = 512;
```
- place const before base type
- constant object must be initialized
- constant object cannot be changed
- compiler는 보통 constant object를 literal value로 변환시킨다.
- 만약에 constant object를 multiple files에서 사용하고 싶다면, extern keyword를 definition과 declaration 모두에 적용시켜줘야 한다.

### reference with const
constant reference is just another name of a reference which refer to a constant object
```c++
const int VALUE = 3;
// normal(non-constant) reference
int & nRef = VALUE; // error
// constant referecne (reference to a constant object)
const int & cRef = VALUE // ok
```
- normal reference는 constant object로 bound 할수없고, 오직 non-constant한 object로만 bound가 가능하다.
- constant reference는 모든 type의 value와 bound가 가능하다.
    * `int value = 3;`
    * `double dVal = 3.14;`
    * `const int & r1 = value;` non-constant
        - 비록 bound 되는 object가 non-constant라고 할지라도, r1자체는 일단 refer하는 대상이 constant라고 생각하기 때문에, r1을 통해서는 value obect의 값을 변경할 수 없다.
    * `const int & r2 = 41;` literal
    * `const int & r3 = r1 * 2;` result of an expression
    * `const int & r4 = dVal;` different type
        - r4같은 경우, dVal로 bound되는게 아니라 다음과 같은 코드가 compiler를 통해서 실행된다.
        - `const int temp = dVal; const int & r4 = temp;`
        - 여기서 나오는 temp라는 이름의 object는 내가 임의로 temp라고 설정한 것이고, 딱히 어떤이름인지는 중요하지 않다.
        - 중요한 개념은 바로 r4같은 상황에서는 type이 다른 object가 bound 되는게 아니라, type을 동일하게 맞춘 temporary unnamed object가 bound 된다는 점을 인지해야한다.

### pointer with const
pointer를 const qualifier와 함께 사용하면, 2가지 방식으로 사용할 수 있다.
```c++
int target = 3;
// top-level const : constant pointer
int * const cPtr = &target;
// low-level const : pointer to constant
const int * pCon = &target;
```
- constant pointer (top-level const)
    * place const after *
        + `int * const ptr = nullptr;`
    * pointer = constant
        + pointer must be initialized like other constant objects
        + pointer cannot change the object which it points to
    * object which pointer points to = non-constant
        + can dereference 
- pointer to constant (low-level const)
    * place const before *
        + `const int * ptr = nullptr;` = `int const * ptr = nullptr;`
    * pointer = non-constant
        + pointer need not be initialized
        + pointer can change the object which it points to
    * object which pointer points to = constant
        + cannot dereference
    * pointer can point to constant object or non-constant object
        + normal pointer cannot point to constant object
- copy operation
    * top-level const is ignored
        + `int * const cPtr = nullptr; int * nPtr = cPtr;` OK
    * low-level const matters
        + low-level const는 copy를 할때 반드시 맞춰줘야하는데, 만약에 low-level const가 다르다면, conversion을 해서라도 맞춰줘야한다.
        + 기본적인 conversion의 원리는 다음과 같다.
            - non-const -> const : O
            - const -> non-const : X
        + `const int * pCon = nullptr; int * nPtr = pCon;` error (const -> non-const)
        + `int * nPtr = nullptr; const int * pCon = nPtr;` ok (non-const -> const)
    * there's no top-level const for references
        + reference는 그 자체가 constant의 성격(refer 하는 대상을 변경 못함)을 갖고 있기 때문에, 의미가 없다.

### constexpr
constant expression is an expression with 2 features
```c++
int num = 0;
while(num < 5)
    num++;
constexpr int cEp = num; // error: num is set at run time
constexpr int cEp = 3;   // ok
```
- it's evaluated at compile time
- the values inside expression cannot change
- examples: literals, const object which is initialized with constant expression
    + non-const object which is initialized with constant expression is not constant expression
- use **constexpr** declaration before the base type to verify whether the const object is initialized with the constant expression
    + if initializer is not constant expression, then compiler would cause an error
- literal type is the type which can be used inside constant expression
    + primitive types, compound types, enumerations, classes which are defined in a specific way (not normal classes) are the literal types
- constexpr with pointer
    + `const int * ptr = nullptr;` pointer to constant
    + `constexpr int * ptr = nullptr;` constant pointer which is constant expression
    + `constexpr const int * ptr = nullptr;` if you want to use both of constexpr and const

### Type Alias
Type Alias is another name of an existing type
```c++
// there are 2 ways to use type aliases in C++

// typedef : tradtional C style
typedef int newint;     // now newint = int
newint a = 3;           // same as int a = 3;
typedef newint A, *B;   // int = newint = A;  int* = B;
// special case for typedef
typedef char* pString;
const pString cStr;     // same as char * const cStr; not const char *;
const pString * cStr;   // same as char*const * cStr;


// using : modern C++ style
using anotherint = int; // now anotherint = int
anotherint b = 3;       // same as int b = 3;
```

### auto
we can let compiler to deduce the type of an object by using its initializer if you use auto type specifier
```c++
auto a = 3;             // same as int a = 3;
auto i = 0, *p = &i;    // ok
auto sz = 0, pi = 3.14; // error
```
- hence, an object with type of auto must be initialized
- if you define multiple objects by using auto type specifier, then those object must have the same base type
- by default, auto ignores top-level const
    + if you want to set the auto as top-level const, you need to place put const before auto
    + `const int VALUE = 3; const auto i = VALUE;`
- auto respects low-level const as usual
- also, auto ignores references
    + if you want to set auto as reference, place & after auto
    + `int a = 3; auto & b = a;`

### decltype
when you use decltype type specifier, you can set the type of an object as the return type of the given expression of decltype type specifier
```c++
decltype(f()) a;    // f() is not called, but a has whatever type f returns
decltype(1+2.3) b;  // same as double b;

const int ci = 0, &cj = ci;    // ci has top-level const, cj is reference to constant
decltype(ci) x = 0;     // same as const int x = 0;
decltype(cj) z = 3;     // same as const int & z = 3;

int i = 3, *p = &i;
decltype((i)) a = i;        // same as int & a = i;
decltype(i) b = i;          // same as int a = i;
decltype(*p) c = i          // same as int & c = i; 
```
- unlike auto, decltype handles top-level const and references
- if you use double parentheses for an object as an expression, decltype always deduce the type as the reference of the given object
- however, without double parentheses, delctype gives reference only if the given object is a reference
- decltype returns a reference type for expressions that yields objects that can stand on the left-hand side of the assignment operation


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}