---
title: "Project 3: Memory"

categories:
    - pintos

tags:
    - [Operating Systems, PintOS, Kernel Development, Linux, Virtual Memory, Demand Paging, Page Swapping, Memory Management, mmap, Clock Algorithm, Stack Growth]

toc: true
toc_label: "Table of Contents"
toc_sticky: true

date: 2025-03-30
---

# Memory
- The third project significantly improves PintOS's memory management by:
  * Implementing a supplemental page table for each process.
  * Introducing demand paging to effectively handle page faults and support dynamic stack growth.
  * Adding memory mapping features to optimize process memory access.
- Below, I outlined the objectives, challenges, solutions, and implementations for each component.

## Part 1: Supplemantal Page Table

### Objective
- The goal is to implement a **supplemental page table** to defer page allocation until needed, rather than at boot time:
  * Pages are allocated only when required.
  * This approach is known as **demand paging**.

### Current Problem
- The original `load_segment()` allocates the pages for each segment.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  static bool
  load_segment (struct file *file, off_t ofs, uint8_t *upage,
                uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
  {
    ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
    ASSERT (pg_ofs (upage) == 0);
    ASSERT (ofs % PGSIZE == 0);

    file_seek (file, ofs);
    while (read_bytes > 0 || zero_bytes > 0) 
      {
        /* Calculate how to fill this page.
          We will read PAGE_READ_BYTES bytes from FILE
          and zero the final PAGE_ZERO_BYTES bytes. */
        size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
        size_t page_zero_bytes = PGSIZE - page_read_bytes;

        /* Get a page of memory. */
        uint8_t *kpage = palloc_get_page (PAL_USER);
        if (kpage == NULL)
          return false;

        /* Load this page. */
        if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
          {
            palloc_free_page (kpage);
            return false; 
          }
        memset (kpage + page_read_bytes, 0, page_zero_bytes);

        /* Add the page to the process's address space. */
        if (!install_page (upage, kpage, writable)) 
          {
            palloc_free_page (kpage);
            return false; 
          }

        /* Advance. */
        read_bytes -= page_read_bytes;
        zero_bytes -= page_zero_bytes;
        upage += PGSIZE;
      }
    return true;
  }
  ```
  </details>

### Original Grade
<img src="data:image/png;base64,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" alt="Description of image">

### Solution
- I reimplemented `load_segment()` to:
  * Allocate entries for the supplemental page table rather than the page table itself.
  * This significantly reduces memory usage.
- To achieve this:
  * I created `struct spt_entry` to store the information required to allocate an actual page.

### Implementation Details
- **`page.h`**
  - **`struct spt_entry`**
    - Newly created.
    - Adds entries for the supplemental page table.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      enum page_type {
          SPT_BIN,     /* code segment */
          SPT_ANON,    /* stack, heap or anonymous */
          SPT_FILE     /* file-backed page */
      };

      /* spt_entry for spt_table in each thread */
      struct spt_entry {
          enum page_type type;                   // type of page
          bool is_stack;                         // flag for stack growth
          void *vaddr;                           // virtual page
          int zero_bytes;                        // padding info
          
          // these are necessary to load the actual file from disk
          struct file *file;
          int read_bytes, offset;
          bool writable;

          struct list_elem sptelem;               // List element for page table   
      };
      ```
      </details>
- **`thread.h`**
  - **`struct thread`**
    - Adds `supplemental_page_table`, `current_stack_top`, and `initial_code_segment`.
    - Note that `current_stack_top` is initialized in `setup_stack()`, and `initial_code_segment` is initialized in `start_process()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct thread
      {
        // other codes
          struct list supplemental_page_table;                     /* supplemental page table */
          void *current_stack_top;                               /* current stack top */ 
          void *initial_code_segment;                            /* address of code segment */

          /* Owned by thread.c. */
          unsigned magic;                     /* Detects stack overflow. */
      };
      ```
      </details>
 - **`process.c`**
  - **`start_process()`**
    - Initializes `supplemental_page_table`, and `initial_code_segment`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      start_process (void *file_name_)
      {
        // other codes
        /* Initialize interrupt frame and load executable. */
        struct intr_frame if_;
        bool success;

        /* Initialize the set of spt_entries */
        struct thread *current_thread = thread_current();
        list_init(&current_thread->supplemental_page_table);
        current_thread->initial_code_segment = NULL;

        // other codes
      }
      ```
      </details>
  - **`process_exit()`**
    - Deallocates `supplemental_page_table`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      process_exit (void)
      {
        file_close(cur->current_running_file);

        /* deallocate supplemental page table */
        for(struct list_elem *current_element = list_begin(&cur->supplemental_page_table), *end_element = list_end(&cur->supplemental_page_table), *next_element
                      ; current_element != end_element;) {
          struct spt_entry *target_entry = list_entry(current_element, struct spt_entry, sptelem);
          next_element = list_next(current_element);
          list_remove(current_element);
          free(target_entry);
          current_element = next_element;
        }

        // other code
      }
      ```
      </details>
  - **`load_segment()`**
    - Allocates `spt_entry` instead of the actual page.
    - Updates `initial_code_segment`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static bool
      load_segment (struct file *file, off_t ofs, uint8_t *upage,
                    uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
      {
        ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
        ASSERT (pg_ofs (upage) == 0);
        ASSERT (ofs % PGSIZE == 0);

        file_seek (file, ofs);
        struct thread *current_thread = thread_current();
        while (read_bytes > 0 || zero_bytes > 0) {
          /* Calculate how to fill this page.
              We will read PAGE_READ_BYTES bytes from FILE
              and zero the final PAGE_ZERO_BYTES bytes. */
          size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
          size_t page_zero_bytes = PGSIZE - page_read_bytes;

          struct spt_entry *new_entry = malloc(sizeof(struct spt_entry));
          if(new_entry == NULL)
            return false;

          new_entry->type = SPT_BIN;
          new_entry->is_stack = false;
          new_entry->vaddr = upage;
          if (current_thread->initial_code_segment == NULL)
            current_thread->initial_code_segment = upage;
          new_entry->zero_bytes = page_zero_bytes;
          new_entry->file = file;
          new_entry->read_bytes = page_read_bytes;
          new_entry->offset = ofs;
          new_entry->writable = writable;
          list_push_back(&current_thread->supplemental_page_table, &new_entry->sptelem);

          /* Advance. */
          read_bytes -= page_read_bytes;
          zero_bytes -= page_zero_bytes;
          upage += PGSIZE;
          ofs += PGSIZE;
        }

        return true;
      }
      ```
      </details>

### Conclusion
- These modifications significantly reduce initial memory usage by deferring page allocation through demand paging.
- However, the current PintOS implementation requires further development, as it lacks page fault handling to manage unmapped memory accesses, and the actual implementation of stack growth.
- With the supplemental page table and `spt_entry` structure in place, future enhancements can build on this foundation to enable robust virtual memory support, improving scalability of PintOS and process isolation.



## Part 2: Demand Paging

### Objective
- The goal is to handle page faults to allocate actual pages only when necessary, enabling efficient memory management.
- Once PintOS supports demand paging, it can dynamically extend the stack area:
  * **Stack expansion** relies on handling page faults, which demand paging manages effectively.

### Current Problem
- The original `page_fault()` function simply calls `kill()` to terminate the process when a page fault occurs.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  static void
  page_fault (struct intr_frame *f) 
  {
    bool not_present;  /* True: not-present page, false: writing r/o page. */
    bool write;        /* True: access was write, false: access was read. */
    bool user;         /* True: access by user, false: access by kernel. */
    void *fault_addr;  /* Fault address. */

    /* Obtain faulting address, the virtual address that was
      accessed to cause the fault.  It may point to code or to
      data.  It is not necessarily the address of the instruction
      that caused the fault (that's f->eip).
      See [IA32-v2a] "MOV--Move to/from Control Registers" and
      [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
      (#PF)". */
    asm ("movl %%cr2, %0" : "=r" (fault_addr));

    /* Turn interrupts back on (they were only off so that we could
      be assured of reading CR2 before it changed). */
    intr_enable ();

    /* Count page faults. */
    page_fault_cnt++;

    /* Determine cause. */
    not_present = (f->error_code & PF_P) == 0;
    write = (f->error_code & PF_W) != 0;
    user = (f->error_code & PF_U) != 0;

    kill (f);
  }
  ```
  </details>

### Solution
- First, I reimplemented `stack_setup()` to support stack growth.
- Then, I reimplemented `page_fault()` to:
  1. Allocate the required page using the `spt_entry`.
  2. Manage stack growth effectively.
- In order to achieve this:
  * I created the `handle_page_fault()` function as a dedicated page fault handler.
    + Then, I modified `page_fault()` to call `handle_page_fault()` for page fault resolution.

### Implementation Details
- **`process.c`**
  - **`setup_stack()`**
    - Initializes `current_stack_top`.
    - Sets the `spt_entry` for the initial stack page.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static bool
      setup_stack (void **esp) 
      {
        uint8_t *kpage;
        bool success = false;

        struct thread *current_thread = thread_current();
        current_thread->current_stack_top = ((uint8_t *) PHYS_BASE) - PGSIZE;

        kpage = palloc_get_page (PAL_USER | PAL_ZERO);
        if (kpage != NULL) {
          success = install_page (current_thread->current_stack_top, kpage, true);
          if (success)
            *esp = PHYS_BASE;
          else
            palloc_free_page (kpage);
        }

        // update supplemental page table
        struct spt_entry *new_entry = malloc(sizeof(struct spt_entry));
        if(new_entry == NULL)
          return false;

        new_entry->type = SPT_ANON;
        new_entry->is_stack = true;
        new_entry->vaddr = current_thread->current_stack_top;
        new_entry->file = NULL;
        new_entry->writable = true;
        list_push_back(&current_thread->supplemental_page_table, &new_entry->sptelem);

        return success;
      }
      ```
      </details>
  - **`install_page()`**
    - `install_page()` is called in `page.c`, which is located in a different directory.
    - Therefore, I removed the `static` modifier from the definition of `install_page()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool
      install_page (void *upage, void *kpage, bool writable)
      {
        struct thread *t = thread_current ();

        /* Verify that there's not already a page at that virtual
          address, then map our page there. */
        return (pagedir_get_page (t->pagedir, upage) == NULL
                && pagedir_set_page (t->pagedir, upage, kpage, writable));
      }
      ```
      </details>
- **`page.c`**
  - **`handle_page_fault()`**
    - Allocates the actual page based on the `spt_entry`.
    - It's worth noting that **page swapping** is required to fully implement this functionality.
      * This will be addressed in the next part.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool handle_page_fault(struct spt_entry *target_spt_entry) {   
          uint8_t *kpage = palloc_get_page (PAL_USER | PAL_ZERO);
          if (kpage == NULL) {
              // if there's no space, terminate the process for now
              // page swap is needed
              return false;
          }


          // load the data from disk
          bool is_lock_already_owned = lock_held_by_current_thread(&filesys_lock);
          if(is_lock_already_owned == false)
              lock_acquire(&filesys_lock);
          if(target_spt_entry->type != SPT_ANON) {
              // if the page is not stack nor heap, then read from the disk
              if(file_read_at(target_spt_entry->file, kpage, target_spt_entry->read_bytes, target_spt_entry->offset) != target_spt_entry->read_bytes) {
                  palloc_free_page (kpage);
                  lock_release(&filesys_lock);
                  return false;
              }
          }
          else {
              // if the page is stack or heap, then read from swap space if needed
              // but skip this for now
              ;
          }
          if(is_lock_already_owned == false)
              lock_release(&filesys_lock);


          // update page table  
          if (!install_page (target_spt_entry->vaddr, kpage, target_spt_entry->writable))  {
              palloc_free_page (kpage);
              return false;
          }

          return true;
      }
      ```
      </details>
- **`exception.c`**
  - **`page_fault()`**
    - Calls `handle_page_fault()` instead of `kill()`.
    - Handles stack growth.
      * Set `MAX_STACK_SIZE` to `8MB` as the maximum stack size.
    - Terminates the thread under the following conditions:
      * The fault address is not a valid user virtual address.
      * The fault address falls outside the allowed range.
    - Additionally, if the fault address is significantly far from the current stack pointer (`f->esp`), the thread is terminated.
      * A margin of up to `32 bytes` is allowed, as the **pusha** test pushes `32 bytes` to the stack.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #define MAX_STACK_SIZE (8 * 1024 * 1024)        // 8MB
      // other codes
      static void
      page_fault (struct intr_frame *f) 
      {
        // other codes
        user = (f->error_code & PF_U) != 0;

        struct thread *current_thread = thread_current();
        
        // Check if the page fault is due to an access violation or invalid memory reference.
        // If the address is not a valid user virtual address or falls outside the allowed range,
        // the process is terminated.
        if(not_present == false || is_user_vaddr(fault_addr) == false || fault_addr < current_thread->initial_code_segment || fault_addr >= PHYS_BASE)
            exit(-1);
              
        // handle page demanding
        struct spt_entry *target_spt_entry = NULL;
        for(struct list_elem *current_element = list_begin(&current_thread->supplemental_page_table), *end_element = list_end(&current_thread->supplemental_page_table); 
            current_element != end_element; 
            current_element = list_next(current_element)) 
        {
            target_spt_entry = list_entry(current_element, struct spt_entry, sptelem);
            if(target_spt_entry->vaddr <= fault_addr && (target_spt_entry->vaddr + PGSIZE) > fault_addr) {
              if(handle_page_fault(target_spt_entry))
                  return;
              else 
                  exit(-1);
            }
        }
        
        // handle stack growth
        // check whether the current attempt is valid for stack growth by comparing the difference between f->esp and fault_addr to 32 bytes.
            // 32 bytes are chosen due to the pusha test, which pushes 32 bytes.
            // if the distance is farther than this, terminate the process.
        // limit the maximum stack growth to MAX_STACK_SIZE (8MB).
        if(f->esp - fault_addr <= 32 && PHYS_BASE - fault_addr <= MAX_STACK_SIZE) {   
            struct spt_entry *new_entry = NULL;
            do {
              // prepare for next stack
              current_thread->current_stack_top -= PGSIZE;
              new_entry = malloc(sizeof(struct spt_entry));
              if(new_entry == NULL)
                  exit(-1);
              new_entry->type = SPT_ANON;
              new_entry->is_stack = true;
              new_entry->vaddr = current_thread->current_stack_top;
              new_entry->file = NULL;
              new_entry->writable = true;
              new_entry->slot_index = -1;
              new_entry->is_immortal = false;
              list_push_back(&current_thread->supplemental_page_table, &new_entry->sptelem);
            } while(current_thread->current_stack_top > fault_addr);
            
            if(handle_page_fault(new_entry))
              return;
        }
        
        exit(-1);
      }
      ```
      </details>
 
### Conclusion
- Now, PintOS has limited support for paging.
  * It works as long as sufficient memory is available.
- However, if memory is exhausted, the system will crash.
  * This indicates the need for page swapping.



## Part 3: Page Swap

### Objective
- The objective of this part is simple: to implement page swapping.

### Current Problem
- The current `handle_page_fault()` terminates the process if page allocation fails.

  <details markdown="1">
  <summary><b>Click</b> to see the original code</summary>

  ```c
  bool handle_page_fault(struct spt_entry *target_spt_entry) {   
    uint8_t *kpage = palloc_get_page (PAL_USER | PAL_ZERO);
    if (kpage == NULL) {
        // if there's no space, terminate the process for now
        // page swap is needed
        return false;
    }
    // other codes
  }
  ```
  </details>

### Solution
- I revised `handle_page_fault()` to call `evict_page()`, which frees the **least recently used** page.
  * The page selection is done by `pick_victim_page()`, which uses the **clock algorithm**.
- To implement page swapping, **swap space** is required:
  * This swap space is global to all threads.
  * Therefore, I had the `main` thread create a single bitmap for swap slots, which is then shared by all child processes.
- Additionally, I introduced an `is_immortal` flag for each `pte_entry` object to prevent certain pages from being swapped out.
  * This is necessary because some pages such as the initial stack page must remain in memory to ensure the correct printing of messages.

### Implementation Details
- **`thread.h`**
  - **`struct thread`**
    - Adds `swap_slots`, with a size of `SWAP_SIZE`.
    - Introduced `current_clock_index`, which is used for the **clock algorithm**.
      * it will be initialized in `init_thread()`
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      #define SWAP_SIZE 1024

      struct thread
      {
          // other code
          void *initial_code_segment;                            /* address of code segment */

          bool *swap_slots;                                      /* swap slot */
          int current_clock_index;                               /* current index of page for clock algorithm*/

          /* Owned by thread.c. */
          unsigned magic;                     /* Detects stack overflow. */
      };
      ```
      </details>
- **`thread.c`**
  - **static array**
    - Since `static` objects in `C` are shared across all child processes, I created a `static` array for global use.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Global Swap Slots */
      static bool global_swap_slots[SWAP_SIZE];
      ```
      </details>
  - **`thread_init()`**
    - Then, I initialized the `swap_slots` of the `main` thread by assigning it to `global_swap_slots`, which is defined globally in `thread_init()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      thread_init (void) 
      {
        // other codes
        initial_thread->tid = allocate_tid ();

        /* Set up swap slot */
        initial_thread->swap_slots = global_swap_slots;
      }
      ```
      </details>
  - **`init_thread()`**
    - Ensures all child processes share the same `swap_slots`.
    - Initializes `current_clock_index` to `0`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      init_thread (struct thread *t, const char *name, int priority)
      {
        // other codes
        t->current_running_file = NULL;
        #endif

        /* child shares the swap slot */
        t->swap_slots = global_swap_slots;

        t->current_clock_index = 0;

        old_level = intr_disable ();
        list_push_back (&all_list, &t->allelem);
        intr_set_level (old_level);
      }
      ```
      </details>
- **`page.h`**
  - **`struct spt_entry`**
      - Adds `slot_index` for swap space.
        * `slot_index` should be initialized to `-1` when a `spt_entry` is allocated.
      - Adds `is_immortal` flag for page swap.
        * `is_immortal` should be set to `true` if the page is:
          + the initial stack page, 
          + one of first two pages of the DATA segment, 
          + the page belonging to the CODE segment,
          + the first page of file-backed pages.
      - Currently, `load_segment()`, `page_fault()`, and `setup_stack()` are responsible for initializing these fields.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct spt_entry {
          // other codes
          bool writable;

          int slot_index;                         // needed to check whether it's related to swap space or not
          bool is_immortal;                       // needed for page swap

          struct list_elem sptelem;               // List element for page table   
      };
      ```
      </details>
- **`page.c`**
  - **Functions for Swap Space**
    - I managed swap space using four custom utility functions.
    - It's important to note that `block_read()` and `block_write()` operate based on `BLOCK_SECTOR_SIZE` (`512 bytes`), not `PGSIZE` (`4096 bytes`).
      * As a result, 8 block operations (`PGSIZE / BLOCK_SECTOR_SIZE = 8`) are required to handle a single page.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Returns the available slot index of swap_slots table */
      int 
      allocate_swap_index(void) 
      {
          struct thread* current_thread = thread_current();
          
          // The trick here is that swap_slots is incremented singly,
          // but when the current_slot is returned, it should be multiplied by 
          // PGSIZE / BLOCK_SECTOR_SIZE, because one page holds 8 sectors.
          for (int current_slot = 0; current_slot < SWAP_SIZE; ++current_slot) {
              if (current_thread->swap_slots[current_slot] == false) {
                  current_thread->swap_slots[current_slot] = true;
                  return current_slot;
              }
          }
          return -1;  // No free slot available
      }

      /* Frees the given slot_index of swap_slots table */
      void 
      free_swap_index(int slot_index)
      {
          if (slot_index >= 0 && slot_index < SWAP_SIZE)
              thread_current()->swap_slots[slot_index] = false;
      }

      /* Flushes the chosen page to swap space */
      void  
      write_to_swap_space(struct spt_entry *target_entry)
      {
          target_entry->slot_index = allocate_swap_index();

          int actual_sector_start_index = target_entry->slot_index * (PGSIZE/BLOCK_SECTOR_SIZE);
          if(target_entry->slot_index != -1) {
              const char *target_page = pagedir_get_page(thread_current()->pagedir, target_entry->vaddr);
              int current_sector_count = 0, end_count = PGSIZE/BLOCK_SECTOR_SIZE;
              while(current_sector_count < end_count) {
                  // The start index for the slot should be adjusted by 
                  // PGSIZE / BLOCK_SECTOR_SIZE.
                  block_write(block_get_role(BLOCK_SWAP), actual_sector_start_index + current_sector_count, target_page);  
                  ++current_sector_count;
                  target_page += BLOCK_SECTOR_SIZE;
              }
          }
      }

      /* Reads a page from swap space */
      void 
      read_from_swap_space(void *kpage, int slot_index)
      {
          const char *target_page = kpage;
          int actual_sector_start_index = slot_index * (PGSIZE/BLOCK_SECTOR_SIZE);
          int current_sector_count = 0, end_count = PGSIZE/BLOCK_SECTOR_SIZE;
          while(current_sector_count < end_count) {
              // The start index for the slot should be adjusted by 
              // PGSIZE / BLOCK_SECTOR_SIZE.
              block_read(block_get_role(BLOCK_SWAP), actual_sector_start_index + current_sector_count, target_page);
              ++current_sector_count;
              target_page += BLOCK_SECTOR_SIZE;
          }

          free_swap_index(slot_index);
      }
      ```
      </details>
  - **`pick_victim_page()`**
    - Selects the victim page using the clock algorithm.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Selects a victim page to evict */
      struct spt_entry* 
      pick_victim_page()
      {
          struct thread *current_thread = thread_current();
          struct spt_entry *target_spt_entry = NULL;
          bool is_full_cycle = false; 

          struct list_elem *current_element = list_begin(&current_thread->supplemental_page_table);
          struct list_elem *end_element = list_end(&current_thread->supplemental_page_table);
          if (current_element == end_element)
              return NULL; // No pages to swap

          int current_index = 0;
          while (current_index < current_thread->current_clock_index && current_element != end_element) {
              current_element = list_next(current_element);
              ++current_index;
          }
          if (current_element == end_element) {
              current_thread->current_clock_index = 0;
              current_element = list_begin(&current_thread->supplemental_page_table);
          }

          while (true) {
            if (current_element == end_element) {
                if (is_full_cycle) {
                    // Completed a full cycle; force selection of first loaded page
                    current_element = list_begin(&current_thread->supplemental_page_table);
                    current_index = 0;
                    while (current_element != end_element) {
                        target_spt_entry = list_entry(current_element, struct spt_entry, sptelem);
                        if (target_spt_entry->is_immortal == false && pagedir_get_page(current_thread->pagedir, target_spt_entry->vaddr) != NULL) {
                            current_thread->current_clock_index = current_index + 1; 
                            return target_spt_entry; 
                        }
                        ++current_index;
                        current_element = list_next(current_element);
                    }
                    return NULL; // No loaded pages found
                }
                current_thread->current_clock_index = 0;
                current_element = list_begin(&current_thread->supplemental_page_table);
                is_full_cycle = true;
                continue;
            }

            // Process the page at current_clock_index
            target_spt_entry = list_entry(current_element, struct spt_entry, sptelem);
            if (target_spt_entry->is_immortal == false && pagedir_get_page(current_thread->pagedir, target_spt_entry->vaddr) != NULL) {
                if (pagedir_is_accessed(current_thread->pagedir, target_spt_entry->vaddr) == false) {
                    ++current_thread->current_clock_index;
                    return target_spt_entry;
                }
                pagedir_set_accessed(current_thread->pagedir, target_spt_entry->vaddr, false);
            }

            ++current_thread->current_clock_index;
            current_element = list_next(current_element);
          }
      }
      ```
      </details>
  - **`evict_page()`**
    - Writes to swap space if the page is not for `mmap()`.
      * Specifically, if the page originally belongs to the DATA segment, this function changes its type to `SPT_ANON` to allow the page to be swapped out to swap space.
    - Frees the selected page.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Flushes the chosen page to swap space or the original physical address based on its type */
      void 
      evict_page(struct spt_entry* target_entry)
      {
          if(target_entry == NULL) 
              return;

          struct thread *current_thread = thread_current();

          // swap out DATA segment to SWAP SPACE as well
          if(target_entry->type == SPT_BIN)
              target_entry->type = SPT_ANON;

          if(target_entry->type == SPT_ANON) 
              write_to_swap_space(target_entry);
          else {
              // this section is for mmap
              if(pagedir_is_dirty(current_thread->pagedir, target_entry->vaddr)) {
                  file_write_at(target_entry->file, pagedir_get_page(current_thread->pagedir, target_entry->vaddr), PGSIZE, target_entry->offset); 
                  pagedir_set_dirty(current_thread->pagedir, target_entry->vaddr, false);
              }
          }
          
          palloc_free_page(pagedir_get_page(current_thread->pagedir, target_entry->vaddr));
          pagedir_clear_page(current_thread->pagedir, target_entry->vaddr);
      }
      ```
      </details>
  - **`handle_page_fault()`**
    - It is now fully implemented.
    - Frees 3 pages if memory becomes full.
    - Reads from swap space if the page is stored there; otherwise, it reads from the original file location.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* Handles the page fault */
      bool  
      handle_page_fault(struct spt_entry *target_spt_entry) 
      {     
          uint8_t *kpage = palloc_get_page (PAL_USER | PAL_ZERO);

          bool is_lock_already_owned = lock_held_by_current_thread(&filesys_lock);
          if(is_lock_already_owned == false)
              lock_acquire(&filesys_lock);

          if (kpage == NULL) {
              // swap out 3 pages whenever memory becomes full
              for(int current_count = 0; current_count < 3; ++current_count)
                  evict_page(pick_victim_page());

              kpage = palloc_get_page (PAL_USER | PAL_ZERO);
              if(kpage == NULL) {
                  // failed to evict
                  if(is_lock_already_owned == false)
                      lock_release(&filesys_lock);
                  return false;
              }
          }


          // load the data from disk
          if(target_spt_entry->type == SPT_ANON) {
              // if the page is stored in swap space, read from there
              if(target_spt_entry->slot_index != -1)
                  read_from_swap_space(kpage, target_spt_entry->slot_index);
          }
          else {
              // otherwise read from the disk
              if(file_read_at(target_spt_entry->file, kpage, target_spt_entry->read_bytes, target_spt_entry->offset) != target_spt_entry->read_bytes) {
                  palloc_free_page (kpage);
                  if(is_lock_already_owned == false)
                      lock_release(&filesys_lock);
                  return false;
              }
          }


          if(is_lock_already_owned == false)
              lock_release(&filesys_lock);


          // update page table  
          if (!install_page (target_spt_entry->vaddr, kpage, target_spt_entry->writable))  {
              palloc_free_page (kpage);
              return false; 
          }

          return true;
      }
      ```
      </details>
- **`process.c`**
  - **`load_segment()`**
    - Initializes `is_immortal` to `true` if the page belongs to the CODE segment or is one of the first two pages of the DATA segment.
    - Initializes `slot_index` to `-1`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static bool
      load_segment (struct file *file, off_t ofs, uint8_t *upage,
                    uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
      {
        // other codes
        bool is_code_segment = current_thread->initial_code_segment == NULL;
        bool is_first_or_second_data_segment = true;
        bool temp_flag = true;
        while (read_bytes > 0 || zero_bytes > 0) {
          // other codes
          new_entry->vaddr = upage;
          if (current_thread->initial_code_segment == NULL)
            current_thread->initial_code_segment = upage;
          new_entry->zero_bytes = page_zero_bytes;
          new_entry->file = file;
          new_entry->read_bytes = page_read_bytes;
          new_entry->offset = ofs;
          new_entry->writable = writable;
          new_entry->slot_index = -1;
          if(is_code_segment || is_first_or_second_data_segment) {
            new_entry->is_immortal = true;
            if(temp_flag)
              temp_flag = false;
            else
              is_first_or_second_data_segment = false;
          } 
          else
            new_entry->is_immortal = false;
          // other codse
        }
        return true;
      }
      ```
      </details>
  - **`setup_stack()`**
    - Initializes `is_immortal` to `true` to set up the initial page for the stack.
    - Initializes `slot_index` to `-1`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static bool
      setup_stack (void **esp) 
      {
        // other codes
        new_entry->type = SPT_ANON;
        new_entry->is_stack = true;
        new_entry->vaddr = current_thread->current_stack_top;
        new_entry->file = NULL;
        new_entry->writable = true;
        new_entry->slot_index = -1;
        new_entry->is_immortal = true;
        list_push_back(&current_thread->supplemental_page_table, &new_entry->sptelem);

        return success;
      }
      ```
      </details>
 
### Conclusion
- PintOS now supports page demand and page swapping.
  * The system can handle page faults, page eviction, and read from swap space when needed.
- However, it still does not handle `mmap()` and its associated memory mapping features.
  * Further improvements are needed to fully support memory mapping and ensure seamless handling of all memory operations.



## Part 4: Memory Mapping Features

### Objective
- The goal is to implement `mmap()` and `munmap()` to enable PintOS to handle file-backed memory mappings efficiently.

### Current Problem
- The current PintOS doesn't support `mmap()` and `munmap()`. 

### Solution
- I implemented `mmap()` and `munmap()` to support memory mapping.
- To achieve this:
  * I created a `struct mmap_entry` to store the information needed to load data from a given file.
  * I added `loaded_spt_entries` for each thread to manage file-backed pages.
  * I implemented `is_mmap_overlapped()` to check for overlapping issues.
- Since `is_mmap_overlapped()` checks the DATA segment, I added `final_data_segment` to the `struct thread` to handle this properly.

### Implementation Details
- **`page.h`**
  - **`struct mmap_entry`**
    - Newly created.
    - Stores essential information for loading data from the specified file.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      /* mmap_entry for mmap_table in each thread */
      struct mmap_entry {
          int map_id;
          int number_of_pages;
          struct file *mapped_file;
          struct list loaded_spt_entries;           // List for loaded spt_entry 

          struct list_elem mmelem;                  // List element for mapping table  
      };
      ```
      </details>
- **`thread.h`**
  - **`struct thread`**
    - Adds `mmap_table`, `current_available_map_id`, and `final_data_segment`.
      * `mmap_table` and `current_available_map_id` are initialized in `init_thread()`.
      * `final_data_segment` is initialized in `load_segment()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      struct thread
      {
          // other codes
          bool *swap_slots;                                      /* swap slot */
          int current_clock_index;                               /* current index of page for clock algorithm*/


          struct list mmap_table;                                /* memory mapping table for mmap() */
          int current_available_map_id;                          /* id for mmap_entry */
          void *final_data_segment;                              /* address of data segment */

          /* Owned by thread.c. */
          unsigned magic;                     /* Detects stack overflow. */
      };
      ```
      </details>
- **`thread.c`**
  - **`init_thread()`**
    - Initializes `mmap_table`.
    - Initializes `current_available_map_id` as `0`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      init_thread (struct thread *t, const char *name, int priority)
      {
        // other codes
        t->current_clock_index = 0;

        list_init(&t->mmap_table);
        t->current_available_map_id = 0;

        old_level = intr_disable ();
        list_push_back (&all_list, &t->allelem);
        intr_set_level (old_level);
      }
      ```
      </details>
- **`process.c`**
  - **`load_segment()`**
    - Initializes `final_data_segment`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static bool
      load_segment (struct file *file, off_t ofs, uint8_t *upage,
                    uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
      {
        // other codes
        while (read_bytes > 0 || zero_bytes > 0) {
          // other codes
          ofs += PGSIZE;
        }/* Advance. */
        if (is_code_segment == false)
          current_thread->final_data_segment = upage;

        return true;
      }
      ```
      </details>
  - **`process_exit()`**
    - Calls `munmap()` on each remaining entry in `mmap_table`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void
      process_exit (void)
      {
        // other codes
        /* deallocate supplemental page table */
        for(struct list_elem *current_element = list_begin(&cur->supplemental_page_table), *end_element = list_end(&cur->supplemental_page_table), *next_element;
            current_element != end_element;) 
        {
          struct spt_entry *target_entry = list_entry(current_element, struct spt_entry, sptelem);
          next_element = list_next(current_element);
          list_remove(current_element);
          free(target_entry);
          current_element = next_element;
        }

        /* deallocate mmap table */
        for(struct list_elem *current_element = list_begin(&cur->mmap_table), *end_element = list_end(&cur->mmap_table), *next_element; 
            current_element != end_element;) 
        {
          struct mmap_entry *target_mmap = list_entry(current_element, struct mmap_entry, mmelem);
          current_element = list_next(current_element);
          munmap(target_mmap->map_id);
        }
        // other codes
      }
      ```
      </details>
- **`syscall.c`**
  - **`mmap()`**
    - Newly created.
    - Calls `file_reopen()` to ensure the file object for `mmap()` is independent of the existing file object.
    - Calls `is_mmap_overlapped()` to check for any overlapping issues.
    - Sets `is_immortal` to `true` for the first page.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      int mmap(int fd, void *addr) {
        struct thread *current_thread = thread_current();  
        lock_acquire(&filesys_lock);
        if(current_thread->fd_table[fd] == NULL || addr == NULL || is_user_vaddr(addr) == false || (uintptr_t)addr % PGSIZE != 0) {
          lock_release(&filesys_lock);
          return -1;
        }
        lock_release(&filesys_lock);

        struct mmap_entry *new_mmap_entry = malloc(sizeof(struct mmap_entry));
        if(new_mmap_entry == NULL)
          exit(-1);
        list_init(&new_mmap_entry->loaded_spt_entries);
        new_mmap_entry->map_id = current_thread->current_available_map_id;
        ++current_thread->current_available_map_id;

        lock_acquire(&filesys_lock);
        // file_reopen() is needed to create a separate file object
        new_mmap_entry->mapped_file = file_reopen(current_thread->fd_table[fd]);
        int read_bytes = file_length(new_mmap_entry->mapped_file);
        new_mmap_entry->number_of_pages = (read_bytes + PGSIZE - 1) / PGSIZE;
        if(is_mmap_overlapped(addr, new_mmap_entry->number_of_pages) == true) {
          file_close(new_mmap_entry->mapped_file);
          --current_thread->current_available_map_id;
          free(new_mmap_entry);
          lock_release(&filesys_lock);
          return -1;
        }
        lock_release(&filesys_lock);

        int offset = 0;
        bool is_first_page = true;
        while (read_bytes > 0) {
          size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
          size_t page_zero_bytes = PGSIZE - page_read_bytes;

          struct spt_entry *new_spt_entry = malloc(sizeof(struct spt_entry));
          if(new_spt_entry == NULL)
            return false;
          new_spt_entry->type = SPT_FILE;
          new_spt_entry->is_stack = false;
          new_spt_entry->vaddr = addr;
          new_spt_entry->zero_bytes = page_zero_bytes;
          new_spt_entry->file = new_mmap_entry->mapped_file;
          new_spt_entry->read_bytes = page_read_bytes;
          new_spt_entry->offset = offset;
          new_spt_entry->writable = true;
          new_spt_entry->slot_index = -1;
          if(is_first_page) {
            new_spt_entry->is_immortal = true;
            is_first_page = false;
          }
          else
            new_spt_entry->is_immortal = false;

          list_push_back(&new_mmap_entry->loaded_spt_entries, &new_spt_entry->sptelem);

          // Advance. 
          read_bytes -= page_read_bytes;
          addr += PGSIZE;
          offset += PGSIZE;
        }
        list_push_back(&current_thread->mmap_table, &new_mmap_entry->mmelem);

        return new_mmap_entry->map_id;
      }
      ```
      </details>
  - **`is_mmap_overlapped()`**
    - Newly created.
    - Checks all `mmap_entry` objects.
    - Checks if the given memory overlaps before the end of the DATA segment or after the top of the stack.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      bool is_mmap_overlapped(void *vaddr_start, int number_of_pages) {
        struct thread *current_thread = thread_current();
        void *vaddr_end = vaddr_start + number_of_pages * PGSIZE;

        void *mmap_start = NULL, *mmap_end = NULL;
        for(struct list_elem *current_element_mmap = list_begin(&current_thread->mmap_table), *end_element_mmap = list_end(&current_thread->mmap_table); 
            current_element_mmap != end_element_mmap; 
            current_element_mmap = list_next(current_element_mmap)) 
        {
          struct mmap_entry *current_mmap_entry = list_entry(current_element_mmap, struct mmap_entry, mmelem);
          for(struct list_elem *current_element_spt = list_begin(&current_mmap_entry->loaded_spt_entries), 
                                                              *end_element_spt = list_end(&current_mmap_entry->loaded_spt_entries); 
              current_element_spt != end_element_spt; 
              current_element_spt = list_next(current_element_spt)) 
          {
            struct spt_entry *current_spt_entry = list_entry(current_element_spt, struct spt_entry, sptelem);

            mmap_start = current_spt_entry->vaddr;
            mmap_end = mmap_start + PGSIZE;
            if (!(vaddr_end <= mmap_start || vaddr_start >= mmap_end))
              return true;
          }
        }
        
        // check data segment
        if (vaddr_start < current_thread->final_data_segment)
          return true; 

        // check stack
        if (vaddr_end > thread_current()->current_stack_top)
          return true;

        return false; 
      }
      ```
      </details>
  - **`munmap()`**
    - Newly created.
    - Removes the target `mmap_entry` from the current thread's `mmap_table`.
    - Closes the target `file` object.
    - Frees all pages and their associated `spt_entry` objects related to the target `mmap_entry`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      void munmap(int map_id) {
        struct thread *current_thread = thread_current();
        struct mmap_entry *target_mmap_entry = NULL;
        for(struct list_elem *current_element = list_begin(&current_thread->mmap_table), *end_element = list_end(&current_thread->mmap_table); 
            current_element != end_element; 
            current_element = list_next(current_element)) 
        {
          target_mmap_entry = list_entry(current_element, struct mmap_entry, mmelem);
          if(target_mmap_entry->map_id == map_id) {
            list_remove(current_element);
            break;
          }
        }
        if(target_mmap_entry == NULL)
          exit(-1);

        bool is_lock_already_owned = lock_held_by_current_thread(&filesys_lock);
        if(is_lock_already_owned == false)
          lock_acquire(&filesys_lock);
        for(struct list_elem *current_element_spt = list_begin(&target_mmap_entry->loaded_spt_entries), 
                          *end_element_spt = list_end(&target_mmap_entry->loaded_spt_entries), *next_element_spt; 
            current_element_spt != end_element_spt;) 
        {
          struct spt_entry *current_spt_entry = list_entry(current_element_spt, struct spt_entry, sptelem);
          next_element_spt = list_next(current_element_spt);

          list_remove(current_element_spt);
          if(pagedir_is_dirty(current_thread->pagedir, current_spt_entry->vaddr)) {
            file_write_at(current_spt_entry->file, pagedir_get_page(current_thread->pagedir, current_spt_entry->vaddr), current_spt_entry->read_bytes, current_spt_entry->offset); 
            pagedir_set_dirty(current_thread->pagedir, current_spt_entry->vaddr, false);
          }

          palloc_free_page(pagedir_get_page(current_thread->pagedir, current_spt_entry->vaddr));
          pagedir_clear_page(current_thread->pagedir, current_spt_entry->vaddr);

          free(current_spt_entry);
          current_element_spt = next_element_spt;
        }
        file_close(target_mmap_entry->mapped_file);
        if(is_lock_already_owned == false)
          lock_release(&filesys_lock);
        free(target_mmap_entry);
      }
      ```
      </details>
  - **`syscall_handler()`**
    - Calls `mmap()` and `munmap()`.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void syscall_handler(struct intr_frame* f) {
        int *current_esp = f->esp;

        if(is_valid_address(current_esp) == false)
          return;

        switch (current_esp[0])
        {
          // other codes
            case SYS_CLOSE: close(current_esp[1]); break;

            case SYS_MMAP: f->eax = mmap(current_esp[1], current_esp[2]); break;
            case SYS_MUNMAP: munmap(current_esp[1]); break;
        }
      }
      ```
      </details>
- **`exception.c`**
  - **`page_fault()`**
    - `page_fault()` is now fully implemented.
    - It also handles file-backed pages.
      <details markdown="1">
      <summary><b>Click</b> to see the refined code</summary>

      ```c
      static void
      page_fault (struct intr_frame *f) 
      {
        // other codes

        // handle page demanding
        struct spt_entry *target_spt_entry = NULL;
        for(struct list_elem *current_element = list_begin(&current_thread->supplemental_page_table), *end_element = list_end(&current_thread->supplemental_page_table); 
            current_element != end_element; 
            current_element = list_next(current_element)) 
        {
            target_spt_entry = list_entry(current_element, struct spt_entry, sptelem);
            if(target_spt_entry->vaddr <= fault_addr && (target_spt_entry->vaddr + PGSIZE) > fault_addr) {
              if(handle_page_fault(target_spt_entry))
                  return;
              else 
                  exit(-1);
            }
        }

        // handle memory-mapped file
        for(struct list_elem *current_element_mmap = list_begin(&current_thread->mmap_table), *end_element_mmap = list_end(&current_thread->mmap_table); 
            current_element_mmap != end_element_mmap; 
            current_element_mmap = list_next(current_element_mmap)) 
        {
            struct mmap_entry *current_mmap_entry = list_entry(current_element_mmap, struct mmap_entry, mmelem);
            for(struct list_elem *current_element_spt = list_begin(&current_mmap_entry->loaded_spt_entries), *end_element_spt = list_end(&current_mmap_entry->loaded_spt_entries); 
                current_element_spt != end_element_spt;
                current_element_spt = list_next(current_element_spt)) 
            {
              target_spt_entry = list_entry(current_element_spt, struct spt_entry, sptelem);
              if(target_spt_entry->vaddr <= fault_addr && (target_spt_entry->vaddr + PGSIZE) > fault_addr) {
                  if(handle_page_fault(target_spt_entry))
                    return;
                  else
                    exit(-1);
              }
            }
        }
        // other codes
      }
      ```
      </details>

### Conclusion
- PintOS now has full features for memory management, including paging, page swapping, and memory mapping.
- The system handles file-backed pages, stack growth, and ensures proper management of both anonymous and memory-mapped pages.


### Improved Grade
<img src="data:image/png;base64,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" alt="Description of image">

## Final Thoughts
- These enhancements have significantly improved memory management capabilities of PintOS, enabling effective handling of page faults, page swapping, and memory-mapped files.
- This third project optimized memory utilization, ensured proper handling of file-backed and anonymous pages.


[Top](#){: .btn .btn--primary }{: .align-right}