---
title: "Chapter 16"

categories:
    - cpp

tags:
    - [C++, Programming Language, Template]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-17
---

# Templates and Generic Programming

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Defining a Template
Templates are the foundation for generic programming in C++
- a template is a **blueprint** for creating classes or functions
- we need to supply the information needed to transform that **blueprint** into a specific class or function
    * and that transformation happens during compilation

### Function Templates
A **function template** is a formula from which we can generate type-specific versions of that function
```c++
template <typename T>
inline int compare(const T &lhs, const T &rhs) {
    if(lhs < rhs) return -1;
    if(lhs > rhs) return 1;
    return 0;
}
```
- a template definition starts with the keyword `template` followed by a **template parameter list**, which is a comma-separated list of one or more **template parameters** bracketed by the < and > tokens
    * when we use a template, we specify either **implicitly** or **explicitly** the **template arguments** to bind to the **template parameters**
- the compiler uses the arguments of the call to **deduce** the template arguments
    * and the comiler uses the **deduced** template parameters to **instantiate** a specific version of the function
    * the compiler-generated functions are generally referred to as an **instantiation** of the template
- also, if you want to declare template function as `inline` or `constexpr`, you need to place the keyword **after** the template parameter list
    * otherwise, an error occurs

### Template Parameter List
Like a function parameter list, template parameters represent **types** or **values** used in the definition of a class or a function
```c++
template <class T, K> void function() {}            // error
template <class T, typename K> void function() {}   // same meaning
template <unsigned N> void function(const char (&p)[N]) {}   // same meaning
```
- they can be used as a usual type specifier
- there are two kinds of template parameters
    * template **type** parameter
        + which can be specified by the keyword `class` or `typename` which have the same meaning
        + it's used for representing the **type**
    * template **nontype** parameter
        + which can be specified by the `integral` type, or a `pointer` or (lvalue)`reference` to an object or a `function` type  
        + it's used for representing the **value**
        + the **value** is supplied by the user or deduced by the compiler
        + also the **value** must be a **constant expression**
            + so that the compiler can instantiate the template during compile time 
- each type parameter must be preceded by the proper keywords, such as `typename`, `integral` type
- template programs should try to minimize the number of requirements placed on the argument types

### Templates and Headers
One of the features of the well-structured programs is to make appropriate use of headers
- definitions of function templates or member functions of class templates are ordinarily put into header files
- and the users of the template must include the header for the template to instantiate it properly

### Templates and Errors
In general, there are 3 stages during which the compiler might flag an error
- the first stage is when we compile the template itself
    * the compiler can detect syntax errors but not much less
- the second stage is when the compiler sees a use of the template
    * for a call to a function template, the compiler typically will check that the number of the arguments is appropriate
        + it can also detect whether two arguments that are supposed to have the same type do so
    * for a class template, the compiler can check that the right number of template arguments are provided but no much more
- the third time is when errors are detected during instantiation
    * it is only then that type-related errors can be found
    * depending on how the compiler manages instantiation, these errors may be reported at link time

### Class Templates
A **class template** is a **blueprint** for generating classes
```c++
template <typename T>
class Name {
    ... // some codes
    std::vector<T> mem;
}
```
- like function templates, class templates begin with the keyword `template` followed by a **template parameter list**
    * in the definition of the class template (and its memebers), we can use the template parameters as stand-ins for **types** or **values** that will be supplied when the template is used
- class templates differ from function templates in that the compiler **cannot** **deduce** the template parameter types for a class template
    * the template arguments must be provided to use the class templates
- each instantiation of a class template consistutes an **independent** class
    * which means, the type `Name<int>` has no relationship to, or any special access to, the members of any other `Name` type

### Member Functions of Class Templates
As with any class, we can define the methods a class template either inside or outside of the class body
```c++
// definition of method outside the class body of the template
template <typename T>
ret-type ClassName<T>::methodName(param-list) {
    ;
}


template <typename T>
class ClassName {
    ClassName methodName(param-list) {   // ok; it's inside class body
        ;
    }
}
template <typename T>
ClassName ClassName<T>::methodName(param-list) {       // error; the return type should be ClassName<T>
    ;
}
template <typename T>
ClassName<T> ClassName<T>::methodName(param-list) {       
    ClassName a;                    // ok; because it's inside class scope
    ... // some codes
}
```
- as with any other class, members defined inside the class body are implicitly `inline`
- a member function defined outside the class template body, starts with the keyword `template` followed by the class's template parameter list
    * also as usual, the name of a class generated from a template includes its template arguments
- by default, a member of an instantiated class template is instantiated **only if** the member is used
- inside the scope of a class template itself, we may use the name of the template without arguments
    * the compiler treats the name of template as if we had supplied template arguments matching the template's own parameters
        * which means, the compiler treats `ClassName` as `ClassName<T>` inside class **scope**
        * the body of the member function defined outside the class body is also treated as a class scope

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}