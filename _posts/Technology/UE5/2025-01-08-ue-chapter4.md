---
title: "Unreal Engine 5 : How to Implement a Matchmaking System"

categories:
    - ue5

tags:
    - [Game Engine, Unreal Engine 5, Multiplayer, Matchmaking]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2025-01-08
---

# Unreal Engine 5 : Chapter 4


## Implement a Matchmaking System

### Step 1 : Create a Queue Class
Create a C++ class to manage the player queue

1. **Create the Class:**
   - In the `Unreal Editor`, go to `Tools` -> `New C++ Class`
   - Select `None` as the **parent class**
   - Name it `APlayerQueueManager`

2. **Define the Class:**
    ```cpp
    #pragma once

    #include "CoreMinimal.h"
    #include "PlayerQueueManager.generated.h"
    #include "GameFramework/PlayerController.h"


    // Store the time when a player enters the queue
    class FQueuedPlayer {
    public:
        TWeakObjectPtr<APlayerController> playerController;  // Use weak pointer to avoid circular references
        float timeEnteredQueue;                              // Timestamp when the player enters the queue

        FQueuedPlayer(APlayerController* inPlayerController) : playerController(inPlayerController), timeEnteredQueue(0.0f) { }
    };


    UCLASS()
    class YOURGAME_API APlayerQueueManager : public AActor {
        GENERATED_BODY()
    public:
        APlayerQueueManager();

        void addPlayerToQueue(APlayerController*);
        void removePlayerFromQueue(APlayerController*);
        float getWaitTimeForPlayer(APlayerController*)
        // Match players and start the game
        void matchPlayers();

    private:
        constexpr int32 MIN_PLAYERS_TO_START = 2;
        // Queue of player controllers
        TArray<FQueuedPlayer*> playerQueue;
    };
    ```

3. **Implement the Class:**
   ```cpp
   #include "PlayerQueueManager.h"
   #include "Engine/World.h"
   #include "TimerManager.h"

   APlayerQueueManager::APlayerQueueManager() {}

   void APlayerQueueManager::addPlayerToQueue(APlayerController* playerController) {
       if (playerController) {
            for(const auto &currentPlayer : playerQueue) {
                if(currentPlayer.playerController.Get() == playerController)
                    return;
            }

            // if the playerController is valid and it's not queued yet, then enqueue it
            TSharedPtr<FQueuedPlayer> newPlayer = MakeShareable(new FQueuedPlayer(playerController));

            newPlayer->timeEnteredQueue = GetWorld()->GetTimeSeconds();  // Store the current time in seconds when player joins
            playerQueue.Add(newPlayer);
            UE_LOG(LogTemp, Log, TEXT("Player added to queue. Current queue size: %d"), playerQueue.Num());
       }
   }

   void APlayerQueueManager::removePlayerFromQueue(APlayerController* playerController) {
        for (int32 currentIndex = 0, endIndex = playerQueue.Num(); currentIndex < endIndex; ++currentIndex) {
            if (playerQueue[currentIndex]->playerController.IsValid() && playerQueue[currentIndex]->playerController->IsA<APlayerController>() && playerQueue[currentIndex]->playerController.Get() == playerController) {
                // Remove the player from the queue
                playerQueue.RemoveAt(currentIndex);
                UE_LOG(LogTemp, Log, TEXT("Player removed from queue. Current queue size: %d"), playerQueue.Num());
                return; 
            }
        }

        UE_LOG(LogTemp, Warning, TEXT("Player not found in queue."));
   }

   void APlayerQueueManager::getWaitTimeForPlayer(APlayerController* playerController) {
        for (const auto &currentPlayer : playerQueue) {
            if (currentPlayer->playerController.Get() == PlayerController)
                return GetWorld()->GetTimeSeconds() - Player->TimeEnteredQueue;   // Return the time the player has been waiting
        }
        return 0.0f;  // If player isn't in queue, return 0
   }

   void APlayerQueueManager::matchPlayers() {
       if (playerQueue.Num() >= MIN_PLAYERS_TO_START) {
           UE_LOG(LogTemp, Log, TEXT("Match starting with %d players!"), playerQueue.Num());

           // Logic to start the match, such as opening a new level
           for (auto &wpCurrentPlayer : playerQueue) {
               auto currentPlayer = wpCurrentPlayer.Get();
               if (currentPlayer)
                   currentPlayer->ClientTravel("/Game/Maps/YourMatchMap", ETravelType::TRAVEL_Absolute);
           }

           // Clear the queue after starting the match
           playerQueue.Empty();
       }
   }
   ```

### Step 2: Integrate the Queue into Your GameMode
Implement the custom `GameModeBase` class to use the queue system

1. **Create the UI Widget Blueprint**
- First, we'll create a `UI Widget Blueprint` to handle the display of the queue wait time
    - **Create a new Widget Blueprint**
        * Right-click in the `Content Browser` and go to `User Interface` -> `Widget Blueprint`
        * Name it something like `BP_QueueStatusWidget`
    - **Design the Widget**
        * Open the newly created widget (`BP_QueueStatusWidget`)
        * In the designer, drag a `TextBlock` into the `Canvas`

2. **Create a C++ Class to Manage the Queue UI**
- Now, we'll modify the `GameMode` or a custom HUD class to manage and display the queue wait time on the UI
    * **Add a Reference to the Widget in Your Game Mode**
        + In your `GameModeBase` (or another class, like `PlayerController`), you need to reference the `QueueStatusWidget` to display it
        + Update the `AYourGameModeBase` to include this reference
            ```cpp
            #include "Blueprint/UserWidget.h"
            #include "BP_QueueStatusWidget.h"
            #include "PlayerQueueManager.h"

            class YOURGAME_API AYourGameModeBase : public AGameModeBase {
                GENERATED_BODY()
            public:
                void postLogin(APlayerController*) override;
                void updateQueueUI();                            // Update queue status in UI
            private:
                APlayerQueueManager* queueManager;

                UTextBlock* waitTimeText = nullptr;
                float estimatedWaitTime;                         // In minutes or seconds
            };
            ```
    * **Spawn and Display the Widget in `postLogin`**:
        + In the `postLogin` function, we'll spawn and display the widget when a player joins the game
            ```cpp
            #include "YourGameModeBase.h"
            void AYourGameModeBase::postLogin(APlayerController* newPlayer) {
                Super::postLogin(newPlayer);

                if (!queueManager)
                    queueManager = GetWorld()->SpawnActor<APlayerQueueManager>();

                if (queueManager)
                    queueManager->AddPlayerToQueue(newPlayer);

                // Set the TextBlock widget for displaying wait time (assuming you have named it)
                waitTimeText = Cast<UTextBlock>(QueueStatusWidget->GetWidgetFromName("WaitTimeText"));
            }
            ```
    * **Update the Queue UI Dynamically**:
        + Implement the logic to update the `QueueStatusWidget` based on changes in the queue system. For example, as players are added or removed from the queue, the position and wait time need to be updated
            ```cpp
            #include "YourGameModeBase.h"
            #include "Blueprint/UserWidget.h"
            #include "Components/TextBlock.h"

            void AYourGameModeBase::updateQueueUI() {
                if (queueManager && waitTimeText) {
                    // Assuming you have access to the player controller
                    APlayerController* playerController = GetWorld()->GetFirstPlayerController();
                    if (playerController) {
                        float waitTime = queueManager->GetWaitTimeForPlayer(playerController);      // Get the wait time for this player
                        waitTimeText->SetText(FText::Format(FText::FromString("Waiting time: {0}m {1}s"), FMath::FloorToInt(waitTime / 60.0f), FMath::FloorToInt(waitTime) % 60));
                    }
                }
            }
            ```
    * **Update Queue Wait Time in Real-Time**
        + To make sure the UI updates in real-time as the queue progresses, you should periodically call `UpdateQueueUI()` whenever there's a change in the queue
        + You could implement a timer to periodically update the status while the player remains in the queue
            ```cpp
            #include <thread>
            // in some code
            bool isQueueEnded = false;
            AYourGameModeBase *gameModeBase;

            // in some code
            threadTimer = std::thread([&isQueueEnded, gameModeBase]()
            {
                while (isQueueEnded == false) {
                    std::this_thread::sleep_for(std::chrono::seconds(1));  // Sleep for 1 second
                    gameModeBase->updateQueueUI();
                }
            });

            // in some code
            isQueueEnded = true; // setting this flag as true to end the timer
            ```

### Step 3 : Test the Queue System
1. Run the game in multiplayer mode
2. Add players to the game and observe how they are queued
3. Verify that the game starts automatically when the required number of players join



[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}