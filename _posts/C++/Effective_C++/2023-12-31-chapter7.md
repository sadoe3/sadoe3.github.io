---
title: "Effective C++ : Chapter 7"

categories:
    - cpp

tags:
    - [C++, Programming Language, Effective C++, Template, Generic Programing]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-31
---

# Templates and Generic Programming

> 이 포스트는 Effective C++(3rd Edition)를 바탕으로 작성되었습니다.

## Item 41

### Understand implicit interfaces and compile-time polymorphism
Unlike run-time polymorphism, compile-time polymorphism can happen in 2 cases
1. through overloading functions
2. through instantiating function templates
- you can increase the run-time performance through compile-time polymorphism


## Item 43

### Know how to access names in templatized base classes
The following code shows how to access the base part from the class template which is derived from another class template
```c++
template <typename T>
class Derived : public Base<T> {
public:
    void memberFunc() {
        Base<T>::baseMember();
    }
};
```
- it's worth noting that you need to supply the **template parameter** so that the base template class is treated as a type not template


## Item 44

### Factor parameter-independent code out of templates
Using templates can lead to *code bloat* : binaries with **replicated** (or almost replicated) code, data or both
- the result of **code bloat** can be source code that looks like fit and trim yest object code that's fat and flabby
- there are 2 possible causes of code duplications
    * due to **non-type** template parameter
        ```c++
        // problem
        template <typename T, std::size_t n> 
        class ClassName {
            void memberFunc();  // do something based on the value of n
        };

        // solution
        template <typename T> 
        class ClassName {
            void memberFunc(const std::size_t n);  // do something based on the value of n
        };
        // or
        template <typename T> 
        class ClassName {
            void memberFunc();  // do something based on the value of n
            std::size_t n;
        };
        ```
        + it can be resolved by replacing it with function parameter or class data member
    * due to **type** template paramemter
        + it can be eliminated by sharing implementation for instantiation types with identical binary representations
        + typically, this means implementing member functions that work with strongly typed pointer by having them call functions that work with untyped pointers
        + some implementations of the standard C++ library do this for templates like `std::vector`, `std::deque` and `std::list`
    

## Item 45

### Use member function templates to accept "all compatible types"
If you want the certain method to take all compatible types, try to define it as a **member function template**
```c++
// basic example
template <typename T>
class ClassName {
public:
    template <typename U> friend class ClassName;   // necessary
    template <typename U>
    ClassName(const ClassName<U>& input) : mem(input.mem) { std::cout << "this is generalized" << std::endl; }   // generalized
    ClassName() : mem() { std::cout << "this is default" << std::endl; }                                // default
private:
    std::string mem;
};
...             // some codes
ClassName<int> a;
ClassName<double> b(a);
// prints
// this is default
// this is generalized


// the enclosing class doesn't have to be a template
class A {
public:
    template <typename T>
    A(const T& a) { std::cout << "generalized"; }
};
A c(3);                     // works
A d("dd");                  // works
A e(3.1);                   // works
```
- if that member function template is a **copy constructor**, then it's usually called as **generalized** copy constructor
    * it's worth noting that `ClassName<T>` and `ClassName<U>` are **different** types
        + which means they **cannot access** to their `private` part unless they are `friend`
    * also note that the **default copy constructor** is **not implicitly synthesized** if you define **generalized** copy constructor
    * same rules are applied to **copy assignment** operators


## Item 46

### Define non-member functions inside templates when type conversions are desired
If you need to define an overloaded operator which takes left-hand side operand which can be constructed from a conversion for a class template
- same rules are applied as [**Item 24**](https://sadoe3.github.io/cpp/chapter4/#item-24)
    * the easiest way to use those rules for class template is
        ```c++
        template <typename T>
        class Rational {
        public:
            // other members
            friend const Rational operator*(const Rational& lhs, const Rational& lhs){
                return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());
            }
        }
        ```
        + define it **inside** a class template
        + and declare it as a `friend`
        + then, it would be **non-member** function but a `friend` to that class template
- note that it's implicitly declared as `inline`
    * if you don't want this, try to define the helper function
        ```c++
        // declare helper function template
        template <typename T>
        const Rational<T> doMultiply(const Rational& lhs, const Rational& lhs); 

        // almost same definition
        template <typename T>
        class Rational {
        public:
            // other members
            friend const Rational operator*(const Rational& lhs, const Rational& lhs){
                return doMultiply(lhs, rhs);
            }
        }

        // define helper function template
        template <typename T>
        const Rational<T> doMultiply(const Rational& lhs, const Rational& lhs) {
            return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());
        }
        ```


## Item 48

### Be aware of template metaprogramming
Template metaprogramming can shift work from runtime to compile-time, thus enabling earlier error detection and higher runtime performance
```c++
// example of TMP
template <unsigned n>
struct Factorial {
    enum { value = n * Factorial<n-1>::value};
};
template <>
struct Factorial<0> {
    enum { value = 1 };
};
// some codes
std::cout << Factorial<3>::value << std::endl;      // prints 6
```
- TMP can be used to generate custom code based on combinations of policy choices,
- and it can also be used to avoid generating code inappropriate for particular types

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}