---
title: "C++ Primer : Chapter 17"

categories:
    - cpp

tags:
    - [C++, Programming Language, tuple, regular expression, random, IO]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-20
---

# Specialized Library Facilities

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## The tuple Type
A `std::tuple` is a template that is similar to a `std::pair`
- like `std::pair`, it can have members whose types vary from one `tuple` type to another
- unlike `std::pair`, it can have any number of members
- a `std::tuple` is most useful when we want to combine some data into a single object but do not want to bother to define a data structure to represent those data 
- it's defined in the `<tuple>` header

### Operations On tuples
The following table shows the operations of `std::tuple`
||Operations on `std::tuple`|
|:---|:---|
|`tuple<T1, T2, ..., Tn> t;`|`t` is a `std::tuple` with as many members there are types `T1` ... `Tn`. the members are value initialized|
|`tuple<T1, T2, ..., Tn> t(v1, v2, ..., vn);`|`t` is a `std::tuple` with types `T1`...`Tn` in which each members is initialized from the corresponding initializer, vi. this constructor is `explicit`|
|`make_tuple(v1, v2, ..., vn)`||
|``||
|``||
|``||
|`get<i>(t)`|as usual, the index starts at 0|
|``||
- the following codes show the example of the use of `std::tuple`
```c++
#include <tuple>
auto item = std::make_tuple(3, "haha", 7.02);
std::get<0>(item) /= 3;         // the first element is now 1
```

## The bitset Type
If you want to handle the collections of bits that are larger than the longest integral type, **std::bitset** class which is defined in the `<bitset>` header would be a good solution

## Regular Expressions
A **regular expression** is a way of describing a sequence of characters

### Regular Expression Library Components
The C++ regular-expression library (RE library) is defined in the `<regex>` header
- the following table shows the components of the library
    ||Regular Expression Library Components|
    |:---|:---|
    |`regex`|class that represents a regular expression|
    |`regex_match`|matches a sequence of characters against a regular expression|
    |`regex_search`|finds the first subsequence that matches the regular expression|
    |`regex_replace`|replaces a regular expression using a given format|
    |`sregex_iterator`|iterator adaptor that calls `regex_search` to iterate through the matches in a string|
    |`smatch`|container class that holds the results of seraching a string|
    |`ssub_match`|results for a matched subexpression in a string|
- the following table shows arguments regarding `std::regex_search` and `std::regex_match`
    ||Arguments to `std::regex_search` and `std::regex_match`|
    |:---|:---|
    ||**Note: These operations return `bool` indicating whether a match was found**|
    |`(seq, m, r, mft)`|look for the regular expression in the `std::regex` object `r` in the character sequence `seq`. `m` is a *match* object, which is used to hold details about the match|
    |`(seq, r, mft)`|`m` and `seq` must have the compatibal types. `mft` is an optional `std::regex_constants::match_flag_type` value. these values affect the match process|
- the following table shows the match flags
    ||**Match Flags**|
    |:---|:---|
    ||**Defined in `std::regex_constants::match_flag_type`**|
    |`match_default`|equivalent to `format_default`|
    |``||
    |``||
    |``||
    |``||
    |``||
    |``||
    |``||
    |``||

### Regular Expression Classes and the Input Sequence Type
The following table shows which classes support a certain input sequence type
||Regular Expression Library Classes|
|:---:|:---:|
|**If Input Sequence Has Type**|**Use Regular Expression Classes**|
|`std::string`|`std::regex`, `std::smatch`, `std::ssub_match` and `std::sregex_iterator`|
|`const char*`|`std::regex`, `std::cmatch`, `std::csub_match` and `std::cregex_iterator`|
|`std::wstring`|`std::wregex`, `std::wsmatch`, and `std::wsregex_iterator`|
|`const wchar_t*`|`std::wregex`, `std::wcmatch` and `std::wcregex_iterator`|

### regex Classes
`std::regex` class is initialized with the **pattern**
- the **pattern** consists of one or more **subexpressions**
    * by default, the regular-expression language used by `std::regex` objects is ECMAScript
    * you can find the whole details regarding it [**here**](https://en.cppreference.com/w/cpp/regex/ecmascript)
- the `std::regex` class is used to call `regex_match`, `regex_search`, `regex_replace`, or to get `sregex_iterator`
    * after processing it, the `std::smatch` object is returned
    * and you can get `std::ssub_match` from `std::smatch` object
- the following table shows the operations on `std::regex`
    ||`std::regex` (and `std::wregex`) Operations |
    |:---:|:---:|
    |`regex r(re)`|`re` represents a regular expression and can be a `std::string`, a pair of iterators denoting a range of characters, a pointer to a null-terminated character array, a character pointer with a count, or a braced list of characters|
    |`regex r(re, f)`|`f` are flags that specify how the object will execute. `f` is set from the values listed below. if `f` is not specified, it defaults to `ECMAScript`|
    |`r1 = re`|replace the regular expression in `r1` with `re`. `re` represents a regular expression and can be another `std::regex`, a `std::string`, a pointer to a null-terminated character array, or a braced list of characters|
    |`r1.assign(re, f)`|same effect as using the assignment operator. `re` and optional flag `f` same as corresponding arguments to `std::regex` constructors|
    |`r1.mark_count()`|returns the number of subexpressions in `r`|
    |`r.flags()`|returns the flags set for `r`|
    ||*Note: Constructors and assignment operations mahy throw expcetions of type `std::regex_error`*|
    ||**Flags Specified When a `std::regex` Is Defined**|
    |``|**Defined in `std::regex` and `std::regex_constants::syntax_option_type`**|
    |`icase`|ignore case during the match|
    |`nosub`|don't store subexpression matches|
    |`optimize`|favor speed of execution over speed of construction|
    |`ECMAScript`|use grammar as specified by ECMA-262|
    |`basic`|use POSIX basic regular-expression grammar|
    |`extended`|use POSIX extended regular-expression grammar|
    |`awk`|use grammar from the POSIX version of `awk` language|
    |`grep`|use grammar from the POSIX version of `grep`|
    |`egrep`|use grammar from the POSIX version of `egrep`|
    * note that we can specify one or more flags that affect how the `std::regex` operates
- a regular expression is "compiled" at **run time** when a `std::regex` object is initialized with or assigned a new pattern
    * therefore, construcing a `std::regex` objedct and assigning a new regular expression to an existing `std::regex` can be **time-consuming**
        + which means, you should try to avoid creating more `std::regex` objects than needed
        + moreover, if you use a regular expression in a loop,
            - you should create it outside the loop
    * if we make a mistake in writing a regular expression, then at **run time** the library will throw an exception of type `std::regex_error`
        + `std::regex_error` has `.what()` as other exception classes, and it also has `.code()` method which returns a numeric code corresponding to the type of error that was encountered
        + the following table shows the error conditions

        ||Regular Expression Error Conditions|
        |:---:|:---:|
        ||**Defined in `std::regex` and in `std::regex_constants::error_type`**|
        |`error_collate`|invalid collating element request|
        |``||
        |``||
        |``||
        |``||
        |``||
        |``||
        |``||


### Subexpressions
The following codes show some examples of **subexpressions**
```c++
std::string pattern;
pattern = "[[:alpha:]]";              // single alphabetic character  
pattern = "[[:alpha:]]+";             // one or more alphabetic character(s)  
pattern = "[[:alpha:]]*";             // zero or more alphabetic character  
pattern = "[[:alpha:]]?";             // zero or one alphabetic character (used to make the component optional)

pattern = "[^c]";                     // single character except for 'c'  
pattern = "[^c]ei";                   // any such letter that is followed by "ei"
pattern = "[-. ]";                    // - or . or space

pattern = "\\d";                      // single digit
pattern = "\\d{n}";                   // sequence of n digits

pattern = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";       // example of the pattern which contains multiple subexpressions to target phone number 

std::regex r(pattern);                // initializes regex class with the pattern
```
- note that the ECMAScript uses the special characters like C++
    * for instance, if you need set .(dot) as a pattern, you need to use \\(backslash) to represent it
        + however, if you use the special character in `[ ]` (which matches any of characters inside square brackets), they have no speical meaning in there
    * moreover, the backslash is also the special character in C++, you need to put additional backslash to represent it
- if there are many subexpressions, they are usually parenthesized  

### Use of sregex_iterator
If you want to get **all** matches, using `std::sregex_iterator` is a good solution
```c++
std::string target = "input sequence";
std::string pattern = "some pattern";
std::regex r(pattern);

for (std::sregex_iterator cur(target.begin(), target.end(), r), end; cur != end; cur++) {
    std::cout << "prefix : " << cur->prefix().str() <<  "\nmatched : " << cur->str() << "\nsuffix : " << cur->suffix().str() << std:: endl; 
}
```
- it's an iterator adaptor bound to the input sequence and `std::regex` object
- when you construct the iterator with the proper arguments, it implicitly calls `std::regex_search` to find the first match
    * if you default construct it, it would be the "off-the-end" iterator
- dereferencing it returns `std::smatch` object that contains the most recent search result
    * the following table shows the operations on `std::smatch`
        ||`std::smatch` Operations|
        |:---:|:---:|
        ||**These Operations also apply to the `std::cmatch`, `std::wsmatch` and the cooresponding `std::csub_match`, `std::wssub_match` and `std::wcsub_match` types**|
        |`m.ready()`|returns `true` if `m` has been set by a call to `std::regex_search` or `regex_match`; `false` otherwise; operations on `m` are undefined if `.ready()` returns `false`|
        |``||
        |``||
        |``||
    * the following table shows the operations on `std::ssub_match`
        ||Submatch Operations|
        |:---:|:---:|
        ||**Note: These operations apply to `std::ssub_match`, `std::csub_match`, `std::wssub_match`, `std::wcsub_match`**|
        |`matched`|a `public bool` data member that indicates whether this `std::ssub_match` was matched|
        |``||
        |``||
        |``||
        |``||
- if you increment it, it would find the next one

### Use of regex_replace
If you want to use some of the matched results with the different format, you can achieve this by using `std::regex_replace`
```c++
std::string pattern = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";       // example of the pattern which contains multiple subexpressions to target phone number 
std::string format = "$2.$5.$7";        // reformat numbers to ddd.ddd.dddd

std::regex r(pattern);
std::string target = "(123) 456-7890";
std::cout << std::regex_replace(target, r, format) << std::endl;

std::smatch results;
std::regex_search(target, results, r);
std::cout << results.format(format) << std::endl;
```
- note that `&n` represents the match result from the nth subexpression
    * unlike indexing, it counts from 1
- `std::regex_replace()` and `.format()` from `std::smatch` object returns the same output



## Random Numbers
Prior to the new standard, both C and C++ relied on a simple C library function named `rand`
- that function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system-dependent maximum value that is at least 32767
    * the `rand` function has several problems :
        + many, if not most, programs need numbers in a different range from the one produced by `rand`
        + some applications require random floating-point numbers
        + some programs need numbers that reflect a nonuniform distribution
- to solve these problems, the library defines the `<random>` header which contains a set of cooperating classes :
    * **random-number engines**
        + an engine is a type that generates a sequence of random `unsigned` integers
    * **random-number distributions**
        + a distribution is a type that uses an engine to return numbers according to a particular probability distribution
- hence, the C++ programs should not use the library `rand` function
    * instead, they should use the engine with the proper distribution

### Random-Number Engines and Distributions
The random-number engines are function-object classes that define a call operator that takes no arguments and returns a random `unsigned` number
- random-number engines
    * we can generate raw random number by calling an object of a random-number engine type
    * there are several engines defined in the library
        + each compiler designates one of these engines as the `std::default_random_engine` type
        + the list of engines would be covered later in this chapter
    * the following table shows the operations of the engine

    ||Random Number Engine Operations|
    |:---|:---|
    |`Engine e;`|default constructor; uses the default seed for the engine type|
    |`Engine e(s);`|uses the integral value `s` as the seed|
    |`e.seed(s)`|reset the state of the engine using the seed `s`|
    |`e.min()`|the smallest number this generator will generate|
    |`e.max()`|the largest number this generator will generate|
    |`Engine::result_type`|the `unsigned` integral type this engine generates|
    |`e.discard(u)`|advance the engine by `u` steps; `u` has type `unsigned long long`|
    + note that the seed is `std::uint_fast32_t` which is usually just a 32-bit `int`. Every value in the range [0 ~ 2^32) should produce different results
    + using `time()` function defined in the `<ctime>` header as a seed usually doesn't work if the program is run repeatedly as part of an automated process
- random-number distributions
    * to get the properly transformed random number, we need to use the distribution object
    * there are several distributions defined in the library
        + the list of distributions would be covered later in this chapter as well
        + with the exception of the `std::bernouilli_distribution`, the distribution types are templates
        + each of these templates takes a single type parameter that names the result type that the distribution will generate
        + some distribution templates can be used to generate only floating-point numbers; others can be used to generate only integers
        + the distribution templates define the default template parameter
            - the default for the integral distribution is `int`
            - the default for the floating-point is `double`
        + the constructor for each distribution has parameters that are specific to the kind of distribution
            - some of these parameters specify the range of the distribution, such as `std::uniform_int_distribution<IntT> u(m, n)`
            - and these ranges are alwasy **inclusive**, unlike iterator ranges
    * the following table shows the operations of the distribution

    ||Distribution Operations|
    |:---|:---|
    |`Dist d`|default consturctor; makes `d` ready to use|
    |``|other constructors depend on the type of `Dist`; and the distruction consturctors are `explicit`|
    |`d(e)`|successive calls with the same `e` produce a sequence of random numbers according to the distribution type of `d`; `e` is a random-number engine object|
    |`d.min()`|return the smallest number `d(e)` will generate|
    |`d.max()`|return the largest number `d(e)` will generate|
    |`d.reset()`|reestablish the state of `d` so that subsequent uses of `d` don't depend on values `d` has already generated|
- when we refer to a **random-number generator**, we mean the combination of a distribution object with an engine

### Things to Consider
- a given random-number generator always produces the same sequence of numbers
    * a function with a **local** random-number generator should make that generator (both the engine and distribution objects) `static`
    * otherwise, the function will generate the identical seuqnce on each call
- because engines return the same sequence of numbers
    * it's essential that we declare engines **outside** of loops
    * otherwise, we'd create a new engine on each iteration and generate the same values on each iteration
    * similarly, distributions may retain state and should also be defined outside loops

### List of Engines
Explanation ddddd
||Random Number Engines|
|:---|:---|
|`default_random_engine`|type alias for one of the other engines intended to be used for most purpose|
|``||
|``||
|``||

### List of Distributions
Explanation ddddd
||Random Number Engines|
|:---|:---|
|`default_random_engine`|type alias for one of the other engines intended to be used for most purpose|
|``||
|``||
|``||


## The IO Library Revisited

### Formatted Input and Output
The library defines a set of **manipulators** that **modify the format** state of a stream
- manipulators are used for two broad categories of output control :
    * controlling the presentation of numeric values
    * controlling the amount and placement of padding
- most of the manipulators that change the format state provide set/unset pairs
- it's usually best to **undo** whatever changes are made as soon as those changes are no longer needed
    * manipulators that change the format state of the stream usually leave the format state changed for all subsequent IO
- `std::endl` is the typcial example of manipulators
    * which means, you use the other manipulators in the same way we use the `std::endl`

### List of Manipulators
The library defines manipulators in two header files
- `<iostream>`
    ||Manipulators Defined in `<iostream>`|
    |:---|:---|
    |`boolalpha`|display `true` and `false` as strings|
    |``||
    |``||
    |``||
    |``||
    * unless you need to control the presentation of a floating-point number, it's usually best to let the library choose the notation
- `<iomanip>`
    ||Manipulators Defined in `<iomanip>`|
    |:---|:---|
    |`setfill(ch)`|fill whitespace with `ch`|
    |``||
    |``||
    |``||
    * `std::setw`, like `std::endl`, does not change the internal state of the output stream
        + it determines the size of only the next output
    
### Unformatted I/O Operations
The library provides a set of low-level operations that support **unformatted IO**
- Single-Byte
    ||Single-Byte Low-Level IO Operations|
    |:---|:---|
    |`is.get(ch)`|put the next byte from the `std::istream` `is` in character `ch`. returns `is`|
    |``||
    |``||
    |``||
- Multi-Byte
    ||Multi-Byte Low-Level IO Operations|
    |:---|:---|
    |`is.get(sink, size, delim)`||
    |``||
    |``||
    |``||
    * it's a common error to intend to remove the delimiter from the stream but to 
    forget to do so
- if you can use the more type-safe, higher-level operations supported by the library, it's usually better to do so

## Random Access to a Stream
The library provides a pair of functions to *seek* to a given location and to *tell* the current location in the associated stream
- random IO is an inherently system-dependent
    * to understand how to use these features, you must consult your system's documentation
- the `std::istream` and `std::ostream` types usually do **not support** random access
    * other types (`std::fstream` or `std::sstream`) **do support**
- to support random access, the IO types maintain a **marker** that determines where the next read (getting) or write (putting) will happen
    * but note that there is only **single** marker, we must do a `seek` to reposition the marker whenever we switch between reading and writing so that it's safe to do so
- the following table shows the random IO functions
    ||Seek and Tell Functions|
    |:---|:---|
    |`tellg()`||
    |`tellp()`||
    |``||
    |``||
    |``||

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}