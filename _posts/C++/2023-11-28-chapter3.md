---
title: "Chapter 3"

categories:
    - cpp

tags:
    - [C++, Programming Language, STL, Vector, String, Iterator, Array]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-11-28
---

# Strings, Vectors, and Arrays

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Namespace using Declaration

### using Declaration
in order to use a name inside a certain namespace, you should type like this : `namespace::name` <br>
but with **using** declaration, you can skip ' namespace:: ' part 
```c++
#include <iostream>

using std::cin;                     // using declaration
using std::endl; using std::string; // multiple using delcarations

int main() {
    int i;

    cin >> i;       // ok
    
    cout << i;      // error
    std::cout << i; // ok

    return 0;
}
```
- :: is the scope operator which let compiler look in the scope of the left-hand operand for the name of the right-hand operand
- when you want to use multiple using declarations in a single line, you need to separate which declaration by semicolon and put using respectively
- headers should not include using declaration
    * because source codes which includes them may not want to use that using declaration

## Library string Type

### Use the C++ version of C Libarary Headers
The C++ library incorporates the C library for facilities defined specifically for C++
```C++
#include <name.h>   // c style header
#include <cname>    // c++ style header

// example
#include <ctype.h>
#include <cctype>
```
- the c++ version of these headers are named cname - they remoe the .h suffix and preced the name with the letter c
- in particular, the names defined in the cname headers are defined inside the std namespace, whereas those dfined in the .h versions are not

### STL and sequential container
- in this chapter, string and vector which are sequential container of STL are covered in order to know how to use them in basic way
- STL would be covered deeply in later chapter

### std::string
string is a class which handles the **variable-length** sequence of characters 
```c++
#include <string>
... // some codes

// basic initialiation of std::string
std::string s1;             // default initialization
std::string s2 = s1;        // s2 is the copy of s1
std::string s2(s1);         // same as std::string s2 = s1; 
std::string s3 = "value";   // s3 is the copy of string literal not including null character
std::string s3("value");    // same as std::string s3 = "value"; 
std::string s4(n, 'c');     // s4 is initialized with n copies of character 'c'
```
- in oder to use string class, you need to include \<string> header file
- because string class is defined in std namespace, you need to specify std:: to using string class
    * if you don't want this, try to use using declaration : `using std::string;`
- if string is created by default initialization, it becomes an empty string
- when you intialize an object, there are 2 types based on the existence of =
    * if there is = for initialization, then it would be **copy initialization**
        + through this type of initialization, the object is a copy of the initializer
    * f there is not = for initialization, then it would be **direct initialization**
        + through this type of initialization, the object is initialized by the implemented way of class author


### Operations on strings
||Basic string Operations|
|:---:|:---|
|`os << s`|Writes s onto ouput stream os. Returns os.|
|`is >> s`|Reads whitespace-separated string from is into s. Returns is.|
|`getline(is, s)`|Reads a line of input from is into s. Retuns is.|
|`s.empty()`|Returns true if s is empty; otherwise returns false.|
|`s.size()`|Returns the number of characters in s.|
|`s[n]`|Returns a reference to the char at position in n in s; positions start at 0.|
|`s1 + s2`|Returns a string that is the concatenatio of s1 and s2.|
|`s1 = s2`|Replaces characters in s1 with a copy of s2.|
|`s1 == s2`|Returns true if s1 and s2 contain the same characters. Equality is case-sensitive.|
|`s1 != s2`|Opposite case of ==|
|`<, <=, >, >=`|Comparision are case-sensitive and use **dictioary ordering**|
```c++
string s1, s2;

std::cin >> s1 >> s2;       // becuase std::cin>> s1 returns std::cin, we can chain multiple i/o

while(std::cin >> s1)       // read until end-of-file
    std::cout << s1 << std::endl;
```
- i/o operation
    * streams for standard i/o use white space for separator, and once it finds white space, it discards it
    * i/o stream can be used as condition, in this case, it returns true if it handles valid i/o and not end-of-file, and false for opposite case
- `getline()` function
    * similar to input operator(>>)
    * difference: getline uses new line character only as separator
        + hence, when it finds new line character, it stops reading and discards that new line character
        + if the fisrt character is new line character, it returns empty string
    * getline returns the given input stream, so getline() function can be used inside a condition
- `s.empty()` and `s.size()` method
    * becuase they are methods (functions defined inside a class), you need to use .(dot operator) to call them
    * s.size() method returns not int but std::string::size_type
        + this type is a **companion type**
        + most classes in STL have their own companion types
        + the reason why they use companion type is because they want to use their companion type in a machine-independent manner
        + if you want an object which contains the size, try to use auto instead of int
- `==` : equality operator
    * two strings are equal if
        + they have same length
        + and have same characters (case sensitive)
- `<, <=, >, >=` : relational operators
    * they use the same strategy as a dictionary
        1. if two strings have different lengths and if every character in the shorter string is equal to the corresponding character of the longer string, then the shorter string is less than the longer one
        2. if any characters at corresponding positions in the two strings differ, then the result of the string comparsion is the result of comparing the first character at which the strings differ
- `+` : concatenation
    * concatenation can be executed between string and string literals
        + but at least on operand to each + operator must be of string type
        + which means concatenation can not be done between string literals only

### How to access the character of a string
There are 2 ways to do so
- **range for** statement
    * this new statement would be covered deeply in the later chapter, hence in this chapter, basic use of it would be covered
    * if you want to access every element, try this way
    ```c++
    std::string str = "value"

    for(auto curChar : str) {
        ...     // do something
    }

    for(auto & curChar : str) {
        curChar = 'a';  
    }
    ```
    * curChar is the character of the given string str
    * range for statement iterates str from the first element to the last one
    * if you want to chnage the value of the certain character, you need to set curChar as a reference
- subscript operator( [ ] )
    * this operator just does **indexing** like using array
    * if you want to access to certain elements, try this way
    * because it's same as indexing, the valid range is 0 to size() - 1
        + the result of using an index outside this range is **undefined**
        + subscripting an empty string is also **undefined**
        + hence, when you use subscript operators, check whether the index is valid
- iterators
    * you can access the element of containers in STL by using their iterators
    * but they would be covered in the later chapter





[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}