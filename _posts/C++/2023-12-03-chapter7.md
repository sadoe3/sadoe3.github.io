---
title: "Chapter 7"

categories:
    - cpp

tags:
    - [C++, Programming Language, Class]

toc: true
toc_label: "목차"
toc_sticky: false
classes: wide

date: 2023-12-3
---

# Classes

> 이 포스트는 C++ Primer(5th Edition)를 바탕으로 작성되었습니다.

## Defining Abstract Data Types

### 3 Core Concepts of OOP
There are 3 core concepts of Object-Oriented Programming.
- Data Abstraction
    * it is a **programming (and design) technique** that relies on the separtion of **interface** and **implementation**
    * you can think of the implmentation as the whole definition of the class, and the interface as the members of the class which the users of the class can execute
- Encapsulation
    * it is to **separate** the interface and the implementation so that the users of the class can use the interface but have no access to the implementation
- Dynamic Binding
    * this concept is related to **inheritance** which would be covered in the later chapter

### Abstract Data Type
A class that uses **data abstraction** and **encapsulation** defines an **abstract data type**.
- in an abstract data type, only the class designer worries about how the class is implemented
- programmers who use the class need not know how the type(class) works
    * they can instead think **abstractly** about what the type does

### 2 Types of members
The class has 2 types of its members.
```c++
// exmaple of the defintion of the class
struct ClassName {
    int dataMember;

    double memberFunctionA() { return 3.2; }
    double memberFunctionB();
};
... // some codes
ClassName a;        // suppose the default-intialization is implemented
a.memberfunctionA();
```
- data member
    * data members must be declared inside the class body
    * data members may be initialized inside the class body or through the constructor
- member function (method)
    * member functions msut be declared inside the class body
    * member functions may be defined inside or outside the class body
- class definition consists of the keyword `class` or `struct` and the name of the class and the body of the class
- the user of the class can access to its member by using `.(dot operator)`
- you must put `semi-colon` after the ending braces of the class definition

### this parameter
Every member function of the class has **implicit** `this` parameter.
```c++
struct ClassName {
    int dataMember;
    double memberFunctionB() {
        return this->datamember * 3.22;
    }
};
```
- `this` parameter is a **constant pointer** which points to the object of the class on which the member function was invoked
- because `this` parameter is **reserved** for this special use, we can't set the name of the paramter as "this"
    - also, because `this` is the **implicit** parameter, it's not visible from the paramter list
- any direct use of a member of the class is asssumed to be an implicit reference through `this`

### const member function
Because `this` is the **implicit** parameter, there's no way to set it as the constant pointer to a constant by using the exisiting concept.
- in order to implement this, we need to learn the new concept : **const member function**
```c++
struct ClassName {
    const int a = 3;
    int memberFunction() const {
        return a*3;
    }
    int memberFunction() {
        return a;
    }
};
...     // some codes
ClassName a;
a.memberFunction(); // 3 is returned
const ClassName b;
b.memberFunction(); // 9 is returned
```
- when we place `const` after the parameter list, we set the member function as the **const member function**
    * it makes `this` as the constant pointer to a constant
    * so that you can't change the value of the data member through this member function unless they are `mutable`
- it's possible to overload member functions based on the `const`
    * because **const member functions** are called only from the **const object**

### Order of compilation
When compiler compiles the class, it compiles the declarations of data members first, and then, it compiles the functions bodies of the member functions
```c++
struct ClassName {
    int memberFunction() {
        return a;       // ok;
    }
    const int a = 3;
};
``` 
- although some data members are defined after the definition of the member function in the class body, the function still can use them
    * because they're compiled first

### Defining a method outside the function body
When you define a method outside the function body, just do the same thing as you define a normal function with one exception : `ClassName::methodName()`
```c++
struct ClassName {
    int memberFunction();   // method declaration
    const int a = 3;        // in-class initialization
};
int ClassName::memberFunction() {       // defining the method outside the class body
    return a;
}
```
- you need to use `::(scope operator)` in order to access to the member function becuase the member function is in the class(scope)

### return *this
It's possible to return the object itself by returning `*this`
```c++
struct ClassName {
    ClassName& memberFunction() { return *this; };
    const ClassName& memberFunction() const { return *this; };
};
```
- because **const member function** has `this` as the constant pointer to the constant, the return type of `*this` should be the reference to the constant

## Specialized Member Functions
There are 3 types of the specialized member functions
- constructors
    * a constructor is a member function which is called first **automatically** when the object of the class is created
    * the job of the constructor is to **initialize** its data members and to execute certain codes if needed right after the initialization phase 
- overloaded operators
    * you can overload various operations on the classes by implementing overloaded operations
- destructors
    * a destructor is a member function which is called **automatically** when the object of the class is destroyed
- the overloaded operators and destructors would be covered in the later chapter

### Synthesized Member Functions
When you don't implement the specialized member functions, compiler creates them instead
- constructor
    * if you don't declare any constructors, compiler creates the **default constructor** also called as **synthesized member function**
    * **default constructor** initializes the data members as follows
        + if there is an in-class initializer, use it to initialize the member
        + otherwise, default-initialize the member
- overloaded operators
    * copy, and assign operators are made if they are not implemented
- desturctors
    * if you don't declare the destructor, it's created by the compiler as well

### Constructors
Constructors have the following features
- they don't have the return type
- they have the same name as the class
- they can be overloaded with different parameters
    * you can overload normal member functions as well
```c++
struct ClassName {
    ClassName() = default;   // default constructor
    ClassName(const std::string & inputName, const int & inputWeight) : name(inputName), weight(inputWeight) {}
    ClassName(const int & inputWeight);

    int age = 3;             // in-class initialization
    std::string name;
    double weight;
};

ClassName::ClassName(const int & inputWeight) : name("nobody"), weight(inputWeight) {}
```
- if there are constructors declared in the class definition, compiler doesn't create the default constructor
    * in this case, we can **request** the compiler to implement the default constructor by using `= default` to the constructor with empty parameter
- note that we initialize the data member inside **Constructor Initializer List** where is after parameter list and before function body
    * we initialize the data members by using direct initialization
    * the only job of the function body is to contain some codes which need to be executed right after the initialization phase
    * if you omit some data members inside the **Constructor Initializer List**, they would be default-initialized unless there're in-class initializers
    * therefore, it's possible not to specify **Constructor Initializer List** so that the constructor initialize the data member in the same way as default constructor does
- it's possible to define the constructor outside the class defintion
    * same rules are applied to constructor as defining methods outside with two exceptions
        + it doesn't have the return type
        + it initializes data members inside **Constructor Initializer List**

## Access Specifiers
There are 3 types of **access specifiers** which control the access level of the members
- `public`
    * members defined after a `public` specifier are accessible to all parts of the program
    * hence, the `public` members define the **interface** to the class
- `protected`
    * it's related to the concept of **inheritance**, hence it would be covered in the later chapter
- `private`
    * members defined after a `private` specifier are accessible to the member functions of the class but are **not** accessible to codes that uses the class
    * hence, the `private` sections **incapsulate(hide)** the implementation

### How to specify the access level
```c++
class ClassName {
public:
    ClassName() = default;   // default constructor
    ClassName(const std::string & inputName, const int & inputWeight) : name(inputName), weight(inputWeight) {}

private:
    int age = 3;             // in-class initialization
    std::string name;
    double weight;
};
... // some codes
ClassName a;
a.age;                      // error; impossible to access private member
```
- you can put the public section after `public:` and the private section after `private:`
- if there's no access specifier provided inside the class defintion, then the **default access level** is used to specify the access level of the members
    * `class` has the `private` as its **default access level**
    * `struct` has the `public` as its **default access level**
    * this is the only difference between `class` and `struct` in C++

### Non-member Class-Related Functions
- in some cases, you need to implement functions which handle the class, but is not part of the class
    * these functions should be declared in the same header as the class itself

### Friend Functions
If you want the non-member class-related functions to have the access to the implementation of the class, you can set it by declaring the function as the **friend** of the class
```c++
class ClassName {
friend int func(ClassName a);
public:
    ClassName() = default;   // default constructor
    ClassName(const std::string & inputName, const int & inputWeight) : name(inputName), weight(inputWeight) {}

private:
    int age = 3;             // in-class initialization
    std::string name;
    double weight;
};
int func(ClassName a);       // declaration or definition should exist before the call of the function
```
- note that, by default, the `friend` declaration is just to give the access to the function which means it is not the general function declaration
    * hence, you need to declare or define the function before the call of it
- also, the access level is not important for `friend` declaration because it doesn't mean anything to the function  

## Additional Class Features

### Type Members
A class can define its own local names for types
```c++
class ClassName {
public:
    typedef std::string::size_type s_pos;
    using v_pos = std::vector::size_type;
private:
    s_pos cursor = 0;
    v_pos width = 3;
};
```
- it can be implemented in both ways : `typedef` and `using`
- you can think of type members as the data members
    * hence, you need to specify the access level
    * also, you need to define type members before declaring the data members which use them as their type
        + as a result, type members usually appear at the beginning of the class

### inline member functions
You can set the member functions as `inline`
- if you define the member functions inside the class body, they are **implicitly** `inline` member functions
- you can **explicitly** define the member function as `inline` by placing `inline` before return type like normal function
    * this can be done inside the class body or outside as well

### mutable data members
If you want to change the value of the data member inside the **const member function**, you can achieve this by setting the data member as `mutable`
```c++
class ClassName {
public:
    int memberFunction() const { 
        age = 1;             // error;
        weight = 3.1;        // ok
    }

private:
    int age = 3;             // in-class initialization
    std::string name;
    mutable double weight;
};
```
- you can set the data member as `mutable` by placing `mutable` keyword before the type of the member

### in-class initialization of the data member of the class type
You can initialize the data member of the class type inside the class body
```c++
class ClassName {
    std::string name = std::string(3, 'c');         // ok
    std::string name(3, 'c');                       // error
    std::string name{3, 'c'};                       // ok
};
```
- you can achieve this in 2 ways
    * `= constructor()`
    * `{ }`
        + note that you need to use curly braces to do the direct initialization not just normal parentheses

### Class Declaration
You can declare the classes
```c++
class ClassName;

ClassName funcA(ClassName &, int);  // ok
int funcA(double a, ClassName b) {  // error
    ... // some codes
};

int main() {
    ClassName objectName;       // error
    ClassName * ptr;            // ok
}

class Class2 {
    Class2* next;               // ok
    Class2* prev;               // ok
};
```
- This declaration is sometimes called **forward delcaration**
- the class which has the declaration but not the definition is the **incomplete type**
    * the incomplete type is utilized in only limited ways
        + it's possible to define compound types to the incomplete types
        + it's possible to declare (**not define**) functions that use the incomplete type as a parameter or return type
            - therefore, it's possible for a class to have a pointer to the type of itself as its data member
    + otherwise, we are unable to use it
        + it's not possible to create the object of the incomplete type
        + it's not possible for the compound types to the incomplete types to access the object of the incomplete types 

### Friend Classes
It's also possible to make another **class** or the **member function** of another class as a `friend` of the class
```c++
class ClassB;               // need to be declared first so that ClassA can have the parameter of ClassB

class ClassA {
public:
    int member(ClassB input);   // need to be defined after the definition of ClassB because it's incomplete type at this point
};

class ClassB {
friend class ClassA;                        // you can set the class as its friend
friend int ClassA::member(ClassB);          // or the member function as its friend

private:
    int age = 3;
};

int ClassA::member(ClassB input) {
    return input.age;
}
...              // some codes
ClassA a;
ClassB b;
a.member(b);            // ok
```
- when you make the class or a member function as a friend, the **order** of declaration and definition matters
    1. you need to declare the `ClassB` first in order to support incomplete type feature for `ClassA`
    2. then, the member function of `ClassA` is declared but not defined yet until the `ClassB` is defined
    3. after `ClassB` is defined, define the member function of `ClassA`


## Class Scope


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}